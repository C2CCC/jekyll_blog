<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>pushState()、popstate事件配合ajax实现浏览器前进后退页面局部刷新</title>
    <url>/2015/06/06/pushstate-popstate-ajax-and-partial-refresh/</url>
    <content><![CDATA[<p>最近研究pushState，看了网上的文章还是不怎么会用，于是自己摸索着理解使用，终于实现局部刷新同时前进后退。</p>
<p>首先说说pushState()，这个函数将当前的url等信息加入history堆栈中；<br>当点击浏览器的前进后退按钮时，会触发popstate事件，所以可以在onpopstate的时候使用ajax实现局部刷新前进后退。</p>
<p>我的方法(用jQuery)：<br>1、定义两个函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajaxLoad</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//里面加载ajax</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setState</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> stateobj = (&#123;<span class="comment">//里面存放url等信息，stateobj将作为pushState()的第一个参数</span></span><br><span class="line">url:url,</span><br><span class="line">title:title</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">window</span>.history.pushState(stateobj,<span class="literal">null</span>,url);<span class="comment">//将当前url加入堆栈中</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2、正常浏览使用ajax时</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;a&#x27;</span>).on(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;<span class="comment">//假设点击a标签加载ajax</span></span><br><span class="line">event.preventDefault();<span class="comment">//防止跳转</span></span><br><span class="line">ajaxLoad();</span><br><span class="line">setState();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>3、onpopstate</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;popstate&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> state = event.state;<span class="comment">//取得目标url的state，这样就可以通过state.url等方式访问之前stateobj中的内容</span></span><br><span class="line">ajaxLoad();</span><br><span class="line"><span class="comment">//注意：此处不要调用setState();了，因为在历史记录堆栈中跳转时不需要往堆栈中写入数据</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>注意：<br>setState()的作用是往历史记录堆栈中添加一条记录；<br>ajax载入进来的元素（如a、button标签等）如有事件要在载入后重新绑定事件；</p>
<p>前端小白学习时所得，如有更好的方法欢迎讨论，代码写得菜求轻喷~</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>pushState</tag>
        <tag>popstate</tag>
      </tags>
  </entry>
  <entry>
    <title>关于新增元素使用jQuery on()方法重复绑定的问题</title>
    <url>/2015/06/08/jquery-on-repeat-binding-problem/</url>
    <content><![CDATA[<p>最近写ajax新增元素button绑定click事件的时候发现元素重新添加进来的时候会多执行一次事件函数，找了半天，怀疑是on()的问题，于是测试了一下，果然是因为on()的使用方式造成了有的新增元素会执行多次绑定事件函数。</p>
<p>当使用<code>$(document).find(&#39;target-selector&#39;).on(event,function);</code>时，必须在元素每次添加进来之后重新绑定，否则会无效。<br>而使用<code>$(document).on(event,selector,function);</code>时，只需执行一次绑定即可，可以在开头就写好绑定，对后面添加进来的元素都有效，如果在元素每次添加进来之后都绑定，则绑定了几次，触发事件的时候就会执行几次事件函数。</p>
<p>下面是一个测试来说明这个问题（需要jQuery）。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/jquery-1.11.1.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Just a test.<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">      button &#123;</span><br><span class="line">        margin: 10px;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      $(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        $(<span class="string">&#x27;.addOnTest&#x27;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">          var buttons = &#x27;<span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;onTest1&quot;</span>&gt;</span>使用.find().on(event,function)的按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;onTest2&quot;</span>&gt;</span>使用.on(event,selector,function)的按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span>&#x27;;</span></span></span><br><span class="line"><span class="javascript">          $(<span class="string">&#x27;.test&#x27;</span>).append(buttons);</span></span><br><span class="line">        &#125;);</span><br><span class="line"><span class="javascript">        $(<span class="string">&#x27;.delOnTest&#x27;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          $(<span class="string">&#x27;.onTest1&#x27;</span>).remove();</span></span><br><span class="line"><span class="javascript">          $(<span class="string">&#x27;.onTest2&#x27;</span>).remove();</span></span><br><span class="line">        &#125;);</span><br><span class="line"><span class="javascript">        $(<span class="string">&#x27;.ontest&#x27;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          $(<span class="built_in">document</span>).find(<span class="string">&#x27;.onTest1&#x27;</span>).on(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">&#x27;111&#x27;</span>);</span></span><br><span class="line">          &#125;);</span><br><span class="line"><span class="javascript">          $(<span class="built_in">document</span>).on(<span class="string">&#x27;click&#x27;</span>, <span class="string">&#x27;.onTest2&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">&#x27;222&#x27;</span>);</span></span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;addOnTest&quot;</span>&gt;</span>新增两种类型的按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;delOnTest&quot;</span>&gt;</span>删除两种类型的按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;ontest&quot;</span>&gt;</span>为新增按钮绑定事件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>测试步骤：</span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span> /&gt;</span> 1、点击“新增两种类型的按钮”新增两个不同类型的按钮</span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span> /&gt;</span> 2、点击“为新增按钮绑定事件”分别为两个新增按钮绑定点击事件</span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span> /&gt;</span> 3、分别点击新增的两个按钮，可以发现，两个按钮点击时都执行了绑定的事件（都有alert）</span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span> /&gt;</span> 4、点击“删除两种类型的按钮”，再点击“新增两种类型的按钮”</span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span> /&gt;</span> 5、分别点击新增的两个按钮，可以发现，第一个按钮不执行绑定事件（没有alert），第二个按钮执行了绑定事件（有弹出alert窗口）</span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span> /&gt;</span> 6、点击“为新增按钮绑定事件”</span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span> /&gt;</span> 7、分别点击新增的两个按钮，可以发现，第一个按钮执行了一次绑定事件（一个alert），而第二个按钮执行了两次（两个alert）</span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>所以，对新增的元素，要么每次都使用<code>.on(event,function);</code>绑定，要么只要使用<code>$(document).on(event,selector,function);</code>绑定一次就好了。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>on</tag>
        <tag>jquery</tag>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>script标签不带属性与带async、defer的区别</title>
    <url>/2016/07/13/script-with-or-without-async-and-defer/</url>
    <content><![CDATA[<p><code>&lt;script&gt;</code><br>当页面解析到script标签时，会停止解析并下载对应的脚本，并马上执行，执行完毕后再继续解析页面</p>
<p><code>&lt;script async&gt;</code><br>async 在下载脚本的同时不会停止解析HTML，但是在下载完成后会停止解析并开始执行，执行完毕后继续解析页面</p>
<p><code>&lt;script defer&gt;</code><br>defer 下载脚本时跟async一样不会停止解析HTML，下载完毕后会延迟到页面解析完后执行</p>
<p>async跟defer都只对外部脚本有效，IE7及更早的版本对嵌入脚本也支持defer；<br>另外，HTML5规范中，defer要按照顺序执行，但实际上defer跟async都不一定会按照顺序执行</p>
<p>参考：<a href="http://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html">http://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>script</tag>
      </tags>
  </entry>
  <entry>
    <title>UWP ComboBox下拉选项滚动循环问题</title>
    <url>/2015/11/30/uwp-combobox-scroll-loop-problem/</url>
    <content><![CDATA[<p>在UWP开发中遇到个小问题，ComboBox的Item太多的话，列表会重复，并且无限循环，Google了一下后发现这貌似是Metro应用的老问题了，由于ComboBox的Items使用的是CarouselPanel而导致的。</p>
<p>解决方法：改变<code>ComboBox</code>的<code>ItemsPanelTemplate</code>为<code>StackPanel</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ComboBox&gt;  </span><br><span class="line">    &lt;ComboBox.ItemsPanel&gt;  </span><br><span class="line">        &lt;ItemsPanelTemplate&gt;  </span><br><span class="line">            &lt;StackPanel Orientation&#x3D;&quot;Vertical&quot;&#x2F;&gt;  </span><br><span class="line">        &lt;&#x2F;ItemsPanelTemplate&gt;  </span><br><span class="line">    &lt;&#x2F;ComboBox.ItemsPanel&gt;  </span><br><span class="line">&lt;&#x2F;ComboBox&gt;</span><br></pre></td></tr></table></figure>

<p>目前发现了这样做的一个问题，ComboBox选择非第一项的选项之后再选择第一项，会出现变成空白，或选不了的bug，暂时没有发现解决办法。</p>
<p>参考：<a href="http://netitude.bc3tech.net/2013/04/12/windows-8s-combobox-and-the-carouselpanel/">http://netitude.bc3tech.net/2013/04/12/windows-8s-combobox-and-the-carouselpanel/</a></p>
]]></content>
      <categories>
        <category>UWP</category>
      </categories>
      <tags>
        <tag>UWP</tag>
        <tag>ComboBox</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript创建对象的几种模式</title>
    <url>/2016/07/14/javascript-create-object/</url>
    <content><![CDATA[<p>看《JavaScript高级程序设计》做的一些笔记</p>
<h1 id="工厂模式："><a href="#工厂模式：" class="headerlink" title="工厂模式："></a>工厂模式：</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params"><span class="built_in">arguments</span></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.name = name;</span><br><span class="line">  o.age = age;</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure>
<p>解决创建多个相似对象的问题</p>
<p>缺点：<br>没有解决对象识别问题</p>
<h1 id="构造函数模式："><a href="#构造函数模式：" class="headerlink" title="构造函数模式："></a>构造函数模式：</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"><span class="built_in">arguments</span></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="built_in">arguments</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure>
<p>构造函数名大写字母开头<br>person1有constructor（构造函数）属性，指向Person</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">person1.constructor == Person  <span class="comment">//true</span></span><br><span class="line">person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>  <span class="comment">//true</span></span><br><span class="line">person1 <span class="keyword">instanceof</span> Person  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>构造函数当做普通函数使用，属性和方法都添加给window</p>
<p>缺点：<br>每个方法在每个实例上都要重新创建一遍<br>person1.sayName == person2.sayName  //false</p>
<h1 id="原型模式："><a href="#原型模式：" class="headerlink" title="原型模式："></a>原型模式：</h1><p>每个函数都有一个prototype属性，指向一个对象，这个对象可以包含特定类型所有实例共享的属性和方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">&#x27;myName&#x27;</span>;</span><br><span class="line">Person.prototype.age = <span class="number">66</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.name == person2.name  <span class="comment">//myName</span></span><br></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20160714155314757?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="Create Object"></p>
<p>可以通过对象实例访问原型中的值，但不能通过对象实例重写原型中的值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">person1.name = <span class="string">&#x27;newName&#x27;</span>;</span><br><span class="line">person1.name  <span class="comment">//newName（来自实例）</span></span><br><span class="line">person2.name  <span class="comment">//myName （来自原型）</span></span><br></pre></td></tr></table></figure>
<p>访问属性时，若没有在实例中搜索到该属性，就会在原型中搜索并返回该属性<br>使用delete可以删除实例中的属性，此时再访问该属性则会返回原型中的属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> person1.name；</span><br><span class="line">person1.name  <span class="comment">//myName （来自原型）</span></span><br></pre></td></tr></table></figure>

<p>原型与in操作符：</p>
<p>通过对象能够访问属性时返回true（for-in返回能够通过对象访问的、可枚举的属性），无论是在实例中还是原型中</p>
<p>原型模式的一些方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">isPrototypeOf()</span><br><span class="line">Person.prototype.isPrototypeOf(person1)  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf() 返回[[Prototype]]的值</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(person1) == Person.prototype  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(person1.name)  <span class="comment">//myName</span></span><br></pre></td></tr></table></figure>
<p>hasOwnProperty() 检测一个属性是否存在于实例中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">person1.name = <span class="string">&#x27;newName&#x27;</span>;</span><br><span class="line">person1.hasOwnProperty(<span class="string">&#x27;name&#x27;</span>);  <span class="comment">//true</span></span><br><span class="line">person2.hasOwnProperty(<span class="string">&#x27;name&#x27;</span>);  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>hasPrototypeProperty() 检测一个属性是否来自原型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">hasPrototypeProperty(person1,<span class="string">&#x27;name&#x27;</span>);  <span class="comment">//false</span></span><br><span class="line">hasPrototypeProperty(person2,<span class="string">&#x27;name&#x27;</span>);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>Object.keys() 取得对象上所有可枚举的实例属性</p>
<p>Object.getOwnPropertyNames() 获取所有实例属性，无论是否可枚举</p>
<p>原型的对象字面量写法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  name:<span class="string">&#x27;myName&#x27;</span>,</span><br><span class="line">  age:<span class="number">66</span>,</span><br><span class="line">  sayName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种写法的constructor属性不再指向Person，而是指向Object构造函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person3 = <span class="keyword">new</span> Person();</span><br><span class="line">person3 <span class="keyword">instanceof</span> Person  <span class="comment">//true</span></span><br><span class="line">person3 <span class="keyword">instanceof</span> <span class="built_in">Object</span>  <span class="comment">//true</span></span><br><span class="line">person3.constructor == Person  <span class="comment">//false</span></span><br><span class="line">person3.constructor == <span class="built_in">Object</span>  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>缺点：<br>由于其共享的特性，对于包含引用类型值的属性，实例无法有属于自己的属性<br>例如属性中包含数组，若通过实例对象对数组进行修改，由于数组存在于prototype中，则会影响到所有的实例。</p>
<h1 id="组合使用构造函数模式和原型模式-广泛使用-："><a href="#组合使用构造函数模式和原型模式-广泛使用-：" class="headerlink" title="组合使用构造函数模式和原型模式(广泛使用)："></a>组合使用构造函数模式和原型模式(广泛使用)：</h1><p>构造函数模式定义实例属性，原型模式用于定义方法和共享的属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"><span class="built_in">arguments</span></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.friends = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="title">constructor</span>:<span class="title">Person</span>,</span><br><span class="line">  <span class="title">sayName</span>:<span class="title">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




<h1 id="动态原型模式："><a href="#动态原型模式：" class="headerlink" title="动态原型模式："></a>动态原型模式：</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"><span class="built_in">arguments</span></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//属性</span></span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//方法</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">this</span>.sayName != <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">    Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    Person.prototype.otherFunction = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h1 id="寄生构造函数模式："><a href="#寄生构造函数模式：" class="headerlink" title="寄生构造函数模式："></a>寄生构造函数模式：</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"><span class="built_in">arguments</span></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.name = name;</span><br><span class="line">  o.age = age;</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure>
<p>除了使用new和构造函数，这个模式跟工厂模式是一样的</p>
<p>例如要创建一个具有额外功能的Array，由于不能直接修改Array，可以这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialArray</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sa = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">  sa.push.apply(sa,<span class="built_in">arguments</span>);  <span class="comment">//使用apply是因为push如果接收数组作为参数，会将整个数组当做一个元素push</span></span><br><span class="line">  sa.newFunction = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> SpecialArray(<span class="built_in">arguments</span>);</span><br><span class="line">arr.newFunction();</span><br></pre></td></tr></table></figure>




<h1 id="稳妥构造函数模式-安全性考虑-："><a href="#稳妥构造函数模式-安全性考虑-：" class="headerlink" title="稳妥构造函数模式(安全性考虑)："></a>稳妥构造函数模式(安全性考虑)：</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = Person(name,age);</span><br><span class="line">person1.sayName();  <span class="comment">//除了使用sayName()方法之外没其他办法访问到name的值</span></span><br></pre></td></tr></table></figure>


<p>参考：《JavaScript高级程序设计》（第3版）</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title>dataTransfer.getData()在dragover,dragenter,dragleave中无法获取数据的问题</title>
    <url>/2016/05/15/datatransfer-cannot-get-data-on-dragover-dragenter-dragleave/</url>
    <content><![CDATA[<p>做拖拽相关效果时，想在ondragover时给被拖拽元素添加一些样式，于是在dragover事件的函数中通过dataTransfer.getData()获取在dragstart中设置的数据，然而发现dataTransfer.getData()所返回的数据为空。<br>查询资料发现dataTransfer.setData()中所设置的数据是存储在drag data store中，而根据W3C标准，drag data store有三种模式，Read/write mode, Read-only mode跟Protected mode。</p>
<p>W3C Working Draft中5.7.2.关于三种drag data store mode的定义</p>
<blockquote>
<p>A drag data store mode, which is one of the following:</p>
</blockquote>
<blockquote>
<p>Read/write mode<br>For the dragstart event. New data can be added to the drag data store.</p>
</blockquote>
<blockquote>
<p>Read-only mode<br>For the drop event. The list of items representing dragged data can be read, including the data. No new data can be added.</p>
</blockquote>
<blockquote>
<p>Protected mode<br>For all other events. The formats and kinds in the drag data store list of items representing dragged data can be enumerated, but the data itself is unavailable and no new data can be added.</p>
</blockquote>
<p>Read/write mode<br>读/写模式，在dragstart事件中使用，可以添加新数据到drag data store中。</p>
<p>Read-only mode<br>只读模式，在drop事件中使用，可以读取被拖拽数据，不可添加新数据。</p>
<p>Protected mode<br>保护模式，在所有其他的事件中使用，数据的列表可以被枚举，但是数据本身不可用且不能添加新数据。</p>
<p>这样就可以解释为什么dragover中dataTransfer.getData()返回的数据为空，以及在dragover时dataTransfer中的types不为0了，因为在除了dragstart,drop以外的事件，包括dragover,dragenter,dragleave中，drag data store出于安全原因处于保护模式，因此不可访问。<br>如果要实现dragover中访问dragstart中设置的数据，可以采用定义一个全局变量的方法，在dragstart中赋值，之后在dragend中清空。</p>
<p>另外，我在ondragover时，尝试给被拖拽元素添加class以改变其样式发现，虽然拖拽时class已经改变，但在拖拽过程中样式并没有改变，而是等到拖拽动作完成后，也就是drop之后样式才被应用上去，所以在dragover,dragenter,dragleave中做得更多的应该是对数据的处理，而不是应用效果。</p>
<p>另一个问题</p>
<p>我的项目在Chrome中所使用的情况完全符合上述描述，但是在运行如下代码时dragover,dragenter,dragleave中均可获取到dataTransfer中的数据。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;oSource&quot;</span> <span class="attr">data-name</span>=<span class="string">&quot;source element&quot;</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span> </span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"><span class="attr">style</span>=<span class="string">&quot;display:block;cursor:pointer;width:80px;height:50px;&quot;</span>&gt;</span>测试锚<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;oTarget&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>将测试锚拖曳到这里<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">$</span>(<span class="params">dom</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">return</span> <span class="built_in">document</span>.querySelectorAll(dom);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">$(<span class="string">&quot;#oSource&quot;</span>)[<span class="number">0</span>].ondragstart = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="javascript">  event.dataTransfer.setData(<span class="string">&quot;text&quot;</span>, event.target.getAttribute(<span class="string">&quot;data-name&quot;</span>));</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">$(<span class="string">&quot;#oTarget&quot;</span>)[<span class="number">0</span>].ondragover = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span></span></span><br><span class="line">&#123;</span><br><span class="line">  event.preventDefault();</span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> sAnchor = event.dataTransfer.getData(<span class="string">&quot;text&quot;</span>);</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(sAnchor + <span class="string">&quot; being dragged&quot;</span>);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">$(<span class="string">&quot;#oTarget&quot;</span>)[<span class="number">0</span>].ondrop = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span></span></span><br><span class="line">&#123;</span><br><span class="line">  event.preventDefault();</span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> sAnchor = event.dataTransfer.getData(<span class="string">&quot;text&quot;</span>);</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(sAnchor + <span class="string">&quot; dropped&quot;</span>);</span></span><br><span class="line"><span class="javascript">  $(<span class="string">&quot;#oTarget&quot;</span>)[<span class="number">0</span>].innerText = sAnchor;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>待解释。</p>
<p>————————————————————————<br>update 2016/5/15 18:42<br>关于上述问题</p>
<p>上面那个示例可以在dragover中通过dataTransfer.getData()获取数据的原因是我直接打开文档运行了，如果放到wamp中一样获取不到数据。</p>
<p>引用：</p>
<p><a href="https://www.w3.org/TR/html51/editing.html#drag-and-drop">HTML 5.1 W3C Working Draft, 3 May 2016</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>dataTransfer</tag>
        <tag>dragover</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript的几种继承方式</title>
    <url>/2016/07/15/javascript-inheritance/</url>
    <content><![CDATA[<p>看《JavaScript高级程序设计》做的一些笔记</p>
<p>ECMAScript只支持实现继承，不支持接口继承（因为函数没有签名）</p>
<p>原型链（实现继承的主要方法）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.property;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//继承SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br></pre></td></tr></table></figure>

<p><img src="http://img.blog.csdn.net/20160715123200377?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="inheritance_1"></p>
<p>通过原型链实现继承时不能使用对象字面量创建原型方法，否则会重写原型链<br>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义SubType的原型方法</span></span><br><span class="line">SubType.prototype = &#123;  <span class="comment">//这样定义会使上面那行代码无效</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所有函数的默认原型都是Object的实例，因此SuperType.prototype中的[[Prototype]]会指向Object.Prototype</p>
<p>问题：<br>原型变成另一个类型的实例，原来的实例属性就变成原型属性了，因此包含引用类型值的属性会被所有SubType实例共享（例如数组）</p>
<p>借用构造函数：</p>
<p>在子类型的构造函数中使用call()或apply()调用超类型的构造函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.colors = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//继承SuperType</span></span><br><span class="line">  SuperType.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以在子类型构造函数中向超类型构造函数传递参数</p>
<p>问题：<br>方法都在构造函数中定义，函数无法复用（类似构造函数模式）；在超类型原型中定义的方法对子类型不可见</p>
<p>组合继承(常用继承模式)：</p>
<p>将原型链和借用构造函数组合到一块（类似组合使用构造函数模式和原型模式）<br>用原型链实现对原型属性和方法的继承，用借用构造函数实现对实例属性的继承</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name;</span><br><span class="line">  <span class="built_in">this</span>.colors = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//继承属性</span></span><br><span class="line">  SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//继承方法</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType(<span class="string">&#x27;myName&#x27;</span>, <span class="number">66</span>);</span><br></pre></td></tr></table></figure>

<p><img src="http://img.blog.csdn.net/20160715123502990?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="inheritance_2"></p>
<p>问题：<br>无论什么情况下都会调用两次超类型构造函数<br>同时，父类构造函数中的属性会被继承到子类的原型上</p>
<p>原型式继承：</p>
<p>基于已有的对象创建新对象，同时还不必因此创建自定义类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name:<span class="string">&#x27;myName&#x27;</span>,</span><br><span class="line">  friends:[]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherPerson = object(person);</span><br><span class="line">anotherPerson.name = <span class="string">&#x27;anotherName&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>ECMAScript5通过Object.create()规范原型式继承</p>
<p>问题：<br>与使用原型模式一样，包含引用类型的值会共享</p>
<p>寄生式继承：</p>
<p>将继承过程封装成函数，并增强对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> clone = object(original);</span><br><span class="line">  clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = createAnother(person);</span><br><span class="line">anotherPerson.sayHi();</span><br></pre></td></tr></table></figure>

<p>问题：<br>不能做到函数复用，降低效率，与构造函数模式类似</p>
<p>寄生组合式继承：</p>
<p>使用寄生式继承来继承超类型的原型，再将结果指定给子类型的原型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>)</span>&#123;  <span class="comment">//参数为两个类型的构造函数</span></span><br><span class="line">  <span class="keyword">var</span> prototype = object(superType.prototype);</span><br><span class="line">  prototype.constructor = subType;  <span class="comment">//为创建的副本添加因重写原型而失去的constructor属性</span></span><br><span class="line">  subType.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.colors = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>只调用了一次SuperType的构造函数，并且避免了在SubType.prototype上面创建不必要的、多余的属性，同时保持原型链不变</p>
<p>参考：《JavaScript高级程序设计》（第3版）</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title>checkbox全选与反选</title>
    <url>/2016/07/27/checkbox-check-all-and-inverse/</url>
    <content><![CDATA[<p>用原生js跟jquery实现checkbox全选反选的一个例子</p>
<p>原生js：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>checkbox<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;check-all&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;check-all&quot;</span>&gt;</span>全选</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;sub-checkbox&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sub-checkbox&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sub-checkbox&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sub-checkbox&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sub-checkbox&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sub-checkbox&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> checkAll = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;[name=check-all]&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> subCheckbox = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;[name=sub-checkbox]&#x27;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">//绑定全选、反选事件</span></span></span><br><span class="line"><span class="javascript">    checkAll.addEventListener(<span class="string">&#x27;change&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (<span class="built_in">this</span>.checked) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; subCheckbox.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">                subCheckbox[i].checked = <span class="literal">true</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; subCheckbox.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">                subCheckbox[i].checked = <span class="literal">false</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">    &#125;, <span class="literal">false</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">//绑定sub checkbox的事件</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; subCheckbox.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">        subCheckbox[i].addEventListener(<span class="string">&#x27;change&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> checkboxnum = subCheckbox.length;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> checked = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;[name=sub-checkbox]:checked&#x27;</span>).length;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (checkboxnum == checked) &#123;  <span class="comment">//如果选中的sub checkbox与全部的sub checkbox一样多，则勾选全选的checkbox</span></span></span><br><span class="line"><span class="javascript">                checkAll.checked = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">//反之取消勾选</span></span></span><br><span class="line"><span class="javascript">                checkAll.checked = <span class="literal">false</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">        &#125;, <span class="literal">false</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>jquery（需引入jquery）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//checkbox select all</span></span><br><span class="line">    $(<span class="built_in">document</span>).on(<span class="string">&#x27;change&#x27;</span>, <span class="string">&#x27;[name=check-all]&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ($(<span class="built_in">this</span>).prop(<span class="string">&#x27;checked&#x27;</span>)) &#123;</span><br><span class="line">            $(<span class="string">&#x27;[name=sub-checkbox]&#x27;</span>).prop(<span class="string">&#x27;checked&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $(<span class="string">&#x27;[name=sub-checkbox]&#x27;</span>).prop(<span class="string">&#x27;checked&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sub checkbox</span></span><br><span class="line">    $(<span class="built_in">document</span>).on(<span class="string">&#x27;change&#x27;</span>, <span class="string">&#x27;[name=sub-checkbox]&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> checkboxnum = $(<span class="string">&#x27;[name=sub-checkbox]&#x27;</span>).length;</span><br><span class="line">        <span class="keyword">var</span> checked = $(<span class="string">&#x27;[name=sub-checkbox]:checked&#x27;</span>).length;</span><br><span class="line">        <span class="keyword">if</span> (checkboxnum == checked) &#123;</span><br><span class="line">            $(<span class="string">&#x27;[name=check-all]&#x27;</span>).prop(<span class="string">&#x27;checked&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $(<span class="string">&#x27;[name=check-all]&#x27;</span>).prop(<span class="string">&#x27;checked&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>思路都是一样的，给总复选框绑定事件实现全选反选功能；给子复选框绑定事件，当所有的子复选框都选中时总复选框勾选，当有一个子复选框被取消勾选时，总复选框取消勾选，这个功能是通过比较被选中子复选框数量跟所有子复选框数量来实现的。<br>需要注意的是jquery中获取checkbox勾选状态时用prop()，不用attr()。<br>绑定事件 由于querySelectorAll()返回的是一个NodeList，所以要写个循环一个节点一个节点绑定。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>checkbox</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>bootstrap如何给.list-group加上序号</title>
    <url>/2016/08/02/bootstrap-add-seq-number-to-list-group-class/</url>
    <content><![CDATA[<p>在bootstrap中，我们可以使用不带任何class的<ol>跟<li>来创建一个有序列表，但是如果加上list-group类，样式有了，但列表前面的数字却没了。</p>
<p>Bootstrap给list-group-item应用了<code>display:block;</code> 所以显示不了序号，因此我们只要修改一下list item的display就能把序号找回来了</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.list-group</span>&#123;</span><br><span class="line">    <span class="attribute">list-style</span>: decimal inside;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list-group-item</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: list-item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果把<code>list-style: decimal inside;</code>写成<code>list-style-type: decimal;</code>，序号会显示在框外</p>
<p>以下附上一段测试代码及效果图：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Bootstrap list<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">integrity</span>=<span class="string">&quot;sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u&quot;</span> <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://code.jquery.com/jquery-2.2.4.min.js&quot;</span> <span class="attr">integrity</span>=<span class="string">&quot;sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=&quot;</span> <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js&quot;</span> <span class="attr">integrity</span>=<span class="string">&quot;sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa&quot;</span> <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.list-group</span>&#123;</span></span><br><span class="line">            list-style: decimal inside;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.list-group-item</span>&#123;</span></span><br><span class="line">            display: list-item;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;list-group&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;list-group-item&quot;</span>&gt;</span>First<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;list-group-item&quot;</span>&gt;</span>Second<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;list-group-item&quot;</span>&gt;</span>Third<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Ordered list--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>First<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>Second<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>Third<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20160802095930742?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="效果图"></p>
<p>参考：</p>
<p><a href="http://stackoverflow.com/questions/24230990/how-to-make-an-ordered-list-with-twitter-bootstrap-component">http://stackoverflow.com/questions/24230990/how-to-make-an-ordered-list-with-twitter-bootstrap-component</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>bootstrap</tag>
        <tag>CSS</tag>
        <tag>.list-group</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript笔记——this的取值</title>
    <url>/2016/08/09/how-to-get-this-value/</url>
    <content><![CDATA[<p><strong>有关ECMAScript定义如何获取this请移步<a href="http://blog.csdn.net/azureternite/article/details/52153809">ECMAScript中关于如何获取this的定义</a></strong></p>
<p><strong>绝大多数情况下，函数的调用方式决定了this的取值</strong></p>
<h1 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(this &#x3D;&#x3D;&#x3D; window);  &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>
<h1 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h1><h2 id="直接调用"><a href="#直接调用" class="headerlink" title="直接调用"></a>直接调用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fn()&#123;</span><br><span class="line">	return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn() &#x3D;&#x3D;&#x3D; window;  &#x2F;&#x2F;true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;this的值不是由函数调用设定，默认为全局对象</span><br></pre></td></tr></table></figure>
<p><em>严格模式下增强了安全措施，this关键字禁止指向全局对象</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fn()&#123;</span><br><span class="line">	&quot;use strict&quot;;</span><br><span class="line">	return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn() &#x3D;&#x3D;&#x3D; undefined;  &#x2F;&#x2F;true</span><br><span class="line"></span><br><span class="line">function f()&#123;</span><br><span class="line">	&quot;use strict&quot;;</span><br><span class="line">	this.a &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();&#x2F;&#x2F; 报错，this未定义</span><br><span class="line"></span><br><span class="line">var fun &#x3D; new f();</span><br><span class="line"></span><br><span class="line">console.log(fun.a);  &#x2F;&#x2F;1</span><br></pre></td></tr></table></figure>
<h2 id="对象方法中的this"><a href="#对象方法中的this" class="headerlink" title="对象方法中的this"></a>对象方法中的this</h2><p>指向调用该函数的对象，并且是最靠近的引用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var o &#x3D; &#123;prop: 37&#125;;</span><br><span class="line"></span><br><span class="line">function independent() &#123;</span><br><span class="line">	return this.prop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.f &#x3D; independent;</span><br><span class="line"></span><br><span class="line">o.b &#x3D; &#123;</span><br><span class="line">	g: independent,</span><br><span class="line">	prop: 42</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(o.f());  &#x2F;&#x2F;logs 37</span><br><span class="line">console.log(o.b.g());  &#x2F;&#x2F;logs 42</span><br></pre></td></tr></table></figure>
<h2 id="构造函数中的this"><a href="#构造函数中的this" class="headerlink" title="构造函数中的this"></a>构造函数中的this</h2><p>与即将被创建的新对象绑定，可手动设置返回对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function C()&#123;</span><br><span class="line">	this.a &#x3D; 37;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var o &#x3D; new C();</span><br><span class="line">console.log(o.a);  &#x2F;&#x2F;logs 37</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function C2()&#123;</span><br><span class="line">	this.a &#x3D; 37;</span><br><span class="line">	return &#123;a:38&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o &#x3D; new C2();</span><br><span class="line">console.log(o.a);  &#x2F;&#x2F;logs 38</span><br></pre></td></tr></table></figure>
<h2 id="call和apply"><a href="#call和apply" class="headerlink" title="call和apply"></a>call和apply</h2><p>this的值被绑定到一个指定的对象上</p>
<p>如果传递的this值不是一个对象，则会使用ToObject操作将其转换为对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function bar() &#123;</span><br><span class="line">	console.log(Object.prototype.toString.call(this));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar.call(7); &#x2F;&#x2F; [object Number]</span><br><span class="line">&#x2F;&#x2F;会通过new Number(7)转换为对象</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果是字符串则会通过new String(&#39;foo&#39;)转换为对象</span><br></pre></td></tr></table></figure>
<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p>Function.prototype.bind<br>会创建一个具有相同函数体和作用域的函数，但是新函数的this被永久绑定到bind的第一个参数上，无论这个函数如何被调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function f()&#123;</span><br><span class="line">	return this.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var g &#x3D; f.bind(&#123;a:&quot;azerty&quot;&#125;);</span><br><span class="line">console.log(g());  &#x2F;&#x2F;azerty</span><br><span class="line"></span><br><span class="line">var o &#x3D; &#123;a:37, f:f, g:g&#125;;</span><br><span class="line">console.log(o.f(), o.g());  &#x2F;&#x2F;37, azerty</span><br></pre></td></tr></table></figure>
<h2 id="DOM事件处理函数中的this"><a href="#DOM事件处理函数中的this" class="headerlink" title="DOM事件处理函数中的this"></a>DOM事件处理函数中的this</h2><p>事件处理函数中的this指向触发事件的函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;button id&#x3D;&quot;btn&quot;&gt;button&lt;&#x2F;button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    function eventHandler() &#123;</span><br><span class="line">    	&#x2F;&#x2F;this指向#btn</span><br><span class="line">        console.log(this);  &#x2F;&#x2F;&lt;button id&#x3D;&quot;btn&quot;&gt;button&lt;&#x2F;button&gt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var btn &#x3D; document.querySelector(&#39;#btn&#39;);</span><br><span class="line">    btn.addEventListener(&#39;click&#39;, eventHandler, false);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="内联事件处理函数中的this"><a href="#内联事件处理函数中的this" class="headerlink" title="内联事件处理函数中的this"></a>内联事件处理函数中的this</h2><p>指向监听器所在DOM元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">&lt;button onclick&#x3D;&quot;console.log(this);&quot;&gt;</span><br><span class="line">    Show this</span><br><span class="line">&lt;&#x2F;button&gt;</span><br><span class="line">--&gt;</span><br><span class="line">&lt;button onclick&#x3D;&quot;alert(this);&quot;&gt;</span><br><span class="line">  Show this</span><br><span class="line">&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--window对象，因为没有设置内部函数的this，非严格模式下默认指向全局对象--&gt;</span><br><span class="line">&lt;button onclick&#x3D;&quot;alert((function()&#123;return this&#125;)());&quot;&gt;</span><br><span class="line">  Show inner this</span><br><span class="line">&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>[this - JavaScript | MDN][]</li>
<li><a href="http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html">Javascript 严格模式详解</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>this</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMAScript中关于如何获取this的定义</title>
    <url>/2016/08/08/how-ECMAScript-get-this/</url>
    <content><![CDATA[<p><strong>文章中一些名词的翻译存疑，没有查过正式的中文名称</strong></p>
<p><strong>前面都是具体过程的解释，懒得看可以直接看<a href="#%E8%8E%B7%E5%8F%96%E6%80%9D%E8%B7%AF">获取思路</a></strong></p>
<p><strong>有关this的取值请移步<a href="http://blog.csdn.net/azureternite/article/details/52160452">JavaScript笔记——this的取值</a></strong></p>
<h1 id="获取this的过程"><a href="#获取this的过程" class="headerlink" title="获取this的过程"></a>获取this的过程</h1><h2 id="Runtime-Semantics-Evaluation"><a href="#Runtime-Semantics-Evaluation" class="headerlink" title="Runtime Semantics: Evaluation"></a>Runtime Semantics: Evaluation</h2><ol>
<li>Return ResolveThisBinding();</li>
</ol>
<h2 id="ResolveThisBinding"><a href="#ResolveThisBinding" class="headerlink" title="ResolveThisBinding()"></a>ResolveThisBinding()</h2><blockquote>
<p>The abstract operation ResolveThisBinding determines the binding of the keyword this using the LexicalEnvironment of the running execution context. ResolveThisBinding performs the following steps:</p>
</blockquote>
<p>抽象操作ResolveThisBinding通过<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-execution-contexts">running execution context</a>中的LexicalEnvironment（词法环境？）来决定关键字this的绑定,执行以下两个步骤：</p>
<ol>
<li>Let envRec be <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-getthisenvironment">GetThisEnvironment()</a>;  //获取当前环境</li>
<li>Return envRec.<a href="#getthisbinding">GetThisBinding()</a>;  //返回当前环境记录中this的绑定</li>
</ol>
<h2 id="GetThisEnvironment"><a href="#GetThisEnvironment" class="headerlink" title="GetThisEnvironment()"></a>GetThisEnvironment()</h2><blockquote>
<p>The abstract operation GetThisEnvironment finds the Environment Record that currently supplies the binding of the keyword this. GetThisEnvironment performs the following steps:</p>
</blockquote>
<p>抽象操作GetThisEnvironment寻找当前提供关键字this绑定的<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-environment-records">Environment Record</a>（环境记录？）,执行以下步骤：</p>
<ol>
<li>Let lex be the running execution context’s LexicalEnvironment.</li>
<li>Repeat<br> a. Let envRec be lex’s EnvironmentRecord.  //获取当前环境记录<br> b. Let exists be envRec.<a href="#hasthisbinding">HasThisBinding()</a>.  //判断当前环境记录中是否建立了this绑定<br> c. If exists is true, return envRec.  //是，则返回当前环境记录<br> d. Let outer be the value of lex’s outer environment reference.  //否，则定义outer为outer Lexical Environment<br> e. Let lex be outer.  //lex = outer，继续循环</li>
</ol>
<p><em>步骤2的循环总是会终止，因为在environments列表中总是以拥有this的绑定的<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-global-environment-records">the global environment</a>结尾</em></p>
<h1 id="一些方法及Environment、Context的解释"><a href="#一些方法及Environment、Context的解释" class="headerlink" title="一些方法及Environment、Context的解释"></a>一些方法及Environment、Context的解释</h1><h2 id="GetThisBinding"><a href="#GetThisBinding" class="headerlink" title="GetThisBinding()"></a>GetThisBinding()</h2><blockquote>
<p>Return the value of this Environment Record’s this binding. Throws a ReferenceError if the this binding has not been initialized.</p>
</blockquote>
<p>返回Environment Record的this的绑定，如果未初始化绑定则抛出ReferenceError异常</p>
<h2 id="HasThisBinding"><a href="#HasThisBinding" class="headerlink" title="HasThisBinding()"></a>HasThisBinding()</h2><blockquote>
<p>Determine if an Environment Record establishes a this binding. Return true if it does and false if it does not.</p>
</blockquote>
<p>决定一个Environment Record是否建立了this绑定，是返回true，否则返回false</p>
<h2 id="Lexical-Environments"><a href="#Lexical-Environments" class="headerlink" title="Lexical Environments"></a>Lexical Environments</h2><blockquote>
<p>A Lexical Environment is a specification type used to define the association of Identifiers to specific variables and functions based upon the lexical nesting structure of ECMAScript code. A Lexical Environment consists of an Environment Record and a possibly null reference to an outer Lexical Environment.</p>
</blockquote>
<p>词法环境(<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-lexical-environments">Lexical Environment</a>)是用于定义具体变量和函数标识符的关联，基于ECMAScript代码的词法嵌套结构的规范类型。<br>词法环境包括词法记录(Environment Record)和对外层词法环境(outer Lexical Environment)的引用，其引用可能为空。</p>
<p>Lexical Environment包括几种类型：</p>
<ul>
<li>global environment</li>
<li>module environment</li>
<li>function environment</li>
</ul>
<p>Lexical Environments和Environment Record的值仅仅是规范机制，无需对任何具体ECMAScript实现的人工程序作出响应，因此不能直接访问或操作这些值。</p>
<h2 id="Environment-Records"><a href="#Environment-Records" class="headerlink" title="Environment Records"></a>Environment Records</h2><p>规范中有两种基本的Environment Record值，declarative Environment Records和object Environment Records</p>
<p>出于规范目的，可以将Environment Record看做一个抽象类，有三个具体的子类declarative Environment Record, object Environment Record, 和global Environment Record；<br>Function Environment Records和module Environment Records是declarative Environment Record的子类</p>
<p><img src="http://img.blog.csdn.net/20160808170715510" alt="Environment"></p>
<h2 id="running-execution-context"><a href="#running-execution-context" class="headerlink" title="running execution context"></a>running execution context</h2><blockquote>
<p>An execution context is a specification device that is used to track the runtime evaluation of code by an ECMAScript implementation. At any point in time, there is at most one execution context that is actually executing code. This is known as the running execution context.</p>
</blockquote>
<p>执行上下文(execution context)是一种用于跟踪ECMAScript实施代码运行时评估的规范设备。<br>在任意时刻，至多有一个执行上下文在实际执行代码，这就是running execution context。</p>
<h1 id="获取思路"><a href="#获取思路" class="headerlink" title="获取思路"></a>获取思路</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始</span><br><span class="line">e&#x3D;&gt;end: 结束</span><br><span class="line">op1&#x3D;&gt;operation: ResolveThisBinding()</span><br><span class="line">op2&#x3D;&gt;operation: envRec &#x3D; GetThisEnvironment()</span><br><span class="line">op3&#x3D;&gt;operation: return envRec.GetThisBinding()</span><br><span class="line"></span><br><span class="line">st-&gt;op1-&gt;op2-&gt;op3-&gt;e</span><br></pre></td></tr></table></figure>
<p>GetThisEnvironment()的流程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始</span><br><span class="line">e&#x3D;&gt;end: 结束</span><br><span class="line">op1&#x3D;&gt;operation: lex &#x3D; running execution context’s LexicalEnvironment</span><br><span class="line">op2&#x3D;&gt;operation: envRec &#x3D; lex&#39;s EnvironmentRecord</span><br><span class="line">op3&#x3D;&gt;operation: exists &#x3D; envRec.HasThisBinding()</span><br><span class="line">cond&#x3D;&gt;condition: exists &#x3D;&#x3D; true?</span><br><span class="line">opret&#x3D;&gt;operation: return envRec</span><br><span class="line">op4&#x3D;&gt;operation: outer &#x3D; outer Lexical Environment</span><br><span class="line">op5&#x3D;&gt;operation: lex &#x3D; outer</span><br><span class="line"></span><br><span class="line">st-&gt;op1-&gt;op2-&gt;op3-&gt;cond</span><br><span class="line">cond(yes)-&gt;opret-&gt;e</span><br><span class="line">cond(no)-&gt;op4-&gt;op5-&gt;op2</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://www.ecma-international.org/ecma-262/6.0/">ECMAScript® 2015 Language Specification</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>this</tag>
        <tag>ECMAScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript对寄生组合式继承的理解</title>
    <url>/2016/08/11/the-understanding-of-Parasitic-Combination-Inheritance-in-JavaScript/</url>
    <content><![CDATA[<p><strong>有关JavaScript的几种继承方式请移步<a href="http://blog.csdn.net/azureternite/article/details/51916673">JavaScript的几种继承方式</a></strong></p>
<h1 id="原型链的缺陷"><a href="#原型链的缺陷" class="headerlink" title="原型链的缺陷"></a>原型链的缺陷</h1><p>SubType.prototype = new SuperType();</p>
<p>这样做的话，SuperType构造函数中的属性也会变成SubType原型中的属性，而我们需要SubType原型只继承SuperType原型<br>还有一点就是引用类型值属性的共享</p>
<h1 id="寄生组合式继承的理解"><a href="#寄生组合式继承的理解" class="headerlink" title="寄生组合式继承的理解"></a>寄生组合式继承的理解</h1><p>为了结合原型链、组合继承和寄生式继承的优点，可以新建一个临时的类temp，temp.prototype指向父类的Prototype，然后创建一个temp实例，并给它加上一个constructor属性<br>这样，相当于用原型链的方法继承temp，由于temp的构造函数为空，所以只继承了原型上的属性，构造函数上的属性再用call或apply来继承</p>
<p>于是，我们可以把封装继承的函数进行修改，不使用object()或Object.create()，便于理解</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//继承原型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>)</span>&#123;  <span class="comment">//参数为两个类型的构造函数  </span></span><br><span class="line">    <span class="keyword">var</span> temp = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    temp.prototype = superType.prototype;</span><br><span class="line">    <span class="keyword">var</span> tempInstance = <span class="keyword">new</span> temp();  <span class="comment">//创建temp的实例tempInstance</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//给temp的实例tempInstance添加constructor属性，指向subType，虽然不是真的prototype.constructor，但是用来实现继承的效果是我们想要的</span></span><br><span class="line">    tempInstance.constructor = subType;</span><br><span class="line">    subType.prototype = tempInstance;  <span class="comment">//原型链继承</span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;  </span><br><span class="line">    <span class="built_in">this</span>.name = name;  </span><br><span class="line">    <span class="built_in">this</span>.colors = [];  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//继承构造函数中的属性  </span></span><br><span class="line">    SuperType.call(<span class="built_in">this</span>, name);  </span><br><span class="line">    <span class="built_in">this</span>.age = age;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">inheritPrototype(SubType, SuperType);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20160811133914557" alt="寄生组合式继承"></p>
<h1 id="不用temp，直接SubType-prototype-SuperType-prototype？"><a href="#不用temp，直接SubType-prototype-SuperType-prototype？" class="headerlink" title="不用temp，直接SubType.prototype = SuperType.prototype？"></a>不用temp，直接SubType.prototype = SuperType.prototype？</h1><p>因为SubType.prototype直接指向了SuperType.prototype，所以改变子类prototype中的属性的话，父类prototype中的属性也会被改变</p>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子类改变会影响父类的情况</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.species = <span class="string">&#x27;animal&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal.prototype.color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.meow = <span class="string">&#x27;meowmeowmeow&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.bark = <span class="string">&#x27;bow-wow&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cat.prototype = Animal.prototype;</span><br><span class="line">Dog.prototype = Animal.prototype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Dog();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cat.color);  <span class="comment">//red</span></span><br><span class="line"><span class="built_in">console</span>.log(dog.color);  <span class="comment">//red</span></span><br><span class="line"><span class="built_in">console</span>.log(Animal.prototype.color);  <span class="comment">//red</span></span><br><span class="line"></span><br><span class="line">Cat.prototype.color = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cat.color);  <span class="comment">//blue</span></span><br><span class="line"><span class="built_in">console</span>.log(dog.color);  <span class="comment">//blue</span></span><br><span class="line"><span class="built_in">console</span>.log(Animal.prototype.color);  <span class="comment">//blue</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//修正：将SubType的原型指向temp的一个临时创建的实例</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.species = <span class="string">&#x27;animal&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal.prototype.color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	Animal.call(<span class="built_in">this</span>);</span><br><span class="line">	<span class="built_in">this</span>.meow = <span class="string">&#x27;meowmeowmeow&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> temp = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">temp.prototype = Animal.prototype;</span><br><span class="line"><span class="keyword">var</span> tempInstance = <span class="keyword">new</span> temp();</span><br><span class="line">tempInstance.constructor = Cat;</span><br><span class="line"></span><br><span class="line">Cat.prototype = tempInstance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cat.color);  <span class="comment">//red</span></span><br><span class="line"><span class="built_in">console</span>.log(Animal.prototype.color);  <span class="comment">//red</span></span><br><span class="line"></span><br><span class="line">Cat.prototype.color = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cat.color);  <span class="comment">//blue</span></span><br><span class="line"><span class="built_in">console</span>.log(Animal.prototype.color);  <span class="comment">//red</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript笔记——引用类型之Object类型和Function类型</title>
    <url>/2016/08/05/JavaScript-Object-and-Function-type/</url>
    <content><![CDATA[<p><strong>《JavaScript高级程序设计》中介绍的几种JavaScript的引用类型，本文只记了Object跟Function类型</strong></p>
<h1 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h1><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var person &#x3D; new Object();</span><br><span class="line">var person &#x3D; &#123;&#125;;</span><br><span class="line">&#x2F;&#x2F;二者效果是一样的，但使用对象字面量表示法定义对象时不会调用Object的构造函数</span><br></pre></td></tr></table></figure>
<h2 id="访问对象属性"><a href="#访问对象属性" class="headerlink" title="访问对象属性"></a>访问对象属性</h2><ul>
<li>点表示法</li>
<li>方括号表示法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">person.name &#x3D; &#39;&#39;;</span><br><span class="line">person[&#39;name&#39;] &#x3D; &#39;&#39;;</span><br><span class="line">&#x2F;&#x2F; 方括号表示法能用变量来访问属性</span><br><span class="line">var propertyName &#x3D; &#39;name&#39;;</span><br><span class="line">person[propertyName] &#x3D; &#39;&#39;;</span><br><span class="line">&#x2F;&#x2F;若属性名包含会导致语法错误的字符或关键字、保留字，可以使用方括号表示法表示</span><br><span class="line">person[&#39;first name&#39;] &#x3D; &#39;&#39;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="Array类型"><a href="#Array类型" class="headerlink" title="Array类型"></a>Array类型</h1><h1 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a>Date类型</h1><h1 id="RegExp类型"><a href="#RegExp类型" class="headerlink" title="RegExp类型"></a>RegExp类型</h1><h1 id="Function类型"><a href="#Function类型" class="headerlink" title="Function类型"></a>Function类型</h1><p><strong>(函数是对象，函数名是指针)</strong></p>
<h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><ul>
<li>函数声明</li>
<li>函数表达式</li>
<li>Function构造函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;函数声明</span><br><span class="line">function sum(num1, num2)&#123;</span><br><span class="line">	return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;函数表达式</span><br><span class="line">var sum &#x3D; function(num1, num2)&#123;</span><br><span class="line">	return num1 + num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用Function构造函数，最后一个参数视为函数体（不推荐）</span><br><span class="line">var sum &#x3D; new Function(&#39;num1&#39;, &#39;num2&#39;, &#39;return num1 + num2&#39;);</span><br></pre></td></tr></table></figure>
<h2 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h2><p><strong>因为函数名是一个指针，所以JavaScript的函数没有重载，后面定义的函数会覆盖前面的定义</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add(n)&#123;</span><br><span class="line">	return n + 100;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function add(n)&#123;</span><br><span class="line">	return n + 200;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(100);  &#x2F;&#x2F;300</span><br><span class="line"></span><br><span class="line">var add &#x3D; function(n)&#123;</span><br><span class="line">	return n + 100;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var add &#x3D; function(n)&#123;</span><br><span class="line">	return n + 200;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">add(100);  &#x2F;&#x2F;300</span><br></pre></td></tr></table></figure>
<h2 id="函数声明与函数表达式（解析顺序）"><a href="#函数声明与函数表达式（解析顺序）" class="headerlink" title="函数声明与函数表达式（解析顺序）"></a>函数声明与函数表达式（解析顺序）</h2><p>函数声明会先被解析，而函数表达式要等到执行至定义的那行代码才会被解析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;正常执行</span><br><span class="line">alert(sum(10, 10));</span><br><span class="line">function sum(n1, n2)&#123;</span><br><span class="line">	return n1 + n2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;报错</span><br><span class="line">alert(sum(10, 10));</span><br><span class="line">var sum &#x3D; function (n1, n2)&#123;</span><br><span class="line">	return n1 + n2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="作为值传递"><a href="#作为值传递" class="headerlink" title="作为值传递"></a>作为值传递</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function callFunction(f, args)&#123;</span><br><span class="line">	return f(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function add(num)&#123;</span><br><span class="line">	return num + 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">callFunction(add, 10);  &#x2F;&#x2F;20</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在一个函数中返回另一个函数</span><br><span class="line">function callFunction()&#123;</span><br><span class="line">	return function()&#123;</span><br><span class="line"></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数内部属性"><a href="#函数内部属性" class="headerlink" title="函数内部属性"></a>函数内部属性</h2><p>函数内部有两个特殊对象：arguments和this</p>
<h3 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h3><p>arguments.callee属性指向拥有arguments对象的函数，可用于递归调用，消除函数执行与函数名的耦合</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;阶乘</span><br><span class="line">function factorial(num)&#123;</span><br><span class="line">	if(num &lt;&#x3D; 1)&#123;</span><br><span class="line">		return 1;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		return num * arguments.callee(num - 1);  &#x2F;&#x2F;效果相当于return num * factorial(num - 1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var calFactorial &#x3D; factorial;</span><br><span class="line"></span><br><span class="line">factorial &#x3D; function()&#123;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">calFactorial(5);  &#x2F;&#x2F;120</span><br><span class="line">factorial(5);  &#x2F;&#x2F;0</span><br></pre></td></tr></table></figure>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>this引用的是函数执行的环境对象（当在全局作用域中调用函数，this对象引用的是window）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.color &#x3D; &#39;red&#39;;</span><br><span class="line">var o &#x3D; &#123;color: &#39;blue&#39;&#125;;</span><br><span class="line"></span><br><span class="line">function sayColor()&#123;</span><br><span class="line">	alert(this.color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayColor();  &#x2F;&#x2F;&#39;red&#39;</span><br><span class="line"></span><br><span class="line">o.sayColor &#x3D; sayColor;</span><br><span class="line">o.sayColor();  &#x2F;&#x2F;&#39;blue&#39;</span><br></pre></td></tr></table></figure>
<h3 id="caller属性"><a href="#caller属性" class="headerlink" title="caller属性"></a>caller属性</h3><p>函数对象的属性，保存着调用当前函数的函数的引用，如果是在全局作用域中调用，则值为null</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function outer()&#123;</span><br><span class="line">	inner();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function inner()&#123;</span><br><span class="line">	alert(inner.caller);  &#x2F;&#x2F;或alert(arguments.callee.caller);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outer();</span><br><span class="line">&#x2F;*</span><br><span class="line">弹窗显示</span><br><span class="line">function outer()&#123;</span><br><span class="line">	inner();</span><br><span class="line">&#125;</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>
<h2 id="函数属性和方法"><a href="#函数属性和方法" class="headerlink" title="函数属性和方法"></a>函数属性和方法</h2><p>length, prototype, call(), apply(), bind()</p>
<h3 id="length"><a href="#length" class="headerlink" title="length"></a>length</h3><p>length表示函数希望接收命名参数的个数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fn1()&#123;&#125;</span><br><span class="line">function fn2(a)&#123;&#125;</span><br><span class="line">function fn3(a, b)&#123;&#125;</span><br><span class="line"></span><br><span class="line">alert(fn1.length);  &#x2F;&#x2F;0</span><br><span class="line">alert(fn2.length);  &#x2F;&#x2F;1</span><br><span class="line">alert(fn3.length);  &#x2F;&#x2F;2</span><br></pre></td></tr></table></figure>
<h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><p>prototype是保存引用类型所有实例方法的地方<br>prototype不可枚举，for-in无法遍历到</p>
<h3 id="call-和apply"><a href="#call-和apply" class="headerlink" title="call()和apply()"></a>call()和apply()</h3><p>用途：在特定作用域中调用函数（可扩充函数的作用域）<br>相当于改变函数体内this所指的对象<br>接收的第一个参数相同，要代替原this的对象<br>后面的参数是要执行函数的形参，call()逐个接收，apply()可以将参数作为数组传入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.num &#x3D; 0;</span><br><span class="line">var o &#x3D; &#123;num: 10&#125;;</span><br><span class="line"></span><br><span class="line">function add(num1, num2)&#123;</span><br><span class="line">	alert(num1 + num2 + this.num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add.call(this, 10, 10);  &#x2F;&#x2F;20</span><br><span class="line">add.call(window, 10, 10);  &#x2F;&#x2F;20</span><br><span class="line">add.call(o, 10, 10);  &#x2F;&#x2F;30</span><br><span class="line"></span><br><span class="line">add.apply(this, [10, 10]);  &#x2F;&#x2F;20</span><br><span class="line">add.apply(window, [10, 10]);  &#x2F;&#x2F;20</span><br><span class="line">add.apply(o, [10, 10]);  &#x2F;&#x2F;30</span><br></pre></td></tr></table></figure>
<h3 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h3><p>bind()方法会创建一个函数实例，实例的this被绑定为传入bind()中的参数（类似于call和apply第一个参数的作用）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.color &#x3D; &#39;red&#39;;</span><br><span class="line">var o &#x3D; &#123;color: &#39;blue&#39;&#125;;</span><br><span class="line"></span><br><span class="line">function sayColor()&#123;</span><br><span class="line">	alert(this.color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var objSayColor &#x3D; sayColor.bind(o);</span><br><span class="line">objSayColor();  &#x2F;&#x2F;&#39;blue&#39;</span><br></pre></td></tr></table></figure>
<h1 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h1><h1 id="单体内置对象"><a href="#单体内置对象" class="headerlink" title="单体内置对象"></a>单体内置对象</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p>《JavaScript高级程序设计》（第3版）</p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>how to remove .html extension</title>
    <url>/2016/08/12/how-to-remove-html-extension/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>Just add permalink: pretty to _config.yml</p>
]]></content>
      <categories>
        <category>jekyll</category>
      </categories>
      <tags>
        <tag>jekyll</tag>
      </tags>
  </entry>
  <entry>
    <title>set my domain</title>
    <url>/2016/08/13/set-my-domain/</url>
    <content><![CDATA[<h1 id="新域名启用"><a href="#新域名启用" class="headerlink" title="新域名启用"></a>新域名启用</h1><p>大半夜的弄好了域名</p>
<p><a href="http://c2ccc.space/">C2CCC.space</a></p>
<p>后面会慢慢建起来（大概吧）</p>
<p>亦可赛艇</p>
]]></content>
      <categories>
        <category>personal</category>
      </categories>
      <tags>
        <tag>domain</tag>
      </tags>
  </entry>
  <entry>
    <title>初学Less</title>
    <url>/2016/08/15/start-learning-Less/</url>
    <content><![CDATA[<ul>
<li>目录<br>{:toc}</li>
</ul>
<p><strong>Less在CSS语法的基础上进行了扩展，主要包含：</strong></p>
<ul>
<li>Variables（变量）</li>
<li>Mixins（混合书写）</li>
<li>Nested Rules（嵌套规则）</li>
<li>Functions &amp; Operations（功能和操作）</li>
<li>Client-side usage（客户端使用）</li>
<li>Server-side usage（服务端使用）</li>
</ul>
<h1 id="使用Less"><a href="#使用Less" class="headerlink" title="使用Less"></a>使用Less</h1><h2 id="Server-side-usage"><a href="#Server-side-usage" class="headerlink" title="Server-side usage"></a>Server-side usage</h2><h3 id="npm安装"><a href="#npm安装" class="headerlink" title="npm安装"></a>npm安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g less</span><br></pre></td></tr></table></figure>
<h3 id="命令行使用"><a href="#命令行使用" class="headerlink" title="命令行使用"></a>命令行使用</h3><p>输出到<code>stdout</code>，直接在控制台显示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lessc styles.less</span><br></pre></td></tr></table></figure>
<p>保存为文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lessc styles.less styles.css</span><br></pre></td></tr></table></figure>
<p>如果需要压缩，要先安装clean-css插件，然后执行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lessc --clean-css styles.less styles.min.css</span><br></pre></td></tr></table></figure>
<h3 id="在代码中使用"><a href="#在代码中使用" class="headerlink" title="在代码中使用"></a>在代码中使用</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> less = <span class="built_in">require</span>(<span class="string">&#x27;less&#x27;</span>);</span><br><span class="line"></span><br><span class="line">less.render(<span class="string">&#x27;.class &#123; width: (1 + 1) &#125;&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e, output</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(output.css);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="Client-side-usage"><a href="#Client-side-usage" class="headerlink" title="Client-side usage"></a>Client-side usage</h2><p>link中的rel设置成<code>stylesheet/less</code><br>先引入less文件，再引入less.js脚本</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet/less&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;styles.less&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;less.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>下载<a href="https://github.com/less/less.js/archive/master.zip">less.js</a></p>
<p><strong>需要注意的是，在浏览器中使用Less虽然入门简单、开发便捷，但在实际项目中因为要考虑性能问题，一般推荐在服务端用node.js或其他第三方工具使用</strong></p>
<h1 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h1><h2 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h2><p>定义变量</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@nice-blue:</span> <span class="number">#5B83AD</span>;</span><br><span class="line"><span class="variable">@light-blue:</span> <span class="variable">@nice-blue</span> + <span class="number">#111</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#header</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">@light-blue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#header</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#6c94be</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，Less中变量相当于“常量”，因为它们只能被定义一次</p>
<p>变量也可以用在选择器、属性名和字符串拼接中，用@{变量名}形式</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*注意：如果定义成@dialog: .dialog-class;这种有连字符 - 的变量值</span></span><br><span class="line"><span class="comment"> *要写成@dialog: dialog-class;</span></span><br><span class="line"><span class="comment"> *然后这样使用：</span></span><br><span class="line"><span class="comment"> *.@&#123;dialog&#125;</span></span><br><span class="line"><span class="comment"> *否则编译会报错 NameError: variable @dialog is undefined</span></span><br><span class="line"><span class="comment"> *然而使用下划线 _ 则没有这个问题，这是个坑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="variable">@dialog:</span> .dialogClass;</span><br><span class="line"></span><br><span class="line"><span class="variable">@&#123;dialog&#125;</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.dialogClass</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Mixins"><a href="#Mixins" class="headerlink" title="Mixins"></a>Mixins</h2><p>一个规则集合应用到另一个规则集合中，例如</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.bordered</span> &#123;</span><br><span class="line">    <span class="attribute">border-top</span>: dotted <span class="number">1px</span> black;</span><br><span class="line">    <span class="attribute">border-bottom</span>: solid <span class="number">2px</span> black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们想要将这些属性应用到别的规则集合中，直接用类名（也可以是id）代替这些属性就行了</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#menu</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#111</span>;</span><br><span class="line">    <span class="selector-class">.bordered</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.post</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="selector-class">.bordered</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以定义不带参数或带参数的Mixin，供调用，不输出css</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不带参数</span></span><br><span class="line"><span class="selector-class">.animal</span>()&#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#000000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//带参数</span></span><br><span class="line"><span class="selector-class">.dog</span>(<span class="variable">@h</span>;<span class="variable">@t</span>)&#123;  <span class="comment">//也可以用,进行分隔，但css中如background、border等样式属性支持属性值组，而,则作为属性值组元素分隔符，因此推荐使用;作为参数分隔符</span></span><br><span class="line">    <span class="attribute">height</span>: <span class="variable">@h</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="variable">@t</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#doge</span>&#123;</span><br><span class="line">    <span class="selector-class">.animal</span>();</span><br><span class="line">    <span class="selector-class">.dog</span>(<span class="number">5px</span>;<span class="number">1px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#doge</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#000000</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Mixin中内置了两个特殊的对象，<code>@arguments</code>和<code>@rest</code><br>@arguments与JavaScript中函数的arguments对象类似，表示传入的所有参数<br>@rest则表示…参数</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.dog</span>(<span class="variable">@h</span>;<span class="variable">@rest</span>...)&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="variable">@h</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="variable">@rest</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.cat</span>(<span class="variable">@t</span>;<span class="variable">@s</span><span class="variable">@c</span>)&#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="variable">@arguments</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#doge</span>&#123;</span><br><span class="line">    <span class="selector-class">.dog</span>(<span class="number">5px</span>;<span class="number">1px</span>;solid;yellow);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#meow</span>&#123;</span><br><span class="line">    <span class="selector-class">.cat</span>(<span class="number">1px</span>;solid;white);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#doge</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#meow</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Nested-Rules"><a href="#Nested-Rules" class="headerlink" title="Nested Rules"></a>Nested Rules</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#header</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: black;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#header</span> <span class="selector-class">.navigation</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#header</span> <span class="selector-class">.logo</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Less中可以写成</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#header</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: black;</span><br><span class="line">    <span class="selector-class">.navigation</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.logo</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们也可以在混合书写模式中使用伪选择器，用<font color="red"><code>&amp;</code></font>表示当前选择器的父选择器</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">zoom</span>: <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">        <span class="attribute">content</span>: <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="attribute">display</span>: block;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">clear</span>: both;</span><br><span class="line">        <span class="attribute">visibility</span>: hidden;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a>Operations</h2><p>加减乘除算术运算可以在任何数字、颜色和变量上操作，如果可能，数学操作将会考虑单位，在操作前会进行换算，运算结果以最左边有定义的单位为准<br>如果单位无法换算或无意义，则会忽略单位</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// numbers are converted into the same units</span></span><br><span class="line"><span class="variable">@conversion-1:</span> <span class="number">5cm</span> + <span class="number">10mm</span>; <span class="comment">// result is 6cm</span></span><br><span class="line"><span class="variable">@conversion-2:</span> <span class="number">2</span> - <span class="number">3cm</span> - <span class="number">5mm</span>; <span class="comment">// result is -1.5cm</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// conversion is impossible</span></span><br><span class="line"><span class="variable">@incompatible-units:</span> <span class="number">2</span> + <span class="number">5px</span> - <span class="number">3cm</span>; <span class="comment">// result is 4px</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// example with variables</span></span><br><span class="line"><span class="variable">@base:</span> <span class="number">5%</span>;</span><br><span class="line"><span class="variable">@filler:</span> <span class="variable">@base</span> * <span class="number">2</span>; <span class="comment">// result is 10%</span></span><br><span class="line"><span class="variable">@other:</span> <span class="variable">@base</span> + <span class="variable">@filler</span>; <span class="comment">// result is 15%</span></span><br></pre></td></tr></table></figure>
<p>注意，乘法与除法在运算时不进行单位换算，因为在大多数情况下这两种操作是无意义的<br>比如：一个长度乘以另一个长度等于一个面，而css中不支持对这样的面操作，因此只会对数字进行运算，然后分配最左边有定义的单位<br>（好像很有道理，比如2cm * 3mm，如果进行单位换算，最终结果将是0.6cm<sup>2</sup>，而这个单位在css中暂时并没有卵用）</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@base:</span> <span class="number">2cm</span> * <span class="number">3mm</span>; <span class="comment">// result is 6cm</span></span><br></pre></td></tr></table></figure>
<p>颜色的运算会分为rgba来运算，并且总会输出一个合法的颜色值，如果颜色值大于ff或小于00，都会被四舍五入成ff或00，对于alpha也是一样，总在1.0-0.0之间<br>注意：alpha值的运算未定义，因为在对颜色的数学操作的意义上没有达成一致，所以如果对alpha进行运算，可能达不到想要的结果，后期也可能会<a href="https://github.com/less/less.js/issues/2694">改变</a></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@color:</span> <span class="number">#224488</span> / <span class="number">2</span>; <span class="comment">//results in #112244</span></span><br><span class="line"><span class="attribute">background-color</span>: <span class="number">#112244</span> + <span class="number">#111</span>; <span class="comment">// result is #223355</span></span><br></pre></td></tr></table></figure>
<h2 id="Escaping"><a href="#Escaping" class="headerlink" title="Escaping"></a>Escaping</h2><p>可以用任意字符串作为属性或变量的值，<font color="red"><code>~&quot;任意字符串&quot;</code></font>或<font color="red"><code>~&#39;任意字符串&#39;</code></font>将不会改变，主要用在css hack中</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.weird-element</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">~&quot;^//* some horrible but needed css hack&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.weird-element</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: ^/<span class="comment">/* some horrible but needed css hack;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><p>Less提供了许多对颜色、字符串和数学操作的功能，使用方式十分直白（前提是你英语好）<br>具体可以在<a href="http://lesscss.org/functions/">Function Reference</a>中查询</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@base:</span> <span class="number">#f04615</span>;</span><br><span class="line"><span class="variable">@width:</span> <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.class</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: percentage(<span class="variable">@width</span>); <span class="comment">// returns `50%`</span></span><br><span class="line">    <span class="attribute">color</span>: saturate(<span class="variable">@base</span>, <span class="number">5%</span>);</span><br><span class="line">    <span class="attribute">background-color</span>: spin(lighten(<span class="variable">@base</span>, <span class="number">25%</span>), <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Namespaces-and-Accessors"><a href="#Namespaces-and-Accessors" class="headerlink" title="Namespaces and Accessors"></a>Namespaces and Accessors</h2><p>可以在命名空间中定义一些属性供以后使用或分发</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#bundle</span> &#123;</span><br><span class="line">    <span class="selector-class">.button</span> &#123;</span><br><span class="line">        <span class="attribute">display</span>: block;</span><br><span class="line">        <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">        <span class="attribute">background-color</span>: grey;</span><br><span class="line">        <span class="selector-tag">&amp;</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">        <span class="attribute">background-color</span>: white</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="selector-class">.tab</span> &#123; ... &#125;</span><br><span class="line">    <span class="selector-class">.citation</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#header</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: orange;</span><br><span class="line">    <span class="selector-id">#bundle</span> &gt; <span class="selector-class">.button</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：在namespace中定义的变量不能通过#namespace &gt; @var访问到</p>
<h2 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h2><p>Less中的作用域与其他编程语言类似，现在本地作用域中寻找变量或Mixin，若没找到，再到上一级作用域中寻找</p>
<h2 id="Comments"><a href="#Comments" class="headerlink" title="Comments"></a>Comments</h2><p>两种注释方法</p>
<ul>
<li>//行内</li>
<li>/*<br>  块级<br>  */</li>
</ul>
<h2 id="Importing"><a href="#Importing" class="headerlink" title="Importing"></a>Importing</h2><p>import 可以导入其他文件，如果是.less文件，可以不写后缀</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&quot;library&quot;</span>;  <span class="comment">// library.less</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;typo.css&quot;</span>;</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://lesscss.org/">lesscss.org</a></li>
<li><a href="http://www.cnblogs.com/fsjohnhuang/p/4187675.html">前端构建：Less入了个门</a></li>
</ul>
]]></content>
      <categories>
        <category>前端 CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>Less</tag>
      </tags>
  </entry>
  <entry>
    <title>(译)什么是构建工具</title>
    <url>/2016/08/15/what-are-build-tools/</url>
    <content><![CDATA[<p><strong>stackoverflow上 <a href="http://stackoverflow.com/questions/7249871/what-is-a-build-tool">What is a build tool?</a> 的一个回答</strong></p>
<h1 id="什么是构建工具"><a href="#什么是构建工具" class="headerlink" title="什么是构建工具"></a>什么是构建工具</h1><p>构建工具是一个把源代码生成可执行应用程序的过程自动化的程序（例如Android app生成apk）。构建包括编译、连接跟把代码打包成可用的或可执行的形式。</p>
<p>基本上构建的自动化是编写或使一大部分任务自动执行的一个动作，而这些任务则是软件开发者的日常，像是：</p>
<ol>
<li>下载依赖</li>
<li>将源代码编译成二进制代码</li>
<li>打包生成的二进制代码</li>
<li>进行单元测试</li>
<li>部署到生产系统</li>
</ol>
<h1 id="为什么要使用构建工具或构建自动化"><a href="#为什么要使用构建工具或构建自动化" class="headerlink" title="为什么要使用构建工具或构建自动化"></a>为什么要使用构建工具或构建自动化</h1><p>在小型项目中，开发者往往手动调用构建过程，这样在大型的项目中很不实用，在构建过程中难以跟踪什么需要被构建、按照什么顺序构建以及项目中存在哪些依赖。使用自动化工具会使构建过程更为连续。</p>
<h1 id="各种现有构建工具（只列举了部分）"><a href="#各种现有构建工具（只列举了部分）" class="headerlink" title="各种现有构建工具（只列举了部分）"></a>各种现有构建工具（只列举了部分）</h1><ol>
<li>For java - Ant,Maven,Gradle.</li>
<li>For .NET framework - NAnt</li>
<li>c# - MsBuild.</li>
</ol>
<h1 id="深入阅读"><a href="#深入阅读" class="headerlink" title="深入阅读"></a>深入阅读</h1><ol>
<li><a href="https://en.wikipedia.org/wiki/Build_automation">Build automation</a> （有中文版，但是不详细）</li>
<li><a href="https://en.wikipedia.org/wiki/List_of_build_automation_software">List of build automation software</a></li>
</ol>
<p>就做了一点微小的工作，谢谢大家。</p>
<h1 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h1><p><a href="http://stackoverflow.com/questions/7249871/what-is-a-build-tool">http://stackoverflow.com/questions/7249871/what-is-a-build-tool</a></p>
]]></content>
      <categories>
        <category>构建工具</category>
      </categories>
      <tags>
        <tag>构建工具</tag>
        <tag>build-tools</tag>
      </tags>
  </entry>
  <entry>
    <title>test</title>
    <url>/2016/08/12/test-post-article/</url>
    <content><![CDATA[<h1 id="test"><a href="#test" class="headerlink" title="test"></a>test</h1><h2 id="test-1"><a href="#test-1" class="headerlink" title="test"></a>test</h2><h3 id="test-2"><a href="#test-2" class="headerlink" title="test"></a>test</h3><h4 id="test-3"><a href="#test-3" class="headerlink" title="test"></a>test</h4><h5 id="test-4"><a href="#test-4" class="headerlink" title="test"></a>test</h5><h6 id="test-5"><a href="#test-5" class="headerlink" title="test"></a>test</h6>]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js exports与module.exports的关系</title>
    <url>/2016/08/16/nodejs-exports-and-module.exports/</url>
    <content><![CDATA[<p>今天搜索module.exports时看到CNode社区上发的Hack Sparrow一篇相关文章的链接<br><a href="http://www.hacksparrow.com/node-js-exports-vs-module-exports.html">Node.js Module – exports vs module.exports</a><br>一篇5年前的远古巨坟…</p>
<p>网上也有相应的翻译，<a href="http://www.jb51.net/article/33269.htm">nodejs中exports与module.exports的区别详细介绍</a></p>
<p>又看了下CNode上的一篇介绍，<a href="http://cnodejs.org/topic/5231a630101e574521e45ef8">exports 和 module.exports 的区别</a></p>
<p>下面做个总结，感谢CNode社区上<a href="http://cnodejs.org/user/manecocomph">@manecocomph</a>的解释，十分直白（在上面那篇文章的评论里）</p>
<p>其实exports跟module.exports初始时指向的是同一个空对象{}，因此在exports上添加的属性也会被添加到module.exports上<br>而在另一个文件中，require的返回值是module.exports，因此当exports跟module.exports不指向同一个对象时，exports中的属性便不会被导出</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">exports</span>);  <span class="comment">//&#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>.exports);  <span class="comment">//&#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">exports</span> === <span class="built_in">module</span>.exports);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<hr>
<p>rocker.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exports</span>.name = <span class="string">&#x27;naive&#x27;</span>;  <span class="comment">//&#123; name: &#x27;naive&#x27; &#125;</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;&#125;;  <span class="comment">//&#123;&#125;，与exports不再指向同一个对象</span></span><br></pre></td></tr></table></figure>
<p>app.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rocker = <span class="built_in">require</span>(<span class="string">&#x27;./rocker.js&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(rocker.name);  <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<hr>
<p>参考：</p>
<ul>
<li><a href="http://www.hacksparrow.com/node-js-exports-vs-module-exports.html">Node.js Module – exports vs module.exports</a></li>
<li><a href="http://cnodejs.org/topic/5231a630101e574521e45ef8">exports 和 module.exports 的区别</a></li>
</ul>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title>分享会</title>
    <url>/2016/08/16/sharing-front-end/</url>
    <content><![CDATA[<h1 id="BUI"><a href="#BUI" class="headerlink" title="BUI"></a>BUI</h1><h2 id="基于jQuery的UI类库，后台系统的框架"><a href="#基于jQuery的UI类库，后台系统的框架" class="headerlink" title="基于jQuery的UI类库，后台系统的框架"></a>基于jQuery的UI类库，后台系统的框架</h2><ul>
<li>统一的UI，基于bootstrap</li>
<li>丰富的控件库</li>
<li>完善的demo</li>
<li>说明全面的API文档</li>
<li>封装好的应用（暂时还没用到</li>
</ul>
<h2 id="为什么使用BUI"><a href="#为什么使用BUI" class="headerlink" title="为什么使用BUI"></a>为什么使用BUI</h2><ol>
<li>内部使用多</li>
<li>专注后台应用</li>
<li>基于jq，上手快</li>
</ol>
<h2 id="脚手架"><a href="#脚手架" class="headerlink" title="脚手架"></a>脚手架</h2><p>dpl.css<br>bui.css</p>
<p>jquery<br>sea.js<br>config.js</p>
<ul>
<li>栅格系统默认24列（bootstrap是12列<ol>
<li>固定布局960px</li>
<li>自适应</li>
</ol>
</li>
</ul>
<h2 id="CSS样式"><a href="#CSS样式" class="headerlink" title="CSS样式"></a>CSS样式</h2><h2 id="控件库"><a href="#控件库" class="headerlink" title="控件库"></a>控件库</h2><ul>
<li>js采用继承实现方式</li>
<li>通过sea.js动态加载</li>
</ul>
<h2 id="如何获取"><a href="#如何获取" class="headerlink" title="如何获取"></a>如何获取</h2><ul>
<li>github</li>
<li>CDN</li>
<li>前端lib资源库</li>
</ul>
<h1 id="FT"><a href="#FT" class="headerlink" title="FT"></a>FT</h1><p>解决： 依赖、调试、编译和发布</p>
<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>CommonJS<br>module.exports</p>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>开发时发送源文件，上线时发送压缩后的文件</p>
<h2 id="编译部署"><a href="#编译部署" class="headerlink" title="编译部署"></a>编译部署</h2><p>pack 合并项目文件<br>min 压缩代码<br>sync 同步到开发机</p>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><ol>
<li>字面量</li>
<li>工厂</li>
<li>构造函数，new</li>
</ol>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>寄生式组合继承</p>
<h1 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h1>]]></content>
      <categories>
        <category>FE</category>
      </categories>
      <tags>
        <tag>sharing</tag>
      </tags>
  </entry>
  <entry>
    <title>通过Gulp使用Browsersync实现浏览器实时响应文件更改</title>
    <url>/2016/08/17/use-browser-sync-with-gulp/</url>
    <content><![CDATA[<ul>
<li>目录<br>{:toc}</li>
</ul>
<h1 id="Gulp是什么鬼"><a href="#Gulp是什么鬼" class="headerlink" title="Gulp是什么鬼"></a>Gulp是什么鬼</h1><p>Gulp是一种基于node.js的构建工具，有关构建工具的概念请移步<a href="http://blog.csdn.net/azureternite/article/details/52213589">什么是构建工具</a></p>
<p>Gulp的安装及基本使用，可参考[一点| gulp详细入门教程][],写得十分6，通俗易懂</p>
<h1 id="Browsersync又是什么鬼"><a href="#Browsersync又是什么鬼" class="headerlink" title="Browsersync又是什么鬼"></a>Browsersync又是什么鬼</h1><p>Browsersync可以让浏览器实时响应所做的文件更改，包括html, js, css, less, sass等，并自动刷新页面<br>而且可以在多个浏览器、多个设备（PC、平板、手机等）下同时进行调试，是提高开发效率的利器</p>
<h1 id="如何安装使用Browsersync"><a href="#如何安装使用Browsersync" class="headerlink" title="如何安装使用Browsersync"></a>如何安装使用Browsersync</h1><p><a href="https://www.browsersync.io/">官网</a>上有各种安装使用方式，这边我用gulp</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>1.全局安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g browser-sync</span><br></pre></td></tr></table></figure>
<p>2.在本地项目目录下安装，同时装一下gulp跟gulp的插件（如果有用到gulp插件的话，比如gulp-less）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install browser-sync --save-dev</span><br><span class="line">npm install gulp --save-dev</span><br><span class="line">npm install gulp-less --save-dev</span><br></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>1.配置gulpfile.js</p>
<p>在项目根目录底下新建文件gulpfile.js，然后填入内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入gulp、gulp插件以及browser-sync</span></span><br><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>),</span><br><span class="line">    browserSync = <span class="built_in">require</span>(<span class="string">&#x27;browser-sync&#x27;</span>).create(),</span><br><span class="line">    less = <span class="built_in">require</span>(<span class="string">&#x27;gulp-less&#x27;</span>);</span><br><span class="line"><span class="comment">//创建一个新的gulp任务</span></span><br><span class="line">gulp.task(<span class="string">&#x27;serve&#x27;</span>,[<span class="string">&#x27;less&#x27;</span>],<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//初始化项目跟目录为&#x27;./&#x27;（也可以使用代理proxy: &quot;yourlocal.dev&quot;）</span></span><br><span class="line">    browserSync.init(&#123;</span><br><span class="line">        server: <span class="string">&#x27;./&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//创建gulp监听器，监听less文件的变化，自动执行&#x27;less&#x27;任务，编译less并生成css文件</span></span><br><span class="line">    gulp.watch(<span class="string">&#x27;./less/*.less&#x27;</span>, [<span class="string">&#x27;less&#x27;</span>]).on(<span class="string">&#x27;change&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;File &#x27;</span> + event.path + <span class="string">&#x27; was &#x27;</span> + event.type + <span class="string">&#x27;, running tasks...&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//监听html文件的变化，自动重新载入</span></span><br><span class="line">    gulp.watch(<span class="string">&#x27;./*.html&#x27;</span>).on(<span class="string">&#x27;change&#x27;</span>, browserSync.reload);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//创建自动编译less的任务，这边需要return stream以保证browserSync.reload在正确的时机调用</span></span><br><span class="line">gulp.task(<span class="string">&#x27;less&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">&#x27;./less/*.less&#x27;</span>)</span><br><span class="line">        .pipe(less())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">&#x27;./css&#x27;</span>))</span><br><span class="line">        .pipe(browserSync.stream());</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//默认启动的gulp任务数组[&#x27;serve&#x27;]</span></span><br><span class="line">gulp.task(<span class="string">&#x27;default&#x27;</span>, [<span class="string">&#x27;serve&#x27;</span>]);</span><br></pre></td></tr></table></figure>
<p>2.运行gulp</p>
<p>在项目根目录命令行执行<code>gulp</code>或<code>gulp default</code><br>项目启动后在命令行中会输出Access URLs，包括本地跟外部访问的URL以及项目跟UI控制界面的URL<br>项目默认启动在<a href="http://localhost:3000/">http://localhost:3000</a><br>UI控制界面默认启动在<a href="http://localhost:3001/">http://localhost:3001</a></p>
<h1 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h1><p><img src="http://img.blog.csdn.net/20160817012323155" alt="browser-sync-demo"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>[一点| gulp详细入门教程][]</li>
<li><a href="https://www.browsersync.io/docs/gulp">Browsersync + Gulp.js</a> </li>
</ul>
]]></content>
      <categories>
        <category>构建工具</category>
      </categories>
      <tags>
        <tag>gulp</tag>
        <tag>browsersync</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS 7部署Node.js+MongoDB：在VPS上从安装到Hello world</title>
    <url>/2016/08/28/deploy-nodejs-and-mongodb-on-centos7-vps/</url>
    <content><![CDATA[<ul>
<li>目录<br>{:toc}</li>
</ul>
<p>写好代码，花钱买了VPS，看着Charges一直上涨却无从下手？记一位新手司机从购买VPS到成功访问的过程</p>
<h1 id="0-购买VPS"><a href="#0-购买VPS" class="headerlink" title="0.购买VPS"></a>0.购买VPS</h1><p>首先，选择VPS提供商，部署一个新的服务器（Deploy New Server），我使用的是Vultr提供的VPS<br>操作系统可以自由选择，我这边使用的是CentOS 7，选择其他操作系统的胖友可以搜一下相应操作系统的部署教程</p>
<h1 id="1-使用PuTTY连接远程VPS"><a href="#1-使用PuTTY连接远程VPS" class="headerlink" title="1.使用PuTTY连接远程VPS"></a>1.使用PuTTY连接远程VPS</h1><p>安装<a href="http://www.putty.org/">PuTTY</a></p>
<p>打开PuTTY，在 Host Name(or IP address) 那一栏填上VPS提供商给你的IP地址，然后点Open开启一个新会话（也可以点底下的Save保存一下，下次直接双击Saved Sessions中保存的的会话打开就行，无须输入IP）</p>
<p><img src="http://img.blog.csdn.net/20160829010214660" alt="PuTTY interface"></p>
<p>打开后会出现一个Terminal，显示login as: ，这边输入VPS提供商给你的Username，默认应该是root</p>
<p>然后出现root@your ip address ‘s password: ，输入VPS提供商提供的Password（可以在本机上复制，然后在窗口中点击鼠标右键，复制的内容就被粘贴了），然后回车<br>注意：输入密码的时候不会显示你输入的东西</p>
<p>成功登录</p>
<h1 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2.准备工作"></a>2.准备工作</h1><p>用yum安装gcc</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install gcc make gcc-c++ openssl-devel wget</span><br></pre></td></tr></table></figure>
<h1 id="3-安装Node-js"><a href="#3-安装Node-js" class="headerlink" title="3.安装Node.js"></a>3.安装Node.js</h1><p>这边以v4.5.0版本、使用源码安装为例，也可以使用EPEL</p>
<p>先用cd命令进入到你要安装Node.js的目录</p>
<p>到Node.js官网上复制源码的地址，然后执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://nodejs.org/dist/v4.5.0/node-v4.5.0.tar.gz</span><br></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20160829010402367" alt="nodejs website"></p>
<p>然后解压提取文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar zxvf node-v4.5.0.tar.gz</span><br></pre></td></tr></table></figure>
<p>执行后会生成node-v4.5.0文件夹，cd进入,里面有个configure文件</p>
<p>配置并编译#这步执行得比较久，可以先去喝杯咖啡</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<p>然后安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>使用node -v检查是否安装成功</p>
<h1 id="4-安装MongoDB"><a href="#4-安装MongoDB" class="headerlink" title="4.安装MongoDB"></a>4.安装MongoDB</h1><p>这边以v3.2.9、使用yum安装为例</p>
<p>MongoDB官网上提供了用yum安装的<a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/">教程</a></p>
<p>我写了一篇翻译别人教程的<a href="http://blog.csdn.net/azureternite/article/details/52349304">Blog</a>，跟官网上的类似<br>步骤是类似的，但是我们用官网上的命令进行安装，比较稳妥，那篇翻译的教程仅供理解用</p>
<h1 id="5-给MongoDB添加用户认证"><a href="#5-给MongoDB添加用户认证" class="headerlink" title="5.给MongoDB添加用户认证"></a>5.给MongoDB添加用户认证</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongo</span><br><span class="line">use db</span><br><span class="line">db.createUser(&#123;user:<span class="string">&#x27;&#x27;</span>,<span class="built_in">pwd</span>:<span class="string">&#x27;&#x27;</span>,roles:[&#123;role:<span class="string">&#x27;readWrite&#x27;</span>,db:<span class="string">&#x27;db&#x27;</span>&#125;]&#125;);  <span class="comment">#添加db数据库下的用户，拥有读写权限</span></span><br><span class="line">db.system.users.find().pretty()  <span class="comment">#查看该数据库下所有的用户</span></span><br></pre></td></tr></table></figure>
<p>记得在admin数据库下添加一个root用户用于以后关闭服务器<br>即 use admin，role: ‘root’</p>
<p>有关新建用户的更多信息请见<a href="http://bbs.51cto.com/thread-1146654-1.html">这里</a></p>
<p>添加了用户后，在启动MongoDB时加上–auth参数即可开启用户认证</p>
<p>附上一条mongoose通过用户认证连接db的代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mongoose.connect(<span class="string">&#x27;mongodb://username:password@host:port/database?options...&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h1 id="6-复制你的应用到VPS服务器"><a href="#6-复制你的应用到VPS服务器" class="headerlink" title="6.复制你的应用到VPS服务器"></a>6.复制你的应用到VPS服务器</h1><p>如果你的代码还没复制到VPS服务器上，你可以使用git，svn，ftp等方式放上去<br>我用的是git</p>
<p>安装git，使用yum安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install git</span><br></pre></td></tr></table></figure>
<p>然后就可以愉快地使用git clone了</p>
<h1 id="7-开启端口"><a href="#7-开启端口" class="headerlink" title="7.开启端口"></a>7.开启端口</h1><p>CentOS 7采用了firewalld防火墙，如果没有开启端口，则外网无法通过ip来访问服务器上的Node应用。</p>
<p>比如Node.js默认用了3000端口，所以我们需要开启相应的端口</p>
<p>查询端口是否开启：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --query-port=3000/tcp</span><br></pre></td></tr></table></figure>
<p>如果显示no，则没有开启端口</p>
<p>开启端口：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --add-port=3000/tcp</span><br></pre></td></tr></table></figure>
<p>也可以修改Node监听的端口，比如修改为80端口，然后再开启80端口</p>
<h1 id="8-后台运行"><a href="#8-后台运行" class="headerlink" title="8.后台运行"></a>8.后台运行</h1><h2 id="后台运行MongoDB"><a href="#后台运行MongoDB" class="headerlink" title="后台运行MongoDB"></a>后台运行MongoDB</h2><p>在启动MongoDB时，加上–fork参数，即可生成一个子进程，当子进程成功运行，则父进程就会被停止，这时候便实现了后台运行MongoDB，可以关闭当前的终端</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongod --dbpath /usr/<span class="built_in">local</span>/mongodb/data --logpath /usr/<span class="built_in">local</span>/mongodb/logs/log.log --logappend --auth --fork</span><br></pre></td></tr></table></figure>
<p>如果要关闭后台MongoDB，则需要通过刚才添加的root用户调用shutdownServer()方法关闭<br>顺带一提，MongoDB没有正常关闭的话会很麻烦的，有时候还会造成一些严重后果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongo</span><br><span class="line">use admin</span><br><span class="line">db.auth(<span class="string">&#x27;usr&#x27;</span>, <span class="string">&#x27;pwd&#x27;</span>)  <span class="comment">#用root用户登录，usr、pwd为root用户的用户名和密码</span></span><br><span class="line">db.shutdownServer()</span><br></pre></td></tr></table></figure>
<h2 id="后台运行Node-js"><a href="#后台运行Node-js" class="headerlink" title="后台运行Node.js"></a>后台运行Node.js</h2><p>这边后台启动Node.js使用一个Node.js的模块forever，可以输出错误和日志<br>当然还有其他的方法，比如nohup啥的</p>
<p>全局安装forever</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g forever</span><br></pre></td></tr></table></figure>
<p>cd进入应用程序的目录</p>
<p>如果是普通的Node应用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">forever start app.js</span><br></pre></td></tr></table></figure>
<p>如果用的Express</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">forever start -c <span class="string">&#x27;npm start&#x27;</span> ./</span><br></pre></td></tr></table></figure>
<p>有关如何停止forever以及其他操作请参考<a href="https://github.com/foreverjs/forever">forever</a>官网及Google</p>
<p>我之前是看<a href="https://cnodejs.org/topic/510dd169df9e9fcc581cb97f">CNode社区里的方法</a>直接杀掉Node的进程 pkill node ，可以，很暴力</p>
<h1 id="9-Hello-world"><a href="#9-Hello-world" class="headerlink" title="9.Hello world"></a>9.Hello world</h1><p>至此，你应该可以从外网通过ip+端口访问到你的Node应用了，你也可以绑定个域名之类的</p>
<h1 id="10-附加"><a href="#10-附加" class="headerlink" title="10.附加"></a>10.附加</h1><h2 id="开机启动"><a href="#开机启动" class="headerlink" title="开机启动"></a>开机启动</h2><p>可以将MongoDB和Node通过编辑/etc/rc.local加入到开机启动中<br>这里我没有试验过，先挂上一篇<a href="http://www.linuxidc.com/Linux/2011-07/39149.htm">教程</a></p>
<h2 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h2><p>使用Linux免不了的一个问题就是 如何编辑文件<br>久闻Vim之大名，今日有幸相会</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install vim</span><br></pre></td></tr></table></figure>
<p>其实刚入门的小白用Vim，只要掌握一些基础的操作，用起来也是很爽的</p>
<p>附一个<a href="http://blog.csdn.net/niushuai666/article/details/7275406">Vim简明教程</a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://www.cnblogs.com/hamy/p/3632574.html">Centos 安装 NodeJS - Hamy - 博客园</a></li>
<li><a href="http://www.linuxidc.com/Linux/2015-02/113554.htm">如何在CentOS 7安装Node.js_Linux教程_Linux公社-Linux系统门户网站</a></li>
<li><a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/">Install MongoDB Community Edition on Red Hat Enterprise or CentOS Linux &mdash; MongoDB Manual 3.2</a></li>
<li><a href="http://bbs.51cto.com/thread-1146654-1.html">【Mongodb】3.0 配置身份验证db.createUser（）说明 - NoSQL论坛 -  51CTO技术论坛_中国领先的IT技术社区</a></li>
<li><a href="https://cnodejs.org/topic/53e0a75abd3cc3e50b8179b3">当mongodb开启用户认证后(auth=true),如何使用mongoose链接数据库 - CNode技术社区</a></li>
<li><a href="http://www.cnblogs.com/mliudong/p/4529612.html">Centos 7 开启端口 - 鍒樻爧 - 博客园</a></li>
<li><a href="http://www.jb51.net/article/54754.htm">mongodb设置后台运行的方法_MongoDB_脚本之家</a></li>
<li><a href="https://github.com/foreverjs/forever/issues/540">Forever with `npm start` · Issue #540 · foreverjs/forever</a></li>
<li><a href="https://cnodejs.org/topic/510dd169df9e9fcc581cb97f">如何 停止node进程？ - CNode技术社区</a></li>
<li><a href="http://www.linuxidc.com/Linux/2011-07/39149.htm">Linux下设置MongoDB开机自启动_Linux教程_Linux公社-Linux系统门户网站</a></li>
<li><a href="http://blog.csdn.net/niushuai666/article/details/7275406">Vim简明教程【CoolShell】 - 飘过的小牛 - 博客频道 - CSDN.NET</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>CentOS</tag>
        <tag>MongoDB</tag>
        <tag>VPS</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js实现CORS跨域资源共享</title>
    <url>/2016/08/28/nodejs-cors-solution/</url>
    <content><![CDATA[<h1 id="什么是CORS"><a href="#什么是CORS" class="headerlink" title="什么是CORS"></a>什么是CORS</h1><p>CORS(Cross-origin resource sharing)，跨域资源共享，是一份浏览器技术的规范，用来避开浏览器的同源策略</p>
<p>简单来说就是解决跨域问题的除了jsonp外的另一种方法</p>
<p><a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing">CORS的wiki</a></p>
<h1 id="如何使用CORS"><a href="#如何使用CORS" class="headerlink" title="如何使用CORS"></a>如何使用CORS</h1><p>只要服务端在响应时发送一个响应的标头即可</p>
<p>浏览器端还是照常使用ajax，支持get，post</p>
<h1 id="在Node-js上启用CORS"><a href="#在Node-js上启用CORS" class="headerlink" title="在Node.js上启用CORS"></a>在Node.js上启用CORS</h1><p>参照<a href="http://stackoverflow.com/questions/7067966/how-to-allow-cors-in-express-node-js">StackOverflow上面的一个回答</a>，定义一个中间件来添加响应标头，然后在处理app.get（或post等）之前使用<br>（这位老兄告诉我们要善用next啊）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CORS middleware</span></span><br><span class="line"><span class="keyword">var</span> allowCrossDomain = <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    res.header(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;http://example.com&#x27;</span>);</span><br><span class="line">    res.header(<span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="string">&#x27;GET,PUT,POST,DELETE&#x27;</span>);</span><br><span class="line">    res.header(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;Content-Type&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">app.configure(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    app.use(express.bodyParser());</span><br><span class="line">    app.use(express.cookieParser());</span><br><span class="line">    app.use(express.session(&#123; <span class="attr">secret</span>: <span class="string">&#x27;cool beans&#x27;</span> &#125;));</span><br><span class="line">    app.use(express.methodOverride());</span><br><span class="line">    app.use(allowCrossDomain);</span><br><span class="line">    app.use(app.router);</span><br><span class="line">    app.use(express.static(__dirname + <span class="string">&#x27;/public&#x27;</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>只要把app.use(allowCrossDomain);放在处理路由之前就行</p>
<p>注意：Access-Control-Allow-Origin，后面如果是 <code>*</code> 就代表所有域名都可以跨域访问到服务器，也可以指定具体的域名，域名一定要小写，不然浏览器这边会报错不允许跨域<br>然后要指定协议名称，http或https等</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://blog.csdn.net/suhenhappy/article/details/18043241">AJAX POST&amp;跨域 解决方案 - CORS</a></li>
<li><a href="http://stackoverflow.com/questions/7067966/how-to-allow-cors-in-express-node-js">How to allow CORS in Express/Node.js?</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>CORS</tag>
      </tags>
  </entry>
  <entry>
    <title>mongoose连接collection后自动加s的问题</title>
    <url>/2016/08/28/mongoose-auto-pluralize-problem/</url>
    <content><![CDATA[<p>这两天折腾mongoose，发现数据成功写入集合了，但是在Terminal查询的时候却查不到<br>于是show collections后发现在原来的集合底下，又生成了一个加了s的集合，shenmegui</p>
<p>查了一下，发现是mongoose.model()的问题</p>
<p>Mongoose#model(name, [schema], [collection], [skipInit])</p>
<p>在官方的api文档里面有解释（我不听）</p>
<blockquote>
<p>When no collection argument is passed, Mongoose produces a collection name by passing the model name to the utils.toCollectionName method. This method pluralizes the name. If you don’t like this behavior, either pass a collection name or set your schemas collection name option.</p>
</blockquote>
<p>当没有传入collection参数时，Mongoose会通过model name（就是第一个参数），调用utils.toCollectionName方法产生一个collection name，而这个方法会使name变成复数形式。如果你不想要这个过程，只要传入collection name参数或设置Schema中的collection name选项。</p>
<p>就像这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> schema = <span class="keyword">new</span> Schema(&#123; <span class="attr">name</span>: <span class="built_in">String</span> &#125;, &#123; <span class="attr">collection</span>: <span class="string">&#x27;actor&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line">schema.set(<span class="string">&#x27;collection&#x27;</span>, <span class="string">&#x27;actor&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> collectionName = <span class="string">&#x27;actor&#x27;</span></span><br><span class="line"><span class="keyword">var</span> M = mongoose.model(<span class="string">&#x27;Actor&#x27;</span>, schema, collectionName);</span><br></pre></td></tr></table></figure>
<p>什么坑爹设定…</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://mongoosejs.com/docs/api.html#index_Mongoose-model">Mongoose API v4.5.9</a></li>
</ul>
]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
        <tag>mongoose</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js用ES6原生Promise对异步函数进行封装</title>
    <url>/2016/08/19/use-es6-promise-to-encapsule-async-functions/</url>
    <content><![CDATA[<h1 id="Promise的概念"><a href="#Promise的概念" class="headerlink" title="Promise的概念"></a>Promise的概念</h1><blockquote>
<p>Promise 对象用于异步(asynchronous)计算.。一个Promise对象代表着一个还未完成，但预期将来会完成的操作。</p>
</blockquote>
<p>Promise的几种状态：</p>
<ul>
<li>pending：初始状态，即等待操作的执行</li>
<li>fulfilled：成功的操作</li>
<li>rejected：失败的操作</li>
</ul>
<p>pending的状态既可以转为fulfilled，也可以转为rejected，当状态发生改变时，promise.then(onFulfilled, onRejected)方法将被调用</p>
<h1 id="Promise的基本用法"><a href="#Promise的基本用法" class="headerlink" title="Promise的基本用法"></a>Promise的基本用法</h1><p>1.首先创建一个Promise的实例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">    <span class="keyword">if</span>(success)&#123;</span><br><span class="line">        resolve(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>构造函数的参数Function中带有两个函数对象resolve和reject，二者都是返回一个Promise对象</p>
<ul>
<li>resolve用在处理执行成功的场景，Promise从pending转为fulfilled状态时调用</li>
<li>reject用在处理执行失败的场景，Promise从pending转为rejected状态时调用</li>
</ul>
<p>2.调用then()方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//成功时调用</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//失败时调用</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="用Promise来封装异步函数"><a href="#用Promise来封装异步函数" class="headerlink" title="用Promise来封装异步函数"></a>用Promise来封装异步函数</h1><p>Node.js中的IO操作都是异步的，因此在写异步程序的过程中容易掉进<a href="http://callbackhell.com/">回调大坑</a></p>
<p>知道了Promise的基本调用过程，我们就可以用来封装异步的函数了</p>
<p>1.定义函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendRequest</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> req = http.request(options, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> data = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            res.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>)</span>&#123;</span><br><span class="line">                data += chunk;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            res.on(<span class="string">&#x27;end&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="comment">//成功后调用</span></span><br><span class="line">                resolve(data);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        req.on(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">            <span class="comment">//失败后调用</span></span><br><span class="line">            reject(err);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        req.end();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.调用函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sendRequest().then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>[Promise - JavaScript | MDN][]</li>
<li><a href="https://segmentfault.com/a/1190000004451095">使用 Promise 封装 FileReader</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>异步</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>用Node.js发送邮件</title>
    <url>/2016/08/29/nodejs-send-mail/</url>
    <content><![CDATA[<p><strong>本文讲的是用Node.js通过一个开启smtp的已有的邮箱账号发送邮件，而不是如何创建一个邮件服务器</strong></p>
<h1 id="开启smtp服务"><a href="#开启smtp服务" class="headerlink" title="开启smtp服务"></a>开启smtp服务</h1><p>首先要去要使用的邮箱中设置开启smtp，才能正常发送邮件</p>
<p>这边以163邮箱为例</p>
<p><img src="http://img.blog.csdn.net/20160829152743891" alt="163mail set smtp"></p>
<h1 id="安装Nodemailer模块"><a href="#安装Nodemailer模块" class="headerlink" title="安装Nodemailer模块"></a>安装Nodemailer模块</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install nodemailer --save-dev</span><br></pre></td></tr></table></figure>
<h1 id="设置Nodemailer"><a href="#设置Nodemailer" class="headerlink" title="设置Nodemailer"></a>设置Nodemailer</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nodemailer = <span class="built_in">require</span>(<span class="string">&#x27;nodemailer&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//username替换为邮箱名，%40后面是邮件服务器的地址，比如163.com，password替换为邮箱密码（或独立密码，如果有设置的话），@后面填SMTP服务器地址，如163的smtp地址为smtp.163.com</span></span><br><span class="line"><span class="keyword">var</span> transport = nodemailer.createTransport(<span class="string">&#x27;smtps://username%40163.com:password@smtp.163.com&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> mailOptions = &#123;</span><br><span class="line">  <span class="keyword">from</span>: <span class="string">&#x27;example@163.com&#x27;</span>,  <span class="comment">//发件人</span></span><br><span class="line">  to: <span class="string">&#x27;abc@163.com, def@163.com&#x27;</span>,  <span class="comment">//收件人，可以设置多个</span></span><br><span class="line">  subject: <span class="string">&#x27;&#x27;</span>,  <span class="comment">//邮件主题</span></span><br><span class="line">  text: <span class="string">&#x27;&#x27;</span>,  <span class="comment">//邮件文本</span></span><br><span class="line">  html: <span class="string">&#x27;&#x27;</span>  <span class="comment">//html格式文本</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a>发送邮件</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">transport.sendMail(mailOptions, <span class="function"><span class="keyword">function</span>(<span class="params">err, info</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(err)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Message sent: &#x27;</span> + info.response);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>成功运行后，去查看一下发件邮箱的已发送，里面会有发送的记录</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://nodemailer.com/">Nodemailer &#8211; Send e-mails with Node.JS</a></li>
</ul>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>邮件</tag>
      </tags>
  </entry>
  <entry>
    <title>(译)如何在CentOS/RHEL &amp; Fedora上安装MongoDB 3.2</title>
    <url>/2016/08/29/how-to-install-mongodb-3.2-on-centos-rhel-and-fedora/</url>
    <content><![CDATA[<p>MongoDB（名称取自“huMONGOus“）是一个有着全面灵活的索引支持和丰富的查询的数据库。MongoDB通过GridFS提供强大的媒体存储。点击<a href="http://www.10gen.com/products/mongodb">这里</a>获取MongoDB的更多信息</p>
<p>MongoDB发布了一个新的稳定版本 3.2，进行了大量的改进。本教程将帮助你在CentOS, RHEL 和 Fedora 系统上安装MongoDB 3.2.X</p>
<h1 id="第一步-——-将MongoDB添加到yum仓库"><a href="#第一步-——-将MongoDB添加到yum仓库" class="headerlink" title="第一步 —— 将MongoDB添加到yum仓库"></a>第一步 —— 将MongoDB添加到yum仓库</h1><p>将下列内容按照你需要的MongoDB版本和系统架构添加到yum仓库的配置文件/etc/yum.repos.d/mongodb.repo中。在本文中我们使用MongoDB 3.2的仓库。</p>
<p>64位系统使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[MongoDB]</span><br><span class="line">name&#x3D;MongoDB Repository</span><br><span class="line">baseurl&#x3D;http:&#x2F;&#x2F;repo.mongodb.org&#x2F;yum&#x2F;redhat&#x2F;$releasever&#x2F;mongodb-org&#x2F;3.2&#x2F;x86_64&#x2F;</span><br><span class="line">gpgcheck&#x3D;0</span><br><span class="line">enabled&#x3D;1</span><br></pre></td></tr></table></figure>
<h1 id="第二步-——-安装MongoDB服务器"><a href="#第二步-——-安装MongoDB服务器" class="headerlink" title="第二步 —— 安装MongoDB服务器"></a>第二步 —— 安装MongoDB服务器</h1><p>使用yum包管理器安装mongodb-org包，这个操作会自动安装所有的依赖。若要安装具体的MongoDB修订版，只要指定包的名称，带上版本号，例如mongodb-org-3.2.0。以下命令会安装最新可用的稳定版。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yum install mongodb-org</span></span><br></pre></td></tr></table></figure>
<h1 id="第三步-——-启动MongoDB"><a href="#第三步-——-启动MongoDB" class="headerlink" title="第三步 —— 启动MongoDB"></a>第三步 —— 启动MongoDB</h1><p>mongodb-org-server包提供了MongoDB的初始化脚本，用脚本来启动服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /etc/init.d/mongod restart</span></span><br></pre></td></tr></table></figure>
<p>配置MongoDB随系统自启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># chkconfig mongod on</span></span><br></pre></td></tr></table></figure>
<h1 id="第四步-——-检查MongoDB版本"><a href="#第四步-——-检查MongoDB版本" class="headerlink" title="第四步 —— 检查MongoDB版本"></a>第四步 —— 检查MongoDB版本</h1><p>使用以下命令来检查MongoDB的版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@tecadmin ~]<span class="comment">#  mongod --version</span></span><br><span class="line"></span><br><span class="line">db version v3.2.0</span><br><span class="line">git version: 45d947729a0315accb6d4f15a6b06be6d9c19fe7</span><br><span class="line">OpenSSL version: OpenSSL 1.0.1e-fips 11 Feb 2013</span><br><span class="line">allocator: tcmalloc</span><br><span class="line">modules: none</span><br><span class="line">build environment:</span><br><span class="line">    distmod: rhel70</span><br><span class="line">    distarch: x86_64</span><br><span class="line">    target_arch: x86_64</span><br></pre></td></tr></table></figure>
<p>连接到MongoDB并执行几个测试的命令来检查是否正常工作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@tecadmin ~]<span class="comment">#  mongo</span></span><br><span class="line"></span><br><span class="line">&gt; use mydb;</span><br><span class="line"></span><br><span class="line">&gt; db.test.save( &#123; a: 1 &#125; )</span><br><span class="line"></span><br><span class="line">&gt; db.test.find()</span><br><span class="line"></span><br><span class="line">  &#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;54fc2a4c71b56443ced99ba2&quot;</span>), <span class="string">&quot;a&quot;</span> : 1 &#125;</span><br></pre></td></tr></table></figure>
<p>恭喜，你已经成功地在你的系统上安装了MongoDB服务器。你还可以在此处进行练习 <a href="http://try.mongodb.org/">MongoDB browser shell</a>。</p>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a href="http://docs.mongodb.org/manual/installation/">http://docs.mongodb.org/manual/installation/</a></p>
<h1 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h1><p><a href="http://tecadmin.net/install-mongodb-on-centos-rhel-and-fedora/">How to Install MongoDB 3.2 on CentOS/RHEL &amp; Fedora</a></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js抓取网页</title>
    <url>/2016/08/29/nodejs-web-crawl/</url>
    <content><![CDATA[<p>前几天四六级成绩出来（然而我没考），用Node.js做了一个模拟表单提交并抓取数据的Web<br>总结一下用到的知识，简单的网页抓取大概就是这个流程了</p>
<h1 id="发送Get或Post请求"><a href="#发送Get或Post请求" class="headerlink" title="发送Get或Post请求"></a>发送Get或Post请求</h1><p>表单提交，首先弄到原网页提交的地址，然后引入http或https模块<br>也可以下载使用request模块。<br>这边以get为例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置请求参数，包括headers</span></span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">    url: <span class="string">&#x27;www.chsi.com.cn&#x27;</span>,</span><br><span class="line">    encoding: <span class="literal">null</span>,</span><br><span class="line">    host: <span class="string">&#x27;www.chsi.com.cn&#x27;</span>,</span><br><span class="line">    path: <span class="string">&#x27;/cet/query?&#x27;</span> + querystring,</span><br><span class="line">    method: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">    headers: &#123;</span><br><span class="line">        <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Accept-Encoding&#x27;</span>: <span class="string">&#x27;gzip, deflate, sdch&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;zh-CN,zh;q=0.8&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Connection&#x27;</span>: <span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Cookie&#x27;</span>: <span class="string">&#x27;JSESSIONID=8D79F004CB79FC5352F123F76CF4D853; __utmt=1; __utma=65168252.1576213452.1471513579.1471575867.1471575870.3; __utmb=65168252.5.10.1471575870; __utmc=65168252; __utmz=65168252.1471575870.3.3.utmcsr=baidu|utmccn=(organic)|utmcmd=organic|utmctr=%E5%AD%A6%E4%BF%A1%E7%BD%91&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Host&#x27;</span>: <span class="string">&#x27;www.chsi.com.cn&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Referer&#x27;</span>: <span class="string">&#x27;http://www.chsi.com.cn/cet/&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Upgrade-Insecure-Requests&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> req = http.request(options, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">  res.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//处理data事件，当接收到数据时触发</span></span><br><span class="line">  &#125;).on(<span class="string">&#x27;end&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//处理读取完所有数据的事件</span></span><br><span class="line">  &#125;).on(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//处理错误时的事件</span></span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送请求</span></span><br><span class="line">req.end();</span><br></pre></td></tr></table></figure>
<p>如果是post请求，需要在<code>req.end()</code>之前用<code>req.write(content)</code>写入请求参数</p>
<h1 id="Transfer-Encoding-chunked？"><a href="#Transfer-Encoding-chunked？" class="headerlink" title="Transfer-Encoding:chunked？"></a>Transfer-Encoding:chunked？</h1><p>有时候服务器的response header会带有一个Transfer-Encoding，如果是chunked，说明服务器是分段传输数据的<br>这种情况下，会触发多次res的data事件，因此可以先定义一个变量，然后在data事件处理函数中将接收到的数据拼接起来</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> req = http.request(options, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  res.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//处理data事件，当接收到数据时触发</span></span><br><span class="line">    data += chunk;</span><br><span class="line">  &#125;).on(<span class="string">&#x27;end&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//处理读取完所有数据的事件</span></span><br><span class="line">  &#125;).on(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//处理错误时的事件</span></span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送请求</span></span><br><span class="line">req.end();</span><br></pre></td></tr></table></figure>
<h1 id="使用zlib库解压gzip压缩过的html"><a href="#使用zlib库解压gzip压缩过的html" class="headerlink" title="使用zlib库解压gzip压缩过的html"></a>使用zlib库解压gzip压缩过的html</h1><p>现在很多网站在进行数据传输时都会先用gzip或deflate压缩以减小传输数据的体积，这样，我们请求到的数据就是压缩过的数据，无法正常解析，因此需要先解压</p>
<p>Node.js带有一个zlib库可以用来解压gzip格式的数据</p>
<p>我们可以利用Node.js的管道流机制，将接收到的数据先通过pipe()交给zlib处理，然后再进行我们自己的处理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> zlib = <span class="built_in">require</span>(<span class="string">&#x27;zlib&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> req = http.request(options, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> gunzip = zlib.createGunzip();</span><br><span class="line">  res.pipe(gunzip);  <span class="comment">//通过pipe()将数据交给gunzip</span></span><br><span class="line">  <span class="keyword">var</span> data = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="comment">//事件处理，res.on改为gunzip.on</span></span><br><span class="line">  gunzip.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//处理data事件，当接收到数据时触发</span></span><br><span class="line">    data += chunk;</span><br><span class="line">  &#125;).on(<span class="string">&#x27;end&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//处理读取完所有数据的事件</span></span><br><span class="line">  &#125;).on(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//处理错误时的事件</span></span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送请求</span></span><br><span class="line">req.end();</span><br></pre></td></tr></table></figure>
<h1 id="压缩html字符串（去除换行符）"><a href="#压缩html字符串（去除换行符）" class="headerlink" title="压缩html字符串（去除换行符）"></a>压缩html字符串（去除换行符）</h1><p>接收到的data如果不是json格式而是html，就需要进一步处理<br>但是在html中有各种换行符，不方便进行正则匹配，因此先把换行符去掉</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">htmlstring = htmlstring.replace(<span class="regexp">/[\r\n]/g</span>, <span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h1 id="用正则表达式提取有用的信息"><a href="#用正则表达式提取有用的信息" class="headerlink" title="用正则表达式提取有用的信息"></a>用正则表达式提取有用的信息</h1><p>去除了烦人的换行符后，就可以愉快地用正则来获取我们需要的信息啦</p>
<p>什么？你不会用正则？<br>学啊，相信你肯定搜到过这个 <a href="http://www.jb51.net/tools/zhengze.html">正则表达式30分钟入门教程</a> ，需要的时候看一看。</p>
<p>大致的匹配流程是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;&#x27;</span>);  <span class="comment">//参数为正则的pattern</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"></span><br><span class="line">arr = htmlstring.match(reg);  <span class="comment">//显然match()方法返回的是匹配结果的数组，如果没有结果则返回null</span></span><br></pre></td></tr></table></figure>
<p>这里贴个MDN上的文档，提高提高姿势水平</p>
<ul>
<li>[RegExp - JavaScript | MDN][]</li>
<li>[String.prototype.match() - JavaScript | MDN][]</li>
</ul>
<h1 id="解析html（可选）"><a href="#解析html（可选）" class="headerlink" title="解析html（可选）"></a>解析html（可选）</h1><p>如果你不想用正则对html数据进行处理，没关系，还可以选择对html数据构造DOM树，然后通过各种选择器来获取你需要的数据<br>像是node-jquery、node-htmlparser之类的，具体的做法问Google吧，这边贴上一篇文章供参考 <a href="https://cnodejs.org/topic/4fa0d3a1cc088b063a2e04a2">NodeJS 中寻找可用的 HTMLParser</a><br>我也没用过，就不多说了。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://stackoverflow.com/questions/12148948/how-do-i-ungzip-decompress-a-nodejs-requests-module-gzip-response-body">How do I ungzip (decompress) a NodeJS request’s module gzip response body?</a></li>
<li><a href="http://www.jb51.net/tools/zhengze.html">正则表达式30分钟入门教程</a></li>
<li>[RegExp - JavaScript | MDN][]</li>
<li>[String.prototype.match() - JavaScript | MDN][]</li>
</ul>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>网页抓取</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS利用postfix搭建邮件服务器</title>
    <url>/2016/08/31/centos-use-postfix/</url>
    <content><![CDATA[<p>之前我用nodemailer通过163邮箱来发送邮件，不过没过几天就一直ETIMEDOUT，不知道什么原因，想着还是自己搭一个来发邮件可能靠谱点（flag？）</p>
<h1 id="安装postfix"><a href="#安装postfix" class="headerlink" title="安装postfix"></a>安装postfix</h1><p>CentOS 7 自带了postfix服务，在/etc/postfix 目录下</p>
<p>没有安装的可以用yum安装</p>
<h1 id="为域名添加DNS解析"><a href="#为域名添加DNS解析" class="headerlink" title="为域名添加DNS解析"></a>为域名添加DNS解析</h1><p>需要添加三条记录，A记录、MX记录、TXT记录</p>
<h1 id="配置postfix"><a href="#配置postfix" class="headerlink" title="配置postfix"></a>配置postfix</h1><p>我接触postfix的时候貌似已经被人玩烂了，网上一搜几年前的文章一大把。</p>
<p>有关域名解析、postfix配置跟使用telnet测试发送邮件，可以参照这篇文章，亲测。</p>
<p><a href="http://www.cnblogs.com/dudu/archive/2012/12/12/linux-postfix-mailserver.html">阿里云CentOS Linux服务器上用postfix搭建邮件服务器</a></p>
<h1 id="Nodemailer连接本机邮件服务器"><a href="#Nodemailer连接本机邮件服务器" class="headerlink" title="Nodemailer连接本机邮件服务器"></a>Nodemailer连接本机邮件服务器</h1><p>配置好postfix后，就可以用自己的服务器发送邮件了。</p>
<p>smtp没有通过ssl加密时的端口是25</p>
<p>所以之前定义的transport</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> transport = nodemailer.createTransport(<span class="string">&#x27;smtps://username%40163.com:password@smtp.163.com&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>修改为</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> transport = nodemailer.createTransport(<span class="string">&#x27;smtp://@127.0.0.1:25&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>即可。</p>
<p>相应的，mailOptions里面的from改成<a href="mailto:&#120;&#x78;&#x78;&#64;&#100;&#x6f;&#109;&#x61;&#x69;&#110;&#46;&#116;&#x6c;&#x64;">&#120;&#x78;&#x78;&#64;&#100;&#x6f;&#109;&#x61;&#x69;&#110;&#46;&#116;&#x6c;&#x64;</a>（你自己的域名，其实改成其他任意域名都可以成功发送）</p>
<p><img src="http://img.blog.csdn.net/20160831012617040" alt="test mail"></p>
<p><img src="http://img.blog.csdn.net/20160831012638899" alt="other domain"></p>
<p>一般会在辣鸡邮件里面找到你发的邮件</p>
<h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>可以为自己的邮件服务器添加smtp认证跟ssl加密。</p>
<p>网上搜索sasl之类的。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://www.cnblogs.com/dudu/archive/2012/12/12/linux-postfix-mailserver.html">阿里云CentOS Linux服务器上用postfix搭建邮件服务器</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>邮件服务器</tag>
        <tag>postfix</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS 7 防止端口自动关闭</title>
    <url>/2016/09/09/centos-add-port-permanently/</url>
    <content><![CDATA[<h1 id="tl-dr"><a href="#tl-dr" class="headerlink" title="tl;dr"></a>tl;dr</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --zone=public --add-port=2888/tcp</span><br><span class="line">firewall-cmd --reload  <span class="comment">#重新载入服务</span></span><br></pre></td></tr></table></figure>
<p>永久配置firewalld开启端口。</p>
<h1 id="之前的一些坑"><a href="#之前的一些坑" class="headerlink" title="之前的一些坑"></a>之前的一些坑</h1><p>之前的一篇文章<a href="http://blog.csdn.net/azureternite/article/details/52349326">CentOS 7部署Node.js+MongoDB：在VPS上从安装到Hello world</a>中，讲到了CentOS开启端口用这个命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --add-port=3000/tcp</span><br></pre></td></tr></table></figure>
<p>这样是没错，开启了端口，但是后面发现这个端口会莫名其妙的被关闭</p>
<p>Google一番后了解到这样添加端口是运行时配置（Runtime configuration），在重载或重启firewalld后，这个配置就失效了。</p>
<h1 id="自动关闭原因"><a href="#自动关闭原因" class="headerlink" title="自动关闭原因"></a>自动关闭原因</h1><p>CentOS 7 采用了firewalld作为防火墙服务，在<a href="https://www.redhat.com/en">Red Hat</a>官方文档的<a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Security_Guide/sec-Using_Firewalls.html">Security Guide</a>中有介绍firewalld</p>
<blockquote>
<p>The dynamic firewall daemon firewalld provides a dynamically managed firewall with support for network “zones” to assign a level of trust to a network and its associated connections and interfaces. It has support for IPv4 and IPv6 firewall settings. It supports Ethernet bridges and has a separation of runtime and permanent configuration options. It also has an interface for services or applications to add firewall rules directly.</p>
</blockquote>
<p>动态防火墙守护进程firewalld提供一个动态管理的防火墙，支持网络“区域”（zones），以用来给一个网络以及其关联的链接和接口分配一个信任层级。firewalld支持IPv4跟IPv6的防火墙设置。它还支持以太网桥，并且有运行时配置选项跟永久配置选项<strong>（runtime and permanent configuration options）</strong>，二者相互分离。并且firewalld为服务或应用直接添加防火墙规则提供了接口。</p>
<p>有关Network Zones的概念这边不细讲，参照Security Guide。</p>
<p>firewalld有个图形化配置工具firewall-config，还有个命令行客户端，就是firewall-cmd了。</p>
<p>我们暂时还没用到图形化工具，所以这边就说一下firewall-cmd</p>
<p>Security Guide中关于firewall-cmd的介绍：</p>
<blockquote>
<p>A command line client, firewall-cmd, is provided. It can be used to make permanent and non-permanent runtime changes as explained in man firewall-cmd(1). Permanent changes need to be made as explained in the firewalld(1) man page. Note that the firewall-cmd command can be run by the root user and also by an administrative user, in other words, a member of the wheel group. In the latter case the command will be authorized via the polkit mechanism.</p>
</blockquote>
<p>具体就不翻译了，大概是说<br>firewall-cmd可以永久或非永久地改变配置，永久配置需要如man page中解释的那样改变（日了狗了）。</p>
<p>于是又去翻了翻firewalld(1)的man page，里面有两段关于Runtime configuration跟Permanent configuration的解释。</p>
<blockquote>
<p>Runtime configuration<br>       Runtime configuration is the actual active configuration and is not permanent. After<br>       reload/restart of the service or a system reboot, runtime settings will be gone if they<br>       haven’t been also in permanent configuration.</p>
</blockquote>
<blockquote>
<p>Permanent configuration<br>   The permanent configuration is stored in config files and will be loaded and become new<br>   runtime configuration with every machine boot or service reload/restart.</p>
</blockquote>
<p>运行时配置<br>        运行时配置是实际上启用了但不是永久的配置。在服务重载/重启或系统重启之后，运行时的设置如果不存在永久配置中，就会失效。</p>
<p>永久配置<br>        永久配置被保存在配置文件中，随着每次机器启动或服务重载/重启，永久配置都会被载入，变成新的运行时配置。</p>
<h1 id="永久开启端口"><a href="#永久开启端口" class="headerlink" title="永久开启端口"></a>永久开启端口</h1><p>好了，说了那么多，应该是理清楚端口被自动关闭的原委了，那怎么永久开启端口呢，万能的Security Guide中给出了答案</p>
<blockquote>
<p>The rules can be made permanent by adding the –permanent option using the firewall-cmd –permanent –direct command or by modifying /etc/firewalld/direct.xml. </p>
</blockquote>
<p>只要添加规则时加上–permanent参数或者修改/etc/firewalld/direct.xml就行了。</p>
<p>所以只需要两条命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --zone=public --add-port=2888/tcp</span><br><span class="line">firewall-cmd --reload  <span class="comment">#重新载入服务</span></span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Security_Guide/sec-Using_Firewalls.html">4.5. USING FIREWALLS</a></li>
<li><a href="http://www.unix.com/man-page/centos/1/firewalld/">CentOS 7.0 - man page for firewalld (centos section 1) - Unix &amp; Linux Commands</a></li>
<li><a href="http://stackoverflow.com/questions/24729024/centos-7-open-firewall-port">centos 7 - open firewall port - Stack Overflow</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>port</tag>
        <tag>firewalld</tag>
      </tags>
  </entry>
  <entry>
    <title>gulp-less解决遇到错误停止执行task</title>
    <url>/2016/09/09/gulp-less-no-stopping-running-tasks-on-error/</url>
    <content><![CDATA[<h1 id="来龙去脉"><a href="#来龙去脉" class="headerlink" title="来龙去脉"></a>来龙去脉</h1><p>在用less+gulp开发时，有时候代码还没写完整，不小心保存了一下，然后gulp就开始执行gulp-less的task。<br>但是代码是有问题的，这时候会输出一个Potentially unhandled rejection，告诉你哪里出问题了，然后，<br>然后就挂了！！pipe就会停止输入数据，整个task就停止了。<br>特别是我用Sublime，设置了失去焦点自动保存，很容易出现这个问题。</p>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p><a href="https://github.com/floatdrop/gulp-plumber">gulp-plumber</a>插件解决了这个问题。<br>插件作者的想法 <a href="https://gist.github.com/floatdrop/8269868">Error management in gulp</a></p>
<p>使用方法：</p>
<p>先npm下载下来</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install gulp-plumber --save-dev</span><br></pre></td></tr></table></figure>
<p>在gulpfile.js中，引入gulp-plumber，然后在处理less的task中加上：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> plumber = <span class="built_in">require</span>(<span class="string">&#x27;gulp-plumber&#x27;</span>);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">&#x27;less&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">&#x27;./less/*.less&#x27;</span>)</span><br><span class="line">        .pipe(plumber())  <span class="comment">//加上这句</span></span><br><span class="line">        .pipe(less())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">&#x27;./css&#x27;</span>))</span><br><span class="line">        .pipe(browserSync.stream());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://segmentfault.com/q/1010000002989913">gulp-less 开发使用中的问题 - SegmentFault</a></li>
<li><a href="http://www.zhihu.com/question/40091117">gulp-less插件自动编译跑着跑着挂了？ - 前端开发 - 知乎</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>构建工具</category>
      </categories>
      <tags>
        <tag>构建工具</tag>
        <tag>gulp</tag>
        <tag>gulp-less</tag>
        <tag>gulp-plumber</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端Web适配的两种做法思路总结</title>
    <url>/2016/09/13/mobile-web-content-adaptation-methods/</url>
    <content><![CDATA[<p><strong>看了几篇文章，理一下网易跟淘宝移动端适配的思路，主要是参考 <a href="http://www.cnblogs.com/lyzg/p/4877277.html">从网易与淘宝的font-size思考前端设计稿与工作流</a></strong></p>
<h1 id="像素相关概念"><a href="#像素相关概念" class="headerlink" title="像素相关概念"></a>像素相关概念</h1><h2 id="物理像素-physical-pixel"><a href="#物理像素-physical-pixel" class="headerlink" title="物理像素(physical pixel)"></a>物理像素(physical pixel)</h2><blockquote>
<p>一个物理像素是显示器(手机屏幕)上最小的物理显示单元，在操作系统的调度下，每一个设备像素都有自己的颜色值和亮度值。</p>
</blockquote>
<p>其值也就是我们常说的分辨率</p>
<h2 id="设备独立像素-density-independent-pixel"><a href="#设备独立像素-density-independent-pixel" class="headerlink" title="设备独立像素(density-independent pixel)"></a>设备独立像素(density-independent pixel)</h2><blockquote>
<p>设备独立像素(也叫密度无关像素)，可以认为是计算机坐标系统中得一个点，这个点代表一个可以由程序使用的虚拟像素(比如: css像素)，然后由相关系统转换为物理像素。</p>
</blockquote>
<p>简称dip，也可以称为CSS像素</p>
<h2 id="设备像素比-device-pixel-ratio"><a href="#设备像素比-device-pixel-ratio" class="headerlink" title="设备像素比(device pixel ratio)"></a>设备像素比(device pixel ratio)</h2><blockquote>
<p>设备像素比(简称dpr)定义了物理像素和设备独立像素的对应关系，它的值可以按如下的公式的得到：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设备像素比 &#x3D; 物理像素 &#x2F; 设备独立像素 &#x2F;&#x2F; 在某一方向上，x方向或者y方向</span><br></pre></td></tr></table></figure>
<h1 id="网易的做法"><a href="#网易的做法" class="headerlink" title="网易的做法"></a>网易的做法</h1><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>css中使用的尺寸与设计稿保持一致，body的宽度设为屏幕宽度</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>将页面宽度定为屏幕宽度，通过设置html的font-size与使用rem来实现尺寸与设计稿一致</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul>
<li>假设设计稿宽度为640px</li>
<li>那么以设计稿为准，设置body的宽度为640px</li>
<li>由于使用rem单位，因此需要设置html标签的font-size</li>
<li>为计算方便，取100px为参照，所以body的宽度为6.4rem</li>
<li>由于设备的dip!=设计稿宽度，因此font-size=deviceWidth/6.4</li>
<li>css尺寸为：设计稿标注尺寸/100</li>
</ul>
<h1 id="淘宝的做法"><a href="#淘宝的做法" class="headerlink" title="淘宝的做法"></a>淘宝的做法</h1><h2 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h2><p>页面大小与设计稿保持一致</p>
<h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>设置meta viewport中的scale保证页面大小与设计稿一致，使用rem</p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><ul>
<li>meta viewport中device-width的算法为：设备的物理分辨率/(devicePixelRatio * scale)</li>
<li>而每台设备的devicePixelRatio都是已知的，可通过window.devicePixelRatio获取</li>
<li>JavaScript动态计算设置scale，包括initial-scale，maximum-scale，minimum-scale</li>
<li>动态设置html的font-size，为屏幕分辨率/10</li>
<li>css尺寸为：设计稿标注尺寸/html的font-size</li>
</ul>
<h1 id="关于font-size能不能使用rem的问题"><a href="#关于font-size能不能使用rem的问题" class="headerlink" title="关于font-size能不能使用rem的问题"></a>关于font-size能不能使用rem的问题</h1><p>流云诸葛在文章中说font-size不能使用rem，要用media query，而实际上，网易的font-size也是有用rem来作为单位的。</p>
<p>那么为什么会说font-size不能使用rem呢？到底能不能用rem？</p>
<p>答案是<strong>能</strong>的。</p>
<p>说不能可能是因为在网页中有可能使用了<a href="https://zh.wikipedia.org/wiki/%E7%82%B9%E9%98%B5%E5%AD%97%E4%BD%93">点阵字体</a>，也叫位图字体，由于位图的缘故，点阵字体很难进行缩放。<br>这个概念与<a href="https://zh.wikipedia.org/wiki/%E7%9F%A2%E9%87%8F%E5%AD%97%E4%BD%93">矢量字体</a>相对应。</p>
<p>网上有给出对于文字使用px的原因的文章</p>
<blockquote>
<p>根据以下两个原因，对于文字使用px：</p>
</blockquote>
<blockquote>
<ul>
<li>在大屏设备希望看到更多的文字</li>
<li>中文点阵最好是在12px，14px，16px这种尺寸，使用rem就会无法避免使用13px，15px尺寸，这样文字会显示的很奇怪</li>
</ul>
</blockquote>
<p>虽然如此，但没有使用点阵字体的话，在一些情况，比如在需要自适应的情况下，使用rem也是没问题的。</p>
<h1 id="关于font-size的更新（2016-09-14-11-50）"><a href="#关于font-size的更新（2016-09-14-11-50）" class="headerlink" title="关于font-size的更新（2016-09-14 11:50）"></a>关于font-size的更新（2016-09-14 11:50）</h1><p>前面说到font-size能不能使用rem，给出的答案是 能。</p>
<p>但是经过一番摸索，这边我还是建议字号用px来作为单位。</p>
<p>为什么呢，除了点阵字体的原因，我们在使用rem时，在不同设备的字体大小不一样，而比较适合阅读的字号大小是14px或16px之类。</p>
<p>比如：iPhone5的设计稿是640px，那么根据网易的做法，html的font-size就是50px，那么我们根据设计稿定义一段文本的font-size为0.16rem，换算成px就是0.16 * 50 = 8 px，这样，在4吋iPhone上看这段文本时，就会显得很小；如果设置成0.32rem，在4吋iPhone上看是正常了，但是在较大屏幕上看，又会显得太大。</p>
<p>还有一个原因，使用rem最终是转换成px的，这样，转换后的px就有可能出现存在小数的情况，这个时候就可能出现1px的不对称。</p>
<p>因此我们在给文本定义字号时还是使用px，应对不同设备，使用media query，或者像淘宝的那种做法，在html中加上data-dpr，算出当前设备的dpr，再根据不同dpr来区分文本字号大小。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.a&#123;</span><br><span class="line">  font-size:12px;</span><br><span class="line">&#125;</span><br><span class="line">[data-dpr=<span class="string">&quot;2&quot;</span>] .a&#123;</span><br><span class="line">  font-size: 24px;</span><br><span class="line">&#125;</span><br><span class="line">[data-dpr=<span class="string">&quot;3&quot;</span>] .a&#123;</span><br><span class="line">  font-size: 36px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://www.cnblogs.com/lyzg/p/4877277.html">从网易与淘宝的font-size思考前端设计稿与工作流 - 流云诸葛 - 博客园</a></li>
<li><a href="http://div.io/topic/1092">移动端高清、多屏适配方案 - Div.IO</a></li>
<li><a href="http://blog.csdn.net/huang100qi/article/details/49886713">webapp font-size解决问题的方案</a></li>
<li><a href="https://github.com/imweb/mobile/issues/3">H5自适应改造方案——rem方案</a></li>
<li><a href="https://github.com/riskers/blog/issues/17">移动端适配方案(上)</a></li>
<li><a href="https://github.com/riskers/blog/issues/18">移动端适配方案(下)</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>移动端适配</tag>
      </tags>
  </entry>
  <entry>
    <title>div直接包裹行内元素高度变高的问题</title>
    <url>/2016/09/18/div-wrapping-inline-elements/</url>
    <content><![CDATA[<h1 id="问题的发现"><a href="#问题的发现" class="headerlink" title="问题的发现"></a>问题的发现</h1><p>最近搞一个页面，用div直接包裹了两个button，本以为很寻常的东西，div的高度却被莫名其妙的撑开了。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  html&#123;</span><br><span class="line">    font-size: 100px;</span><br><span class="line">  &#125;</span><br><span class="line">  button&#123;</span><br><span class="line">    font-size: 0.16rem;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;background-color:aqua;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>Button 1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>想来想去怀疑是line-height的问题，于是查了一下，搜到zxx的一篇文章<a href="http://www.zhangxinxu.com/wordpress/2015/08/css-deep-understand-vertical-align-and-line-height/">CSS深入理解vertical-align和line-height的基友关系</a></p>
<p>于是把div的line-height设置成0，button的vertical-align设置成top或bottom，问题解决。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-id">#div2</span>&#123;</span></span><br><span class="line">    line-height: 0;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-id">#btn2</span>&#123;</span></span><br><span class="line">    vertical-align: top;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div2&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color:aqua;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn2&quot;</span>&gt;</span>Button 2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>不过vertical-align设置成middle时button距离上边会有1px的间隙。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-id">#div3</span>&#123;</span></span><br><span class="line">    line-height: 0;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-id">#btn3</span>&#123;</span></span><br><span class="line">    vertical-align: middle;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div3&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color:aqua;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn3&quot;</span>&gt;</span>Button 3<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>研究中…</p>
<p>贴上测试代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&#x27;utf-8&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  html&#123;</span><br><span class="line">    font-size: 100px;</span><br><span class="line">  &#125;</span><br><span class="line">  button&#123;</span><br><span class="line">    font-size: 0.16rem;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;background-color:aqua;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn1&quot;</span>&gt;</span>button 1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-id">#div2</span>&#123;</span></span><br><span class="line">    line-height: 0;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-id">#btn2</span>&#123;</span></span><br><span class="line">    vertical-align: top;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div2&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color:aqua;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn2&quot;</span>&gt;</span>Button 2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-id">#div3</span>&#123;</span></span><br><span class="line">    line-height: 0;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-id">#btn3</span>&#123;</span></span><br><span class="line">    vertical-align: middle;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div3&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color:aqua;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn3&quot;</span>&gt;</span>Button 3<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://www.zhangxinxu.com/wordpress/2015/08/css-deep-understand-vertical-align-and-line-height/">CSS深入理解vertical-align和line-height的基友关系</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>ES6学习笔记（一）</title>
    <url>/2016/09/18/learning-es6-1/</url>
    <content><![CDATA[<p><strong>声明：本篇blog部分内容摘自<a href="http://www.ruanyifeng.com/home.html">阮一峰</a>老师的<a href="http://es6.ruanyifeng.com/">ECMAScript 6入门</a>，全部内容参考自上述链接</strong></p>
<h1 id="声明变量的方法"><a href="#声明变量的方法" class="headerlink" title="声明变量的方法"></a>声明变量的方法</h1><table>
<thead>
<tr>
<th></th>
<th>var</th>
<th>function</th>
<th>let</th>
<th>const</th>
<th>import</th>
<th>class</th>
</tr>
</thead>
<tbody><tr>
<td>作用域</td>
<td>函数或全局</td>
<td>顶层、函数和块级作用域</td>
<td>所在代码块</td>
<td>所在代码块</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>变量提升</td>
<td>存在</td>
<td>存在</td>
<td>不存在</td>
<td>不存在</td>
<td>存在</td>
<td>不存在</td>
</tr>
<tr>
<td>暂时性死区</td>
<td>无</td>
<td>无</td>
<td>有</td>
<td>有</td>
<td>无</td>
<td>有</td>
</tr>
<tr>
<td>重复声明</td>
<td>允许</td>
<td>允许</td>
<td>不允许</td>
<td>不允许</td>
<td>-</td>
<td>不允许</td>
</tr>
<tr>
<td>值可变</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>-</td>
<td>是</td>
</tr>
<tr>
<td>属于全局对象</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>-</td>
<td>否</td>
</tr>
</tbody></table>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>可访问到变量的代码区块</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a <span class="comment">// ReferenceError: a is not defined.</span></span><br><span class="line">b <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>不存在变量提升的声明方式，变量一定要在声明后使用，否则会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 输出undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// 报错ReferenceError</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<h2 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h2><blockquote>
<p>在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称TDZ）。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// TDZ开始</span></span><br><span class="line">  tmp = <span class="string">&#x27;abc&#x27;</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// ReferenceError</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> tmp; <span class="comment">// TDZ结束</span></span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">  tmp = <span class="number">123</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重复声明"><a href="#重复声明" class="headerlink" title="重复声明"></a>重复声明</h2><p>在同一个作用域内重复声明同一个变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arg; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> arg; <span class="comment">// 不报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="值可变"><a href="#值可变" class="headerlink" title="值可变"></a>值可变</h2><p>const声明的是一个只读的常量，声明时必须初始化，否则会报错。声明后常量的值不可改变。</p>
<p>对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。const只保证变量名指向的地址不变，而该地址的数据可变。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [];</span><br><span class="line">a.push(<span class="string">&#x27;Hello&#x27;</span>); <span class="comment">// 可执行</span></span><br><span class="line">a.length = <span class="number">0</span>;    <span class="comment">// 可执行</span></span><br><span class="line">a = [<span class="string">&#x27;Dave&#x27;</span>];    <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<h2 id="属于全局对象"><a href="#属于全局对象" class="headerlink" title="属于全局对象"></a>属于全局对象</h2><p>声明的全局变量是否属于全局对象（浏览器环境window，Node中是指global）</p>
<p>ES6规定var和function声明的全局变量为全局对象的属性，而let、const、class声明的全局变量不属于全局对象的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 如果在Node的REPL环境，可以写成global.a</span></span><br><span class="line"><span class="comment">// 或者采用通用方法，写成this.a</span></span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">window</span>.b <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h1 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote>
<p>ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p>
</blockquote>
<h2 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h2><p>数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line">foo <span class="comment">// 1</span></span><br><span class="line">bar <span class="comment">// 2</span></span><br><span class="line">baz <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">&quot;aaa&quot;</span>, <span class="attr">bar</span>: <span class="string">&quot;bbb&quot;</span> &#125;;</span><br><span class="line">foo <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line">bar <span class="comment">// &quot;bbb&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123; baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&quot;aaa&quot;</span>, <span class="attr">bar</span>: <span class="string">&quot;bbb&quot;</span> &#125;;</span><br><span class="line">baz <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">baz <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&quot;aaa&quot;</span>, <span class="attr">bar</span>: <span class="string">&quot;bbb&quot;</span> &#125;;</span><br><span class="line">baz <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line">foo <span class="comment">// error: foo is not defined</span></span><br></pre></td></tr></table></figure>
<p>字符串：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">a <span class="comment">// &quot;h&quot;</span></span><br><span class="line">b <span class="comment">// &quot;e&quot;</span></span><br><span class="line">c <span class="comment">// &quot;l&quot;</span></span><br><span class="line">d <span class="comment">// &quot;l&quot;</span></span><br><span class="line">e <span class="comment">// &quot;o&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span> : len&#125; = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">len <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>数值和布尔值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">123</span>;</span><br><span class="line">s === <span class="built_in">Number</span>.prototype.toString <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="literal">true</span>;</span><br><span class="line">s === <span class="built_in">Boolean</span>.prototype.toString <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>函数参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x, y]</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add([<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h2 id="数组与对象解构的区别"><a href="#数组与对象解构的区别" class="headerlink" title="数组与对象解构的区别"></a>数组与对象解构的区别</h2><p>数组的解构，元素是按顺序进行解构的，而对象的解构看的是属性名，与顺序无关。</p>
<h2 id="不完全解构"><a href="#不完全解构" class="headerlink" title="不完全解构"></a>不完全解构</h2><p>等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</p>
<p>以数组为例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">b <span class="comment">// 2</span></span><br><span class="line">d <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<h2 id="解构不成功"><a href="#解构不成功" class="headerlink" title="解构不成功"></a>解构不成功</h2><p>等号右边没有足够或对应的值供左边匹配</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> [foo] = [];</span><br><span class="line"><span class="keyword">var</span> [bar, foo] = [<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//两种情况foo都为undefined</span></span><br></pre></td></tr></table></figure>
<h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><blockquote>
<p>ES6内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];</span><br><span class="line"><span class="comment">//或者var [x = 1] = [];</span></span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];</span><br><span class="line"><span class="comment">//null不严格等于undefined</span></span><br><span class="line">x <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;aaa&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = f()] = [<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为x能取到值1，所以f()不会执行</span></span><br></pre></td></tr></table></figure>
<h2 id="报错的情况"><a href="#报错的情况" class="headerlink" title="报错的情况"></a>报错的情况</h2><p>如果等号右边是不可遍历的结构，则会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面的表达式都会报错，因为等号右边的值，要么转为对象以后不具备Iterator接口（前五个表达式），要么本身就不具备Iterator接口（最后一个表达式）。</p>
</blockquote>
<blockquote>
<p>事实上，只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值。</p>
</blockquote>
<h2 id="圆括号问题"><a href="#圆括号问题" class="headerlink" title="圆括号问题"></a>圆括号问题</h2><blockquote>
<p>只要有可能导致解构的歧义，就不得使用圆括号。</p>
</blockquote>
<p>否则会报错。</p>
<p>建议在模式中尽量不要用圆括号。</p>
<h2 id="解构的用途"><a href="#解构的用途" class="headerlink" title="解构的用途"></a>解构的用途</h2><ul>
<li>交换变量的值（<code>[x, y] = [y, x];</code>）</li>
<li>从函数返回多个值（<code>return [1, 2, 3];</code>）</li>
<li>定义函数参数（<code>function f([x, y, z]) &#123; ... &#125;</code>）</li>
<li>提取JSON数据（<code>let &#123; id, status, data: number &#125; = jsonData;</code>）</li>
<li>设置函数参数默认值（<code>function f(&#123;a = true, b = 1&#125;)&#123;...&#125;</code>）</li>
<li>遍历Map（<code>for (let [key, value] of map)&#123;&#125;</code>）</li>
<li>输入模块的指定方法（<code>const &#123; SourceMapConsumer, SourceNode &#125; = require(&quot;source-map&quot;);</code>）</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://es6.ruanyifeng.com/">ECMAScript 6入门</a></li>
</ul>
<p><strong>有关变量声明的还没看到class跟import，待更新…</strong></p>
]]></content>
  </entry>
  <entry>
    <title>HTTP协议入门要点</title>
    <url>/2016/09/20/http-getting-start-points/</url>
    <content><![CDATA[<p><strong>应用层协议、基于tcp</strong></p>
<h1 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP/0.9"></a>HTTP/0.9</h1><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p><code>GET</code></p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>服务器只能回应HTML字符串</li>
<li>服务器发送完毕后就关闭tcp连接</li>
</ul>
<h1 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h1><h2 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h2><p><code>GET</code> <code>POST</code> <code>HEAD</code></p>
<h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><ul>
<li>每次通信都必须包括头信息（HTTP header）</li>
<li>状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等</li>
<li>Content-Type</li>
<li>Content-Encoding</li>
<li>每个TCP连接只能发送一个请求（用Connection: keep-alive解决）</li>
</ul>
<h1 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h1><h2 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h2><p><code>GET</code> <code>POST</code> <code>PUT</code> <code>PATCH</code> <code>HEAD</code> <code>OPTIONS</code> <code>DELETE</code></p>
<h2 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h2><ul>
<li>持久连接，tcp连接默认不关闭，可被多个请求复用</li>
<li>管道机制，在同一个tcp连接中，客户端可以同时发送多个请求（但服务器还是按顺序回应请求）</li>
<li>Content-Length</li>
<li>分块传输，Transfer-Encoding: chunked，用来传输动态操作的数据，可不指定Content-Length</li>
<li>header里新增Host字段指定服务器的域名</li>
<li>队头堵塞，同一个tcp连接里，数据通信是按次序进行的，服务器只有处理完一个回应才会进行下一个回应</li>
</ul>
<h1 id="SPDY"><a href="#SPDY" class="headerlink" title="SPDY"></a>SPDY</h1><h2 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h2><ul>
<li>Google大佬自行研发的协议</li>
<li>主要解决HTTP/1.1效率不高的问题</li>
<li>作为HTTP/2的基础</li>
</ul>
<h1 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h1><h2 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h2><ul>
<li>二进制协议，头信息和数据体都是二进制，统称为 帧</li>
<li>多工，客户端和服务器都可以同时发送多个请求或回应，且不用按照顺序</li>
<li>数据流，同一个连接里连续的数据包可能属于不同的回应，因此需要给数据流（每个请求或回应的所有数据包）编号，客户端发出的数据流ID一律为奇数，服务器发出的ID为偶数</li>
<li>头信息压缩，使用gzip或compress压缩，客户端和服务器共同维护一张表，生成索引号，只发送索引号</li>
<li>服务器推送，服务器可主动向客户端发送资源，比如主动发送js、css等静态资源，不必等服务端解析HTML后发起请求</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://www.ruanyifeng.com/blog/2016/08/http.html">HTTP 协议入门 - 阮一峰的网络日志</a></li>
</ul>
]]></content>
      <categories>
        <category>协议</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>协议</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript数组去重的几种方法</title>
    <url>/2016/09/20/javascript-remove-duplicates-from-array/</url>
    <content><![CDATA[<p>这个老问题，网上普遍都有了，为什么要再写一遍呢，主要是为了记个笔记。。。</p>
<h1 id="遍历时搜索结果数组"><a href="#遍历时搜索结果数组" class="headerlink" title="遍历时搜索结果数组"></a>遍历时搜索结果数组</h1><p>思路很明确，如下</p>
<ul>
<li>新建一个数组存放结果</li>
<li>循环遍历原数组，对于每一个元素，在结果数组中搜索是否存在</li>
<li>若不存在则存入结果数组中，返回第二步，直到循环结束</li>
</ul>
<p>代码就不上了，网上一大把。</p>
<p>这是最直接的方法，但由于嵌套了循环，效率不高。</p>
<h1 id="先排序后比较"><a href="#先排序后比较" class="headerlink" title="先排序后比较"></a>先排序后比较</h1><ul>
<li>先将原数组进行排序</li>
<li>新建一个结果数组</li>
<li>遍历排序后的数组，比较第i个元素与结果数组的最后一个元素是否相等</li>
<li>如果不相等则存入结果数组</li>
</ul>
<p>同不上代码。</p>
<p>速度是快了些，但返回的是一个排序后的数组，并且有更快的方法。</p>
<h1 id="使用对象记录已有元素"><a href="#使用对象记录已有元素" class="headerlink" title="使用对象记录已有元素"></a>使用对象记录已有元素</h1><p>这个方法使用hashtable结构，避免了循环嵌套，而且返回的数组顺序没改变，效率也高。</p>
<p>主要思路是将原数组的元素作为对象的属性名来记录是否出现过：</p>
<ul>
<li>新建一个对象与结果数组</li>
<li>遍历原数组，对于第i个元素，访问对象中属性名为i的属性</li>
<li>如果属性不存在，则标记此属性为true，并将此元素存入结果数组中，返回第二步直到循环结束</li>
</ul>
<p>但是这样做也有个问题，对象的属性名在访问时会被转换为字符串，因此不同类型的值也可能被去重，<br>比如数字0跟字符’0’</p>
<p>解决办法：将hashtable中的标记 true ，改为保存出现过的类型的数组，在判断元素是否出现时，多判断一步保存的类型数组中是否出现过此类型即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> n = &#123;&#125;, r = [], len = <span class="built_in">this</span>.length, val, type;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.length; i++) &#123;  </span><br><span class="line">        val = <span class="built_in">this</span>[i]; <span class="comment">//数组元素</span></span><br><span class="line">        type = <span class="keyword">typeof</span> val;  <span class="comment">//数组元素的类型</span></span><br><span class="line">        <span class="keyword">if</span> (!n[val]) &#123;  <span class="comment">//如果没有记录</span></span><br><span class="line">            n[val] = [type];  <span class="comment">//保存类型</span></span><br><span class="line">            r.push(val);  <span class="comment">//保存元素到结果数组</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n[val].indexOf(type) &lt; <span class="number">0</span>) &#123; <span class="comment">//如果有记录，判断其类型是否在记录数组中，如果没有 </span></span><br><span class="line">            n[val].push(type);  <span class="comment">//将此类型添加到记录数组中</span></span><br><span class="line">            r.push(val);  <span class="comment">//保存元素到结果数组</span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> r;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此方法效率高，并且返回的数组元素顺序不变。</p>
<h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><p>ES6的许多新特性让人眼前一亮，最近拜读<a href="http://www.ruanyifeng.com/home.html">阮一峰</a>老师的<a href="http://es6.ruanyifeng.com/">ECMAScript 6入门</a>，又皮卡了一种新的数组去重方法</p>
<p>就是利用扩展运算符(…)跟Set数据结构的不重复特性来达到给数组去重的目的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...new <span class="built_in">Set</span>(<span class="built_in">this</span>)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>…就一行代码，简洁。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://blog.csdn.net/chengxuyuan20100425/article/details/8497277">js数组去重的4个方法</a> 以及底下的评论</li>
<li><a href="http://www.cnblogs.com/sosoft/archive/2013/12/08/3463830.html">高效率去掉js数组中重复项 - 柔城 - 博客园</a></li>
<li><a href="http://es6.ruanyifeng.com/#docs/set-map">Set和Map数据结构 - ECMAScript 6入门</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数组去重</tag>
      </tags>
  </entry>
  <entry>
    <title>页面两列布局高度填满</title>
    <url>/2016/09/22/html-2-column-layout-height-filled/</url>
    <content><![CDATA[<h1 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h1><p>昨天早上某面试提出的一个问题，脑子一热漏写了一个条件，心塞。</p>
<p>问题大概是写一个两列布局，左边固定，高度都是默认填满页面，右边内容高度超出浏览器窗口出现滚动条。</p>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>今天仔细想了下，用浮动做的话，高度不好弄成填满的。折腾了一会儿，搞出两种方案（不使用js的）。</p>
<ul>
<li>左侧：fixed，右侧：absolute，min-height:100%，width为calc(100% - [左侧的width])，同时margin-left也为左侧的width</li>
<li>html的overflow-x设置为hidden，右侧就可以不用calc了，直接width: 100%，不过这样的话，右侧元素使用margin 0 auto居中就会向右边偏移，偏移的长度为左侧的width</li>
</ul>
<p>测试代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>test layout<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line">    *&#123;</span><br><span class="line">      padding: 0;</span><br><span class="line">      margin: 0;</span><br><span class="line">    &#125;</span><br><span class="line">    /*html&#123;</span><br><span class="line"><span class="css">      <span class="selector-tag">overflow-x</span><span class="selector-pseudo">:hidden</span>;   </span></span><br><span class="line"><span class="css">    &#125;*/  <span class="comment">/*方法2*/</span></span></span><br><span class="line"><span class="css">    <span class="selector-class">.left</span>&#123;</span></span><br><span class="line">      position: fixed;</span><br><span class="line">      top: 0;</span><br><span class="line">      left: 0;</span><br><span class="line">      width: 100px;</span><br><span class="line">      height: 100%;</span><br><span class="line">      background-color: red;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.right</span>&#123;</span></span><br><span class="line">      position: absolute;</span><br><span class="line"><span class="css">      <span class="selector-tag">width</span>: <span class="selector-tag">calc</span>(100% <span class="selector-tag">-</span> 100<span class="selector-tag">px</span>);  <span class="comment">/*方法1*/</span></span></span><br><span class="line"><span class="css">      <span class="comment">/*width: 100%;*/</span>  <span class="comment">/*方法2*/</span></span></span><br><span class="line">      min-height: 100%;</span><br><span class="line">      margin-left: 100px;</span><br><span class="line">      background-color: blue;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.center</span>&#123;</span></span><br><span class="line">      width: 100px;</span><br><span class="line">      background-color: yellow;</span><br><span class="line">      margin: 0 auto;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> addBtn = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;js-add-btn&#x27;</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> delBtn = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;js-del-btn&#x27;</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> right = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;right&#x27;</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript">      addBtn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> pNode = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        pNode.innerText = <span class="string">&#x27;content&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">var</span> cpNode = pNode.cloneNode(<span class="literal">true</span>);</span></span><br><span class="line">          right.appendChild(cpNode);  </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="javascript">      delBtn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> children = right.children;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> len = children.length;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> delCount = len &gt; <span class="number">20</span> ? <span class="number">20</span> : len;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; delCount; i++)&#123;</span></span><br><span class="line">          right.removeChild(children[len - (i + 1)]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>left<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;js-add-btn&quot;</span>&gt;</span>增加右侧内容<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;js-del-btn&quot;</span>&gt;</span>删除右侧内容<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>centered content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>lots of content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>lots of content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>lots of content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>lots of content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>lots of content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>lots of content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>lots of content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>lots of content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>lots of content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>lots of content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>lots of content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>lots of content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>lots of content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>lots of content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>lots of content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>lots of content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>lots of content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>lots of content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>lots of content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>lots of content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>lots of content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>lots of content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>lots of content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>lots of content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>lots of content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>lots of content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>lots of content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>lots of content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>lots of content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>lots of content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>jsfiddle： <a href="https://jsfiddle.net/g9j8mcf4/1/">https://jsfiddle.net/g9j8mcf4/1/</a></p>
<script async src="//jsfiddle.net/g9j8mcf4/1/embed/"></script>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Array.prototype.filter()的实现</title>
    <url>/2016/09/22/javascript-filter-realize/</url>
    <content><![CDATA[<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><p>今年某前端笔试的一道题，大概就是实现一遍filter，包括一个可以改变上下文的要求，其实就是改变this啦，跟原生的filter一样的功能跟参数。</p>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>filter的功能就是过滤，传入一个函数作为条件，返回true则将元素加入最终返回的数组中。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.filter = <span class="function"><span class="keyword">function</span>(<span class="params">cb, context</span>)</span>&#123;</span><br><span class="line">  context = context || <span class="built_in">this</span>;  <span class="comment">//确定上下文，默认为this</span></span><br><span class="line">  <span class="keyword">var</span> len = <span class="built_in">this</span>.length;  <span class="comment">//数组的长度</span></span><br><span class="line">  <span class="keyword">var</span> r = [];  <span class="comment">//最终将返回的结果数组</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(cb.call(context, <span class="built_in">this</span>[i], i, <span class="built_in">this</span>))&#123;  <span class="comment">//filter回调函数的三个参数：元素值，元素索引，原数组</span></span><br><span class="line">      r.push(<span class="built_in">this</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><p>个人觉得考察的是call的使用</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>filter</tag>
      </tags>
  </entry>
  <entry>
    <title>var x=y=1;</title>
    <url>/2016/09/30/javascript-var-x=y=1/</url>
    <content><![CDATA[<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><p>今年某度校招笔试题</p>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x=y=<span class="number">1</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line"><span class="built_in">console</span>.log(y);</span><br></pre></td></tr></table></figure>
<p>答案是：<br>ReferenceError跟1</p>
<p>因为x是用var声明的，所以在函数外无法访问，而y不是。</p>
<p>一个小坑，记录一下。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>var</tag>
      </tags>
  </entry>
  <entry>
    <title>根据前序、中序构造二叉树，并输出后序</title>
    <url>/2016/10/11/binary-tree-pre-in-post-order/</url>
    <content><![CDATA[<p>用js写的根据前序、中序构造二叉树，并输出后序的一段代码，不知道有没有问题。</p>
<p>先上树：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">       A</span><br><span class="line">     &#x2F;   \</span><br><span class="line">    B     C</span><br><span class="line">   &#x2F; \   &#x2F; \</span><br><span class="line">  D   E F   G</span><br><span class="line"> &#x2F;</span><br><span class="line">H</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> preOrder = <span class="string">&#x27;ABDHECFG&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> inOrder = <span class="string">&#x27;HDBEAFCG&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> postOrder = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tree = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">create(preOrder, preOrder.length, inOrder, inOrder.length);</span><br><span class="line"><span class="built_in">console</span>.log(tree);</span><br><span class="line"></span><br><span class="line">getPostOrder(preOrder[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(postOrder);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">preStr, preLen, inStr, inLen</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> root = preStr[<span class="number">0</span>];</span><br><span class="line">  tree[root] = &#123;&#125;;</span><br><span class="line">  tree[root].l = tree[root].r = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(preLen == <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> rootInPos = inStr.indexOf(root);</span><br><span class="line">  <span class="keyword">var</span> lStr = inStr.substr(<span class="number">0</span>, rootInPos);</span><br><span class="line">  <span class="keyword">var</span> rStr = inStr.substr(rootInPos + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span>(lStr.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    tree[root].l = create(preStr.substr(<span class="number">1</span>), preStr.substr(<span class="number">1</span>).length, lStr, lStr.length);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(rStr.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    tree[root].r = create(preStr.substr(rootInPos + <span class="number">1</span>), preStr.substr(rootInPos + <span class="number">1</span>).length, rStr, rStr.length);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPreOrder</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(root)&#123;</span><br><span class="line">    preOrder += root;</span><br><span class="line">    getPreOrder(tree[root].l);</span><br><span class="line">    getPreOrder(tree[root].r);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInOrder</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(root)&#123;</span><br><span class="line">    getInOrder(tree[root].l);</span><br><span class="line">    inOrder += root;</span><br><span class="line">    getInOrder(tree[root].r);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPostOrder</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(root)&#123;</span><br><span class="line">    getPostOrder(tree[root].l);</span><br><span class="line">    getPostOrder(tree[root].r);</span><br><span class="line">    postOrder += root;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123; A: &#123; r: <span class="string">&#x27;C&#x27;</span>, l: <span class="string">&#x27;B&#x27;</span> &#125;,</span><br><span class="line">  B: &#123; r: <span class="string">&#x27;E&#x27;</span>, l: <span class="string">&#x27;D&#x27;</span> &#125;,</span><br><span class="line">  D: &#123; r: null, l: <span class="string">&#x27;H&#x27;</span> &#125;,</span><br><span class="line">  H: &#123; r: null, l: null &#125;,</span><br><span class="line">  E: &#123; r: null, l: null &#125;,</span><br><span class="line">  C: &#123; r: <span class="string">&#x27;G&#x27;</span>, l: <span class="string">&#x27;F&#x27;</span> &#125;,</span><br><span class="line">  F: &#123; r: null, l: null &#125;,</span><br><span class="line">  G: &#123; r: null, l: null &#125; &#125;</span><br><span class="line">HDEBFGCA</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
        <tag>遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript +new Array(017)</title>
    <url>/2016/10/13/javascript-unary-plus-operator/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>某龙的笔试题，问<code>console.log(+new Array(017));</code>输出什么</p>
<p>第一反应是考察new Array()跟017</p>
<p>其实考察的是<code>+</code></p>
<p><code>+</code>运算符作为二元运算符时，有两个功能</p>
<ul>
<li>数字相加</li>
<li>连接字符串</li>
</ul>
<p>数字相加没啥好说的，连接字符串时，会先把两个参数都转换成字符串再进行连接。</p>
<p><code>+</code>作为一元运算符时，会将参数转换为数字返回</p>
<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p>所以<code>console.log(+new Array(017));</code>输出的是<code>NaN</code></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>类似的还有<code>-</code>运算符，输出一个转换后的负数</p>
<p>附上一些其他的输出</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(+<span class="keyword">new</span> <span class="built_in">Array</span>());</span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">0</span>));</span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>));</span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>));  <span class="comment">//2以上都是NaN</span></span><br><span class="line"><span class="comment">//NaN</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(+[]);</span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(+[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(+[<span class="number">1</span>, <span class="number">2</span>]);</span><br><span class="line"><span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(+[<span class="literal">undefined</span>]);</span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(+[<span class="literal">undefined</span>, <span class="literal">undefined</span>]);</span><br><span class="line"><span class="comment">//NaN</span></span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://www.ecma-international.org/ecma-262/7.0/index.html#sec-unary-plus-operator">ECMAScript® 2016 Language Specification</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack打包生成的bundle.js文件过大的问题</title>
    <url>/2016/10/20/webpack-bundle-js-size-too-large/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>使用webpack进行打包时，发现bundle.js竟然有2M多。</p>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>网上有去除插件、提取第三方库、压缩代码等方法。</p>
<p>还有一个比较容易忽略的原因就是开了sourcemap</p>
<p>在生产环境中，应使用<code>devtool: false</code></p>
<p>关闭sourcemap后bundle.js的大小从2.46M降到302k</p>
<p><img src="http://img.blog.csdn.net/20161020142705217" alt="webpack bundle.js"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://www.jianshu.com/p/a64735eb0e2b">彻底解决 webpack 打包文件体积过大 - 简书</a></li>
<li><a href="http://react-china.org/t/webpack/2214">用webpack打包后的文件为什么会非常大？ - React 中文</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Handlebars学习之——表达式</title>
    <url>/2016/10/27/handlebars-expressions/</url>
    <content><![CDATA[

**Handlebars表达式是Handlebars模板的基本单元，可以单独在{{mustache}}中使用它，将它们传入Handlebars helper，或将它们作为hash arguments的值使用**

# 基本使用

<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><span class="template-variable">&#123;&#123;<span class="name">title</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
这个表达式的意思是：在当前上下文中查找`title`属性

Handlebars也可以使用`.`来分隔标识符，这类表达式被称为path

<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><span class="template-variable">&#123;&#123;<span class="name">article.title</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
这个表达式的意思是：在当前上下文中查找`article`属性，并在查找结果中查找`title`属性

也支持用`/`来分隔，但不推荐使用

标识符可以是任何Unicode编码的字符，除了：

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">空格 ! &quot; # % &amp; &#39; ( ) * + , . &#x2F; ; &lt; &#x3D; &gt; @ [ \ ] ^ &#96; &#123; | &#125; ~</span><br></pre></td></tr></table></figure>
要引用一个不是合法标识符的属性，可以用方括号`[`，如：

<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="template-tag">&#123;&#123;#<span class="name"><span class="builtin-name">each</span></span> articles.[10].[#comments]&#125;&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><span class="template-variable">&#123;&#123;<span class="name">subject</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-variable">&#123;&#123;<span class="name">body</span>&#125;&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="template-tag">&#123;&#123;/<span class="name"><span class="builtin-name">each</span></span>&#125;&#125;</span></span><br></pre></td></tr></table></figure>
上述`articles.[10].[#comments]`相当于JavaScript中的`articles[10]['#comments']`

当使用{{expression}}时，handlebars会转义其中的html内容，而使用{{{expression}}}时不会转义

<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="xml">Handlebars.registerHelper(&#x27;link&#x27;, function(str)&#123;</span></span><br><span class="line"><span class="xml">    return &#x27;<span class="tag">&lt;<span class="name">span</span>&gt;</span>&#x27;+ str +&#x27;<span class="tag">&lt;/<span class="name">span</span>&gt;</span>&#x27;;</span></span><br><span class="line"><span class="xml">&#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="template-variable">&#123;&#123;<span class="name">link</span> <span class="string">&#x27;hello&#x27;</span>&#125;&#125;</span><span class="xml">  //<span class="tag">&lt;<span class="name">span</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="template-variable">&#123;&#123;&#123;<span class="name">link</span> <span class="string">&#x27;hello&#x27;</span>&#125;&#125;&#125;</span><span class="xml">  //hello</span></span><br></pre></td></tr></table></figure>
# Helpers

handlebars helper相当于一个函数，先在js代码中注册一个helper：

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Handlebars.registerHelper(<span class="string">&#x27;link&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;&lt;span&gt;&#x27;</span>+ str +<span class="string">&#x27;&lt;/span&gt;&#x27;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
然后在模板文件中调用helper，第一个标识符为注册的helper的名称，在本例中为"link"，后面跟着helper回调函数的参数，可以是0个或多个，用空格隔开

<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="template-variable">&#123;&#123;&#123;<span class="name">link</span> <span class="string">&#x27;hello&#x27;</span>&#125;&#125;&#125;</span></span><br></pre></td></tr></table></figure>
此外，handlebars还可以接收一些可选的键值对序列作为helper回调函数最后一个参数的值（这在Handlebars中被称为hash arguments）。
hash arguments的key是一个普通的标识符，value则是一个Handlebars表达式，因此可以是标识符、path或字符串

模板文件中：

<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="template-variable">&#123;&#123;&#123;<span class="name"><span class="builtin-name">hash</span></span> <span class="string">&#x27;hello&#x27;</span> <span class="attr">href</span>=<span class="string">&#x27;world&#x27;</span>&#125;&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">handlebars.registerHelper(<span class="string">&#x27;hash&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">str, options</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(options.hash);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
输出

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">href</span>: <span class="string">&#x27;world&#x27;</span> &#125;</span><br></pre></td></tr></table></figure>
# 子表达式

Handlebars支持子表达式，可以在一个mustache中调用多个helper，内层helper的返回结果将作为外层helper的参数传递

<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="template-variable">&#123;&#123;<span class="name">outer-helper</span> (<span class="name">inner-helper</span> <span class="string">&#x27;abc&#x27;</span>) <span class="string">&#x27;def&#x27;</span>&#125;&#125;</span></span><br></pre></td></tr></table></figure>
# 控制空白

当在mustache语句的两侧使用`~`符号，可以去除那一侧的所有空白，直到遇到非空白字符或第一个handlebars表达式

示例：

上下文：

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  nav: [</span><br><span class="line">    &#123;<span class="attr">url</span>: <span class="string">&#x27;foo&#x27;</span>, <span class="attr">test</span>: <span class="literal">true</span>, <span class="attr">title</span>: <span class="string">&#x27;bar&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">url</span>: <span class="string">&#x27;bar&#x27;</span>&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
下列模板代码：

<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="template-tag">&#123;&#123;#<span class="name"><span class="builtin-name">each</span></span> nav&#125;&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;</span></span></span><span class="template-variable">&#123;&#123;<span class="name">url</span>&#125;&#125;</span><span class="xml"><span class="tag"><span class="string">&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-tag">&#123;&#123;#<span class="name"><span class="builtin-name">if</span></span> test&#125;&#125;</span></span><br><span class="line"><span class="xml">      </span><span class="template-variable">&#123;&#123;<span class="name">title</span>&#125;&#125;</span></span><br><span class="line"><span class="xml">    </span><span class="template-variable">&#123;&#123;^&#125;&#125;</span></span><br><span class="line"><span class="xml">      Empty</span></span><br><span class="line"><span class="xml">    </span><span class="template-tag">&#123;&#123;/<span class="name"><span class="builtin-name">if</span></span>&#125;&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="template-variable">&#123;&#123;~<span class="name">/each</span>&#125;&#125;</span></span><br></pre></td></tr></table></figure>
会输出：

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;foo&quot;</span>&gt;</span></span><br><span class="line">    bar</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;bar&quot;</span>&gt;</span></span><br><span class="line">    Empty</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
使用`~`去除空白：

<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="template-tag">&#123;&#123;#<span class="name"><span class="builtin-name">each</span></span> nav ~&#125;&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;</span></span></span><span class="template-variable">&#123;&#123;<span class="name">url</span>&#125;&#125;</span><span class="xml"><span class="tag"><span class="string">&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-variable">&#123;&#123;~#<span class="name"><span class="builtin-name">if</span></span> test&#125;&#125;</span></span><br><span class="line"><span class="xml">      </span><span class="template-variable">&#123;&#123;~<span class="name">title</span>&#125;&#125;</span></span><br><span class="line"><span class="xml">    </span><span class="template-variable">&#123;&#123;~^~&#125;&#125;</span></span><br><span class="line"><span class="xml">      Empty</span></span><br><span class="line"><span class="xml">    </span><span class="template-variable">&#123;&#123;~<span class="name">/if</span>~&#125;&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="template-variable">&#123;&#123;~<span class="name">/each</span>&#125;&#125;</span></span><br></pre></td></tr></table></figure>
输出：

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;foo&quot;</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;bar&quot;</span>&gt;</span>Empty<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
# 转义

这边说的转义并不是指html转义，而是输出模板语句，如直接输出`{{title}}`而不是输出`title`

Handlebars有两种转义方式：

* inline escapes
* raw blocks

inline escapes就是在mustache区块之前加一个反斜杠`\`

<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="xml">\&#123;&#123;escaped&#125;&#125;</span></span><br></pre></td></tr></table></figure>
raw blocks是用四个大括号`{{{{`将要转义的区块围住来进行转义

<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="template-tag">&#123;&#123;&#123;&#123;<span class="name">raw</span>&#125;&#125;&#125;&#125;</span></span><br><span class="line"><span class="xml">  &#123;&#123;escaped&#125;&#125;</span></span><br><span class="line"><span class="template-tag">&#123;&#123;&#123;&#123;/<span class="name">raw</span>&#125;&#125;&#125;&#125;</span></span><br></pre></td></tr></table></figure>
然后还要写一个helper：

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">handlebars.registerHelper(<span class="string">&#x27;raw&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> options.fn();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
(这么多花括号看得眼睛都花了...)



<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://handlebarsjs.com/expressions.html">Handlebars.js: Minimal Templating on Steroids</a></li>
</ul>
]]></content>
      <categories>
        <category>Handlebars</category>
      </categories>
      <tags>
        <tag>Handlebars</tag>
      </tags>
  </entry>
  <entry>
    <title>在Express中使用Handlebars模板引擎</title>
    <url>/2016/10/27/using-handlebars-in-express/</url>
    <content><![CDATA[<h1 id="Handlebars介绍"><a href="#Handlebars介绍" class="headerlink" title="Handlebars介绍"></a>Handlebars介绍</h1><blockquote>
<p>Handlebars 是 JavaScript 一个语义模板库，通过对view和data的分离来快速构建Web模板。它采用”Logic-less template”（无逻辑模版）的思路，在加载时被预编译，而不是到了客户端执行到代码时再去编译， 这样可以保证模板加载和运行的速度。Handlebars兼容Mustache，你可以在Handlebars中导入Mustache模板。</p>
</blockquote>
<h1 id="在Express中使用"><a href="#在Express中使用" class="headerlink" title="在Express中使用"></a>在Express中使用</h1><p>在Express中使用Handlebars，有一个hbs模块，对Handlebars进行了包装，可以代替Express自带的jade或ejs模板引擎</p>
<p>安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hbs --save</span><br></pre></td></tr></table></figure>
<p>在app.js中设置view engine</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.set(<span class="string">&#x27;view engine&#x27;</span>, <span class="string">&#x27;hbs&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>如果要在不同扩展名的文件中使用Handlebars（如.html文件）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.set(<span class="string">&#x27;view engine&#x27;</span>, <span class="string">&#x27;html&#x27;</span>);</span><br><span class="line">app.engine(<span class="string">&#x27;html&#x27;</span>, <span class="built_in">require</span>(<span class="string">&#x27;hbs&#x27;</span>).__express);</span><br></pre></td></tr></table></figure>
<p>然后就可以在views文件夹中使用.hbs的模板文件了。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://www.ghostchina.com/introducing-the-handlebars-js-templating-engine/">Handlebars.js 模板引擎 | Ghost中文网</a></li>
<li><a href="https://github.com/pillarjs/hbs">pillarjs/hbs: Express view engine wrapper for Handlebars</a></li>
</ul>
]]></content>
      <categories>
        <category>Node.js</category>
        <category>Handlebars</category>
      </categories>
      <tags>
        <tag>Handlebars</tag>
        <tag>Express</tag>
        <tag>hbs</tag>
      </tags>
  </entry>
  <entry>
    <title>Handlebars学习之——HTML转义</title>
    <url>/2016/11/04/handlebars-html-escaping/</url>
    <content><![CDATA[

# 场景

使用`{{expression}}`时，输出的内容会被转义，如：

<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><span class="template-variable">&#123;&#123;<span class="name">title</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
context为

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  title: <span class="string">&#x27;&lt;p&gt;Hello world&lt;/p&gt;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
结果生成html：

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="symbol">&amp;lt;</span>Hello world<span class="symbol">&amp;gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
最终在页面上显示的就是字符串`<p>Hello world</p>`

如果不想进行html的转义，有两种方法：

* {{{
* SafeString

# {{{

在模板中将两个花括号替换成三个花括号，即可避免html字符串被转义

<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><span class="template-variable">&#123;&#123;<span class="name">title</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><span class="template-variable">&#123;&#123;&#123;<span class="name">body</span>&#125;&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
传入的context为

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  title: <span class="string">&#x27;&lt;p&gt;Hello world&lt;/p&gt;&#x27;</span>,</span><br><span class="line">  body: <span class="string">&#x27;&lt;p&gt;Hello world&lt;/p&gt;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
生成的结果：

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="symbol">&amp;lt;</span>Hello world<span class="symbol">&amp;gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
页面上显示的就是

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;Hello world&lt;&#x2F;p&gt;</span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure>
# SafeString

Handlebars提供一个SafeString方法，使用这个方法返回的值即便在{{expression}}中也不会被转义

Handlebars模板：

<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="template-variable">&#123;&#123;<span class="name">sayhi</span>&#125;&#125;</span></span><br></pre></td></tr></table></figure>
JavaScript:

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Handlebars.registerHelper(<span class="string">&#x27;sayhi&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> str = <span class="string">&#x27;&lt;p&gt;Hello world&lt;/p&gt;&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Handlebars.SafeString(str);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://handlebarsjs.com/">Handlebars.js: Minimal Templating on Steroids</a></li>
</ul>
]]></content>
      <categories>
        <category>Handlebars</category>
      </categories>
      <tags>
        <tag>Handlebars</tag>
      </tags>
  </entry>
  <entry>
    <title>Handlebars学习之——块表达式</title>
    <url>/2016/11/08/handlebars-block-expressions/</url>
    <content><![CDATA[

**Block helper可以让你自定义迭代器和其他可以传入新的上下文的功能**

# 基本块

Block helper的定义方法是：在一个mustache中，以`#`开头，后面跟着helper的名称，然后对应的在一个mustache中以`/`开头，加上相同的名称作为这个块的结尾。

形如：

<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="template-tag">&#123;&#123;#<span class="name">hello</span>&#125;&#125;</span></span><br><span class="line"><span class="xml">  </span><span class="template-variable">&#123;&#123;<span class="name">item</span>&#125;&#125;</span></span><br><span class="line"><span class="template-tag">&#123;&#123;/<span class="name">hello</span>&#125;&#125;</span></span><br></pre></td></tr></table></figure>
在helper中，function接收一个hash参数options，而options有个fn方法，该方法可接收一个context参数来改变block中的上下文，返回一个类似于编译后的Handlebars模板，明确地说，就是一个字符串。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Handlebars.registerHelper(<span class="string">&#x27;hello&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> options.fn(<span class="built_in">this</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
在上面的代码中，我们给options.fn传入了一个新的上下文，这个新的context是this，就是代表当前的上下文，因此，如果当前的上下文是：

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  title: <span class="string">&#x27;This is the title.&#x27;</span>,</span><br><span class="line">  body: <span class="string">&#x27;body&#x27;</span>,</span><br><span class="line">  item: <span class="string">&#x27;item&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
那么block中的item标识符最终返回字符串`'item'`

注：以这种方式定义的helper，在模板中，可以使用path，如上面的`{{item}}`可以写成`{{./item}}`

# with helper(内置)

with helper会把传入的context直接调用，实现如下

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Handlebars.registerHelper(<span class="string">&#x27;with&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">context, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> options.fn(context);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
当处理json的时候用with比较方便

<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;entry&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><span class="template-variable">&#123;&#123;<span class="name">title</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">  </span><span class="template-tag">&#123;&#123;#<span class="name"><span class="builtin-name">with</span></span> story&#125;&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;intro&quot;</span>&gt;</span></span><span class="template-variable">&#123;&#123;&#123;<span class="name">intro</span>&#125;&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;body&quot;</span>&gt;</span></span><span class="template-variable">&#123;&#123;&#123;<span class="name">body</span>&#125;&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  </span><span class="template-tag">&#123;&#123;/<span class="name"><span class="builtin-name">with</span></span>&#125;&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
context:

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  title: <span class="string">&quot;First Post&quot;</span>,</span><br><span class="line">  story: &#123;</span><br><span class="line">    intro: <span class="string">&quot;Before the jump&quot;</span>,</span><br><span class="line">    body: <span class="string">&quot;After the jump&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
# 简单迭代器

先来看一下内置的each helper是怎么实现的

<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;comments&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">  </span><span class="template-tag">&#123;&#123;#<span class="name"><span class="builtin-name">each</span></span> comments&#125;&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;comment&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span></span><span class="template-variable">&#123;&#123;<span class="name">subject</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">      </span><span class="template-variable">&#123;&#123;&#123;<span class="name">body</span>&#125;&#125;&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  </span><span class="template-tag">&#123;&#123;/<span class="name"><span class="builtin-name">each</span></span>&#125;&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
helper:

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Handlebars.registerHelper(<span class="string">&#x27;each&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">context, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ret = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>, j=context.length; i&lt;j; i++) &#123;</span><br><span class="line">    ret = ret + options.fn(context[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
其实就是在helper中遍历了一次context。明白了这一点，我们就可以对其进行改造，实现自定义的迭代器了。如：

<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="template-tag">&#123;&#123;#<span class="name">list</span> nav&#125;&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;</span></span></span><span class="template-variable">&#123;&#123;<span class="name">url</span>&#125;&#125;</span><span class="xml"><span class="tag"><span class="string">&quot;</span>&gt;</span></span><span class="template-variable">&#123;&#123;<span class="name">title</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="template-tag">&#123;&#123;/<span class="name">list</span>&#125;&#125;</span></span><br></pre></td></tr></table></figure>
context:

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  nav: [</span><br><span class="line">    &#123; <span class="attr">url</span>: <span class="string">&quot;http://www.yehudakatz.com&quot;</span>, <span class="attr">title</span>: <span class="string">&quot;Katz Got Your Tongue&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">url</span>: <span class="string">&quot;http://www.sproutcore.com/block&quot;</span>, <span class="attr">title</span>: <span class="string">&quot;SproutCore Blog&quot;</span> &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
helper:

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Handlebars.registerHelper(<span class="string">&#x27;list&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">context, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ret = <span class="string">&quot;&lt;ul&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>, j=context.length; i&lt;j; i++) &#123;</span><br><span class="line">    ret = ret + <span class="string">&quot;&lt;li&gt;&quot;</span> + options.fn(context[i]) + <span class="string">&quot;&lt;/li&gt;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret + <span class="string">&quot;&lt;/ul&gt;&quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
# 条件表达式

Handlebars中内置的if只能判断true/false，具体实现如下：

<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="template-tag">&#123;&#123;#<span class="name"><span class="builtin-name">if</span></span> isActive&#125;&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;star.gif&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Active&quot;</span>&gt;</span></span></span><br><span class="line"><span class="template-tag">&#123;&#123;<span class="keyword">else</span>&#125;&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;cry.gif&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Inactive&quot;</span>&gt;</span></span></span><br><span class="line"><span class="template-tag">&#123;&#123;/<span class="name"><span class="builtin-name">if</span></span>&#125;&#125;</span></span><br></pre></td></tr></table></figure>
helper:

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Handlebars.registerHelper(<span class="string">&#x27;if&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">conditional, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(conditional) &#123;</span><br><span class="line">    <span class="keyword">return</span> options.fn(<span class="built_in">this</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> options.inverse(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
其中，`options.inverse`用来处理block中的else语句，对此，我们也可以实现自定义的条件helper来增强条件语句的功能

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Handlebars.registerHelper(<span class="string">&#x27;equal&#x27;</span> <span class="function"><span class="keyword">function</span>(<span class="params">param1, param2, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(param1 == param2) &#123;</span><br><span class="line">    <span class="keyword">return</span> options.fn(<span class="built_in">this</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> options.inverse(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="template-tag">&#123;&#123;#<span class="name">equal</span> <span class="string">&#x27;hello&#x27;</span> <span class="string">&#x27;world&#x27;</span>&#125;&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>==<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">  </span><span class="template-tag">&#123;&#123;<span class="keyword">else</span>&#125;&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>!=<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="template-tag">&#123;&#123;/<span class="name">equal</span>&#125;&#125;</span></span><br></pre></td></tr></table></figure>
以上示例展示了判断两个变量相等或不等时执行的操作。

此外，Handlebars支持链式的条件语句，如

<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="template-tag">&#123;&#123;#<span class="name"><span class="builtin-name">if</span></span> isActive&#125;&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;star.gif&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Active&quot;</span>&gt;</span></span></span><br><span class="line"><span class="template-tag">&#123;&#123;<span class="keyword">else</span> <span class="keyword">if</span> isInactive&#125;&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;cry.gif&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Inactive&quot;</span>&gt;</span></span></span><br><span class="line"><span class="template-tag">&#123;&#123;/<span class="name"><span class="builtin-name">if</span></span>&#125;&#125;</span></span><br></pre></td></tr></table></figure>
# hash参数

hash arguments在之前的文章有提到过，就是将一些键值对序列作为helper回调函数最后一个参数的值，通过`options.hash`来访问。

<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="template-tag">&#123;&#123;#<span class="name">list</span> nav <span class="attr">id</span>=<span class="string">&quot;nav-bar&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top&quot;</span>&#125;&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;</span></span></span><span class="template-variable">&#123;&#123;<span class="name">url</span>&#125;&#125;</span><span class="xml"><span class="tag"><span class="string">&quot;</span>&gt;</span></span><span class="template-variable">&#123;&#123;<span class="name">title</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="template-tag">&#123;&#123;/<span class="name">list</span>&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Handlebars.registerHelper(<span class="string">&#x27;list&#x27;</span> <span class="function"><span class="keyword">function</span>(<span class="params">context, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> attrs = Em.keys(options.hash).map(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key + <span class="string">&#x27;=&quot;&#x27;</span> + options.hash[key] + <span class="string">&#x27;&quot;&#x27;</span>;</span><br><span class="line">  &#125;).join(<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;&lt;ul &quot;</span> + attrs + <span class="string">&quot;&gt;&quot;</span> + context.map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&lt;li&gt;&quot;</span> + options.fn(item) + <span class="string">&quot;&lt;/li&gt;&quot;</span>;</span><br><span class="line">  &#125;).join(<span class="string">&quot;\n&quot;</span>) + <span class="string">&quot;&lt;/ul&gt;&quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
# 块参数

Handlebars 3.0的新特性。

<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="template-tag">&#123;&#123;#<span class="name"><span class="builtin-name">each</span></span> users <span class="keyword">as</span> |user userId|&#125;&#125;</span></span><br><span class="line"><span class="xml">  Id: </span><span class="template-variable">&#123;&#123;<span class="name">userId</span>&#125;&#125;</span><span class="xml"> Name: </span><span class="template-variable">&#123;&#123;<span class="name">user.name</span>&#125;&#125;</span></span><br><span class="line"><span class="template-tag">&#123;&#123;/<span class="name"><span class="builtin-name">each</span></span>&#125;&#125;</span></span><br></pre></td></tr></table></figure>
这边`user`会取当前context的值，而`userId`会取当前遍历context的索引值。
有点类似于JavaScript里的Array.map

# raw helper

之前也提到过，用来转义的

<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="template-tag">&#123;&#123;&#123;&#123;<span class="name">raw-helper</span>&#125;&#125;&#125;&#125;</span></span><br><span class="line"><span class="xml">  &#123;&#123;bar&#125;&#125;</span></span><br><span class="line"><span class="template-tag">&#123;&#123;&#123;&#123;/<span class="name">raw-helper</span>&#125;&#125;&#125;&#125;</span></span><br></pre></td></tr></table></figure>
helper:

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Handlebars.registerHelper(<span class="string">&#x27;raw-helper&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> options.fn();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
输出：

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123;bar&#125;&#125;</span><br></pre></td></tr></table></figure>
# 参考

* [Handlebars.js: Minimal Templating on Steroids][]




]]></content>
      <categories>
        <category>Handlebars</category>
      </categories>
      <tags>
        <tag>Handlebars</tag>
      </tags>
  </entry>
  <entry>
    <title>git的基本使用流程</title>
    <url>/2016/12/07/git-basic-workflow/</url>
    <content><![CDATA[<h1 id="关于git的基本理解"><a href="#关于git的基本理解" class="headerlink" title="关于git的基本理解"></a>关于git的基本理解</h1><p>git：一种分布式版本控制系统</p>
<p>git保存的是每一次改动，而不是文件本身。</p>
<hr>
<p>git有三个区：</p>
<p><strong>工作区(Working Directory)</strong></p>
<p>这个区就是你在电脑上创建项目的地方，文件的编辑修改都在这个区中进行。</p>
<p><strong>暂存区(Stage Area)</strong></p>
<p>暂存区存放的是待提交到repo的修改，当你使用git add命令时，就是把工作区的修改添加到暂存区。</p>
<p><strong>版本库/仓库(Git Directory/Repository)</strong></p>
<p>每次使用git commit命令，就是把暂存区中的内容全部提交到repo中。</p>
<hr>
<p>关于分支：</p>
<p>新建分支默认是master。</p>
<p>master分支应该是一个稳定的，可用的应用，平时不在这个分支上工作。</p>
<p>当要添加新功能时，可从master分支新建一个分支，如feature分支，当新功能完成时，再合并到master分支上，这样，master分支始终是稳定可用的。</p>
<p>多人合作时，可以每个人在各自的分支上工作，时不时合并到同一个分支上，当功能完善时，再合并到master分支。</p>
<p>分支之间大概是这种感觉(假设A、B两个人开发)：</p>
<p><img src="http://img.blog.csdn.net/20161209172839993?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYXp1cmV0ZXJuaXRl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="branches"></p>
<p>当master分支上的应用出现bug时，可以在master分支上新建一个bug分支，如issue-101，修复bug后再合并到master分支上，然后删除bug分支。</p>
<h1 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h1><p>假设你已经安装了git</p>
<p>以下考虑最基本的git使用流程，开发时遇到的情况很多，以下流程暂不列出删除、撤销、回退的步骤，后面再单独列出来。</p>
<p>暂不考虑多人合作与远程repo，后面再补充，因为了解了怎么自己玩git，也就明白怎么跟基友一起玩github了。</p>
<p>因此以下流程都是在本地进行，跟github啥的暂时没什么关系。</p>
<p>新建repo-&gt;修改文件-&gt;添加修改到暂存区-&gt;提交修改到repo-&gt;创建分支-&gt;修改文件-&gt;添加修改到暂存区-&gt;提交修改到repo-&gt;合并分支-&gt;解决冲突</p>
<p>创建bug分支-&gt;修复bug-&gt;合并分支</p>
<h1 id="流程步骤"><a href="#流程步骤" class="headerlink" title="流程步骤"></a>流程步骤</h1><p><strong>新建repo</strong></p>
<p>在项目根目录下使用<code>git init</code>初始化git仓库</p>
<p><strong>修改文件</strong></p>
<p>我们在项目目录下新建一个hello.txt文件，里面输入内容<code>hello world</code>（注意不要用Windows自带的记事本创建、编辑）</p>
<p>然后输入<code>git status</code>，会看到输出了这些信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">Initial commit</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">        hello.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure>
<p>这边git提示我们有一个Untracked file，可以用<code>git add &lt;file&gt;</code>来添加要提交的文件。</p>
<p><strong>添加修改到暂存区</strong></p>
<p>按照提示，我们输入<code>git add hello.txt</code>把文件添加到暂存区（使用<code>git add .</code>添加更改过的全部文件）</p>
<p>再次输入<code>git status</code>，这次看到输出信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">Initial commit</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        new file:   hello.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>hello.txt已经被存放到暂存区了</p>
<p><strong>提交修改到repo</strong></p>
<p>使用<code>git commit -m &#39;add hello.txt&#39;</code>来提交这个文件的更改</p>
<p>输出信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[master (root-commit) 88aa3e8] add hello.txt</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 hello.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这时候，文件的更改已经提交到repo中。</p>
<p><strong>创建分支</strong></p>
<p>在master分支下：</p>
<p><code>git checkout -b feature</code>创建并切换到feature分支</p>
<p>创建分支是<code>git branch feature</code>，创建feature分支</p>
<p>切换分支是<code>git checkout feature</code>，切换到feature分支</p>
<p><strong>合并分支</strong></p>
<p>我们切换到feature分支，<code>git checkout feature</code></p>
<p>打开刚才的hello.txt</p>
<p>把内容修改成<code>goodbye world</code></p>
<p>然后用<code>git add</code>跟<code>git commit</code>命令提交到repo中</p>
<p>切换到master分支，在hello.txt文件结尾加上一行<code>hello world again</code>，然后提交</p>
<p>这时候，两个分支各有一个提交(commit)</p>
<p>我们切换到master分支<code>git checkout master</code></p>
<p>然后把feature分支合并到master分支上，<code>git merge --no-ff -m &#39;merge feature&#39; feature</code></p>
<p>这时候会提示有冲突：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Auto-merging hello.txt</span><br><span class="line">CONFLICT (content): Merge conflict in hello.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>
<p>git提示我们解决了冲突再把结果commit。</p>
<p><strong>解决冲突</strong></p>
<p>冲突在多人合作中应该是常有的事。</p>
<p>我们打开hello.txt，发现内容变成了这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello world</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">hello world again</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">goodbye world</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>于是我们把hello.txt修改成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello world</span><br><span class="line">goodbye world</span><br></pre></td></tr></table></figure>
<p>然后提交</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add hello.txt</span><br><span class="line">git commit -m <span class="string">&#x27;fix conflict&#x27;</span></span><br><span class="line">[master 40cd928] fix conflict</span><br></pre></td></tr></table></figure>
<p>分支合并成功。</p>
<p>可以用<code>git log --graph --pretty=oneline --abbrev-commit</code>来查看合并的情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*   40cd928 fix conflict</span><br><span class="line">|\</span><br><span class="line">| * 3cbd4df modified hello.txt</span><br><span class="line">* | a40c0bc add &quot;again&quot;</span><br><span class="line">|&#x2F;</span><br><span class="line">* 10fb7e4 add hello.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>log的顺序是按时间顺序从下到上。</p>
<p><strong>bug分支</strong></p>
<p>假设现在master分支上发现了个bug，需要紧急修复，但你现在正在feature分支上工作</p>
<p>假设现在hello.txt的内容是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello world</span><br><span class="line">goodbye world</span><br><span class="line"></span><br><span class="line">feature branch unfinished work</span><br></pre></td></tr></table></figure>
<p>现在feature分支上的功能还未完成，无法提交，但是需要修复bug。这时，就需要使用<code>git stash</code>保存工作现场。</p>
<p>于是，在feature分支上，输入<code>git stash</code>，看到输出信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Saved working directory and index state WIP on feature: 3cbd4df modified hello.txt</span><br><span class="line">HEAD is now at 3cbd4df modified hello.txt</span><br></pre></td></tr></table></figure>
<p>这时候，再输入<code>git status</code>，发现输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">On branch feature</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>
<p>现场已被保存，打开hello.txt，后面的那句<code>feature branch unfinished work</code>也不见了。</p>
<p>好，现在我们可以切换到master分支，并新建一个bug分支来修复这个bug了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git checkout -b issue-101</span><br></pre></td></tr></table></figure>
<p>在hello.txt中添加一行<code>issue-101 bug fixed</code>，提交到repo</p>
<p>然后切回master分支，把issue-101分支合并进来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add hello.txt</span><br><span class="line">git commit -m &#39;bug fixed&#39;</span><br><span class="line"></span><br><span class="line">git checkout master</span><br><span class="line">git merge --no-ff -m &#39;merge issue-101&#39; issue-101</span><br></pre></td></tr></table></figure>
<p>输出信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Merge made by the &#39;recursive&#39; strategy.</span><br><span class="line"> hello.txt | 4 +++-</span><br><span class="line"> 1 file changed, 3 insertions(+), 1 deletion(-)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>合并完成，然后我们回到feature分支继续工作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout feature</span><br></pre></td></tr></table></figure>
<p>但是现在hello.txt里面的内容还是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello world</span><br><span class="line">goodbye world</span><br></pre></td></tr></table></figure>
<p>我们需要把之前未完成的工作现场恢复过来。</p>
<p>使用<code>git stash list</code>可以查看保存了哪些工作现场：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stash@&#123;0&#125;: WIP on feature: 3cbd4df modified hello.txt</span><br></pre></td></tr></table></figure>
<p>可以看到，这边只有一条数据，我们可以使用<code>git stash pop</code>来恢复这个现场。</p>
<p>输出的信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">On branch feature</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   hello.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)</span><br><span class="line">Dropped refs&#x2F;stash@&#123;0&#125; (643bef60d9b9540f66675d2fe1e8d9ad9d35f4fd)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，hello.txt里面的<code>feature branch unfinished work</code>又回来了<br>并且在恢复现场后，<code>Dropped refs/stash@&#123;0&#125; (643bef60d9b9540f66675d2fe1e8d9ad9d35f4fd)</code><br>删除了stash的内容。</p>
<p>如果有多条stash数据，可以用<code>git stash apply</code>来恢复，如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure>
<p>但是用这种方式，stash内容并不会被删除，如果要删除某条stash，用<code>git stash drop</code></p>
<h1 id="删除、撤销、回退"><a href="#删除、撤销、回退" class="headerlink" title="删除、撤销、回退"></a>删除、撤销、回退</h1><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p><strong>删除文件</strong></p>
<p>假设我们有个文件，已经commit到repo中了，需要删除。<br>为此，我们新建一个文本文件delete.txt来模拟这个文件，把它提交到repo中。</p>
<p>这时候我们可以用两种方法来删除delete.txt。</p>
<p>1、使用<code>git rm delete.txt</code></p>
<p>执行这句之后，会输出一句<code>rm &#39;delete.txt&#39;</code>，这时候到工作区查看，会发现delete.txt已经不在工作区了。</p>
<p>输入<code>git status</code>，发现输出如下信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">On branch feature</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        deleted:    delete.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>暂存区已经记录了删除delete.txt的操作，接下来只要<code>git commit</code>就可以把delete.txt从repo中删除了。</p>
<p>2、直接从工作区目录中删除delete.txt，然后<code>git add</code>，<code>git commit</code>提交修改。</p>
<p><strong>删除分支</strong></p>
<p><code>git branch -d &lt;name&gt;</code>可以删除分支。</p>
<p>例如我们可以删除之前用来修bug的issue-101分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -d issue-101</span><br></pre></td></tr></table></figure>
<p>执行后输出的信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Deleted branch issue-101 (was 5d97433).</span><br></pre></td></tr></table></figure>
<p>用<code>git branch</code>查看分支，输出信息中表示只剩master分支跟feature分支了。</p>
<p>如果要删除一个未合并的分支，默认git会报错，例如我们创建一个delete分支，在hello.txt中添加一行内容<code>delete branch</code>，然后进行一个commit</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b delete</span><br><span class="line">git add hello.txt</span><br><span class="line">git commit -m &#39;update delete branch&#39;</span><br></pre></td></tr></table></figure>
<p>然后切回master分支，删除delete分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git branch -d delete</span><br></pre></td></tr></table></figure>
<p>输出了一个error：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error: The branch &#39;delete&#39; is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run &#39;git branch -D delete&#39;.</span><br></pre></td></tr></table></figure>
<p>git告诉你这个分支没被合并，如果确定要删除，使用<code>git branch -D delete</code>。</p>
<p>执行<code>git branch -D delete</code>，成功删除。</p>
<p>这个操作通常用来删除做到一半后面计划不做了的功能分支。</p>
<h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><p>场景：从工作区撤销</p>
<p>你在hello.txt中写下了新的一行：<code>I prefer svn</code><br>这时候你还没执行<code>git add</code><br>输入<code>git status</code>，会发现有个提示，<code>(use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</code></p>
<p>于是按照提示，执行<code>git checkout -- hello.txt</code><br>再回去hello.txt看看，新增的那句话已经被撤销了。</p>
<p>实际上，<code>git checkout</code>所做的，就是把工作区的修改替换成暂存区的。</p>
<hr>
<p>场景：从暂存区撤销到工作区</p>
<p>你在hello.txt中写下了新的一行：<code>I prefer svn</code><br>执行了<code>git add hello.txt</code>，把修改添加到暂存区<br>这时候git会提示你，<code>(use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</code></p>
<p>说得很清楚了，于是我们执行<code>git reset HEAD hello.txt</code></p>
<p>再执行<code>git status</code>查看，发现修改又回到了工作区。</p>
<hr>
<p>场景：从repo中撤销</p>
<p>……，，，遇到这种情况，看接下来的 回退 吧</p>
<h2 id="回退"><a href="#回退" class="headerlink" title="回退"></a>回退</h2><p>概念：git中有个HEAD指针，指向当前分支的当前版本，当我们进行回退操作时，其实就是改变HEAD指针，使其指向不同的commit节点。</p>
<p>理解了这个概念，就知道，既然是移动HEAD指针，那我们就可以在任意commit节点间进行跳转，无论是之前的版本，还是回退到之前版本后，想要回到未来的版本，只要知道commit的id就可以跳转版本。</p>
<p>使用<code>git reset HEAD --hard &lt;commit_id&gt;</code>来回退。</p>
<p>类似<code>10fb7e42c63586db6948f7a9221bafb32f19409d</code>这样的就是一个commit id，也可以输入前面几位，只要跟其他id有区别就行，如<code>10fb7e4</code></p>
<p>commit_id可以使用<code>git reflog</code>来查看。（使用<code>git log</code>不能看到回退后未来的commit id）</p>
<h1 id="多人合作"><a href="#多人合作" class="headerlink" title="多人合作"></a>多人合作</h1><p>看到这里，清楚了git的基本操作，包括分支与解决冲突，单人玩git应该可以了，那么多人合作，其实是类似的，处理好分支与冲突的解决，多人合作也是没问题的。</p>
<h1 id="远程repo"><a href="#远程repo" class="headerlink" title="远程repo"></a>远程repo</h1><p>github是目前流行的远程repo之一。具体使用就不细说了。<br>当对本地repo进行了修改，用<code>git push</code>命令推送到远程repo就行了，包括分支的改动。</p>
<p>如果别人对远程的repo进行了修改，或者自己在另一台电脑上进行之前的项目，用<code>git pull</code>拉取下来就行，这个过程中也可能遇到冲突。</p>
<h1 id="几个命令"><a href="#几个命令" class="headerlink" title="几个命令"></a>几个命令</h1><p><code>git init</code> 初始化repo</p>
<p><code>git status</code> 列出未被添加到暂存区与未被提交到repo的修改(经常使用这个命令，对文件的修改以及提交情况会比较清楚)</p>
<p><code>git add &lt;file&gt;</code> 添加修改到暂存区</p>
<p><code>git commit -m &#39;&lt;msg&gt;&#39;</code> 提交修改到repo，并附上说明</p>
<p><code>git push</code> 推送到远程仓库</p>
<p><code>git pull</code> 从远程仓库拉取更新，并与本地对应分支合并</p>
<p><code>git branch</code> 查看本地分支</p>
<p><code>git branch -a</code> 查看远程分支</p>
<p><code>git branch &lt;branch_name&gt;</code> 创建分支</p>
<p><code>git checkout &lt;branch_name&gt;</code> 切换分支</p>
<p><code>git checkout -b &lt;branch_name&gt;</code> 新建并切换分支</p>
<p><code>git merge</code> 合并分支</p>
<p><code>git stash</code> 保存工作区工作现场</p>
<p><code>git stash list</code> 查看stash</p>
<p><code>git stash pop</code> 恢复最后一个stash并删除stash数据</p>
<p><code>git stash apply &lt;stash&gt;</code> 恢复指定stash</p>
<p><code>git stash drop &lt;stash&gt;</code> 删除指定stash</p>
<p><code>git rm &lt;file&gt;</code> 将文件从工作区删除</p>
<p><code>git branch -d &lt;branch_name&gt;</code> 删除分支</p>
<p><code>git branch -D &lt;branch_name&gt;</code> 强制删除未合并分支</p>
<p><code>git checkout -- &lt;file&gt;</code> 把修改从工作区撤销</p>
<p><code>git reset HEAD &lt;file&gt;</code> 把修改从暂存区撤销到工作区</p>
<p><code>git reset HEAD --hard &lt;commit_id&gt;</code> repo版本回退到某个commit</p>
<p><code>git log</code> 查看commit历史</p>
<p><code>git reflog</code> 查看每个操作的log</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">Git教程 - 廖雪峰的官方网站</a></li>
</ul>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>使用git fetch和git rebase处理多人开发同一分支的问题</title>
    <url>/2017/07/24/git-fetch-and-rebase/</url>
    <content><![CDATA[<h1 id="情景"><a href="#情景" class="headerlink" title="情景"></a>情景</h1><p>有的时候会遇到这种问题，比如说有两个人，在同一个分支进行开发，假设是我自己，跟我的同伴；现在，我写了一部分代码，准备push到远程了，于是我执行git add、git commit，一切ok，没问题，然后git push，这下问题来了，git告诉我说我的push被rejected了，原来，我的同伴在我执行push之前，已经push了若干个commit到远程，因此我不能直接push，而是需要先把他的commits拉到我本地的repo才行。git的提示如下图。</p>
<p><img src="http://img.blog.csdn.net/20170726171432119?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYXp1cmV0ZXJuaXRl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="push rejected"></p>
<h1 id="按照git的提示做"><a href="#按照git的提示做" class="headerlink" title="按照git的提示做"></a>按照git的提示做</h1><p>好，git的提示已经很清楚了，rejected的原因通常是远程有了另外的push，询问了同伴，我们知道，就是ta先进行了push。那么，根据git的提示，我们可能想要先把远程的改变进行整合，再来push。那怎么整合呢，rejected那行告诉我们，要“fetch first”，而下面的e.g.说，我们可以用git pull来整合。也就是说，我们可以用git fetch，也可以用git pull来整合远程的改变到我们本地仓库中。</p>
<h1 id="使用git-pull"><a href="#使用git-pull" class="headerlink" title="使用git pull"></a>使用git pull</h1><p>由于我本人对fetch不太了解，看着pull好像跟push是反义词比较亲切，那就用它吧。于是我执行了git pull，然后git push。emmmm，好像没什么问题，但是…在source tree里面看着分支的图谱怎么怪怪的？</p>
<p><img src="http://img.blog.csdn.net/20170726171828164?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYXp1cmV0ZXJuaXRl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="git fetch"></p>
<p>图谱里面显示，我提交了两个commit，但实际上我改动的地方只进行了一次提交。我们看看多出来的commit的描述，写着“Merge branch ‘master’ of github.com:ChuChencheng/test”。</p>
<p>嗯？意思是这个提交做的改动是把远端的master分支进行合并。</p>
<h1 id="git-pull动的手脚"><a href="#git-pull动的手脚" class="headerlink" title="git pull动的手脚"></a>git pull动的手脚</h1><p>Google了一番git pull，发现git pull做的事情其实相当于git fetch跟git merge，那，我之前一直没用到的git fetch做的事情是什么呢？</p>
<p>git fetch这个命令会把远程的commits拉取到本地的repo中，但是，它不是直接把commits接在分支的最后面，而是从你最后一次push的那个commit节点，再拉取一个新的分支出来，类似这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   * git fetch拉下来的节点，建立在一个新的分支上</span><br><span class="line">* &#x2F;  你还没push的节点</span><br><span class="line">|&#x2F;</span><br><span class="line">* 你最后一次push的节点</span><br><span class="line">|</span><br><span class="line">*</span><br></pre></td></tr></table></figure>
<p>那merge呢？git pull在拉取完之后，就会将新建的分支跟你原来的分支进行合并，所以图就变成了这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*  新建的分支merge进原本的分支，这个节点就是merge xxx那个多出来的节点</span><br><span class="line">| \</span><br><span class="line">|  * git fetch拉下来的节点，建立在一个新的分支上</span><br><span class="line">* &#x2F;  你还没push的节点</span><br><span class="line">|&#x2F;</span><br><span class="line">* 你最后一次push的节点</span><br><span class="line">|</span><br><span class="line">*</span><br></pre></td></tr></table></figure>
<h1 id="那怎么办？"><a href="#那怎么办？" class="headerlink" title="那怎么办？"></a>那怎么办？</h1><p>现在，我们知道了，这种情况下执行git pull，分支的图谱就会变得很难看，但又必须把远程的commits拉取下来，那有没有办法让分支图谱保持一条直线而不分叉呢？</p>
<p>这个时候，我们还需要一个以前也很少用（我真的很菜）的命令，git rebase。</p>
<p>git rebase的作用是，把一个分支的修改合并到另一个分支。听起来有点熟悉？没错，它跟merge的功能有点像。不同的是，merge的做法比较粗暴，直接把两个分支再各自拉出一条线，连在一起就完了；而rebase则比较细心，它会把当前分支跟你要合并的分支中不同的commits取消掉，临时保存起来，然后在要合并的分支中再把保存起来的commits patch上去，变成新的commits，当然，commitId也是新的，这样，最后的效果就是只剩合并后的分支，而且是一条直线，没有分叉，没有“Merge branch xxx of xxx”这种多余的提交。</p>
<p><img src="http://img.blog.csdn.net/20170726171905927?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYXp1cmV0ZXJuaXRl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="git rebase"></p>
<h1 id="具体做法"><a href="#具体做法" class="headerlink" title="具体做法"></a>具体做法</h1><p>知道了是什么，为什么，最后就是怎么做了。</p>
<p>步骤如下：</p>
<ol>
<li>git fetch</li>
<li>git rebase</li>
<li>解决冲突</li>
<li>git add 冲突文件</li>
<li>git rebase –continue</li>
<li>git push</li>
</ol>
<p>其中，3、4、5点，如果没遇到冲突就不用进行，直接push上去。</p>
<p>当遇到冲突时，git会提示patch failed，并要我们解决问题了再执行<code>git rebase --continue</code></p>
<p><img src="http://img.blog.csdn.net/20170726172143711?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYXp1cmV0ZXJuaXRl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="git rebase patch failed"></p>
<p>此时的图谱：</p>
<p><img src="http://img.blog.csdn.net/20170726172213448?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYXp1cmV0ZXJuaXRl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="rebase meets conflict"></p>
<p>解决冲突后，通过<code>git status</code>可以看到rebase in progress，也就是说现在还是在rebase的过程中：</p>
<p><img src="http://img.blog.csdn.net/20170726172429306?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYXp1cmV0ZXJuaXRl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="rebase in progress"></p>
<p>然后我们把解决后的冲突文件add进来，并执行<code>git rebase --continue</code>继续patch（也可以执行–skip跳过这个patch，或–abort放弃rebase），可以看到分支是清晰的一条直线：</p>
<p><img src="http://img.blog.csdn.net/20170726172703505?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYXp1cmV0ZXJuaXRl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="conflict solved"></p>
<p>最后push，完成。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>iview树组件源码阅读笔记</title>
    <url>/2017/09/08/iview%E6%A0%91%E7%BB%84%E4%BB%B6%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>好久没有记一些东西了，本菜鸡又来水文章了。</p>
<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><ul>
<li><p>iview里面的树组件思路跟vue官网上的<a href="https://cn.vuejs.org/v2/examples/tree-view.html">树形视图</a>示例类似，应用了组件的递归使用（好像是废话</p>
</li>
<li><p>整个树组件里有两个vue文件，一个是递归使用的node.vue，一个是父组件tree.vue</p>
</li>
<li><p>组件内的事件大致分为三种：expand（展开）、select（点击节点title触发）和check（复选框的选中与取消触发）</p>
</li>
</ul>
<h1 id="node-vue"><a href="#node-vue" class="headerlink" title="node.vue"></a>node.vue</h1><p>这个组件内包括树组件的一个选项，以及它的children（如果有）</p>
<h2 id="template"><a href="#template" class="headerlink" title="template"></a>template</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;collapse-transition&gt;</span><br><span class="line">        &lt;ul :class&#x3D;&quot;classes&quot; v-show&#x3D;&quot;visible&quot;&gt;</span><br><span class="line">            &lt;li&gt;</span><br><span class="line">                &lt;span :class&#x3D;&quot;arrowClasses&quot; @click&#x3D;&quot;handleExpand&quot;&gt;</span><br><span class="line">                    &lt;Icon type&#x3D;&quot;arrow-right-b&quot;&gt;&lt;&#x2F;Icon&gt;</span><br><span class="line">                &lt;&#x2F;span&gt;</span><br><span class="line">                &lt;Checkbox</span><br><span class="line">                        v-if&#x3D;&quot;showCheckbox&quot;</span><br><span class="line">                        :value&#x3D;&quot;data.checked&quot;</span><br><span class="line">                        :indeterminate&#x3D;&quot;indeterminate&quot;</span><br><span class="line">                        :disabled&#x3D;&quot;data.disabled || data.disableCheckbox&quot;</span><br><span class="line">                        @click.native.prevent&#x3D;&quot;handleCheck&quot;&gt;&lt;&#x2F;Checkbox&gt;</span><br><span class="line">                &lt;span :class&#x3D;&quot;titleClasses&quot; v-html&#x3D;&quot;data.title&quot; @click&#x3D;&quot;handleSelect&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">                &lt;Tree-node</span><br><span class="line">                        v-for&#x3D;&quot;item in data.children&quot;</span><br><span class="line">                        :key&#x3D;&quot;item.nodeKey&quot;</span><br><span class="line">                        :data&#x3D;&quot;item&quot;</span><br><span class="line">                        :visible&#x3D;&quot;data.expand&quot;</span><br><span class="line">                        :multiple&#x3D;&quot;multiple&quot;</span><br><span class="line">                        :show-checkbox&#x3D;&quot;showCheckbox&quot;&gt;</span><br><span class="line">                &lt;&#x2F;Tree-node&gt;</span><br><span class="line">            &lt;&#x2F;li&gt;</span><br><span class="line">        &lt;&#x2F;ul&gt;</span><br><span class="line">    &lt;&#x2F;collapse-transition&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<p><code>collapse-transition</code>应该是父节点展开收起的动画效果，<code>ul</code>则是包括一个父节点，里面的<code>tree-node</code>是这个父节点的所有子节点，通过<code>v-for</code>循环渲染出来，而其子节点的每一项跟父节点是一样的结构，所以<code>tree-node</code>实际上就是<code>node.vue</code>组件本身。</p>
<p>然后是<strong>script部分</strong></p>
<h2 id="主要props"><a href="#主要props" class="headerlink" title="主要props"></a>主要props</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        type: <span class="built_in">Object</span>,</span><br><span class="line">        <span class="keyword">default</span> () &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    multiple: &#123;</span><br><span class="line">        type: <span class="built_in">Boolean</span>,</span><br><span class="line">        <span class="keyword">default</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    showCheckbox: &#123;</span><br><span class="line">        type: <span class="built_in">Boolean</span>,</span><br><span class="line">        <span class="keyword">default</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    visible: &#123;</span><br><span class="line">        type: <span class="built_in">Boolean</span>,</span><br><span class="line">        <span class="keyword">default</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<ul>
<li>data: 树的数据，根据template中的<code>v-for=&quot;item in data.children&quot;</code>和<code>:data=&quot;item&quot;</code>可以知道每个节点的data都是当前节点的信息包括所有的子节点，简化的数据结构如下</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  title: <span class="string">&#x27;父节点&#x27;</span>,</span><br><span class="line">  children: [&#123;</span><br><span class="line">    title: <span class="string">&#x27;子节点1&#x27;</span>,</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    title: <span class="string">&#x27;子节点2&#x27;</span>,</span><br><span class="line">    children: [&#123;</span><br><span class="line">      title: <span class="string">&#x27;子节点2的子节点&#x27;</span>,</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>methods</code>中，又对data追加声明了4个额外的属性：selected、disabled、expand、checked，具体是干嘛的看名字应该很清楚了</p>
<ul>
<li><p>multiple: 控制多选的布尔值，默认false，这是控制能否select多个节点的值，而不是控制能不能check多个复选框的值</p>
</li>
<li><p>其他props，showCheckbox、visible字面意思都能看出来，不多说</p>
</li>
</ul>
<h2 id="data"><a href="#data" class="headerlink" title="data"></a>data</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        prefixCls: prefixCls,</span><br><span class="line">        indeterminate: <span class="literal">false</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<ul>
<li><p>prefixCls：控制class前缀的，主要用于样式</p>
</li>
<li><p>indeterminate：对应checkbox的indeterminate状态</p>
</li>
</ul>
<h2 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h2><p>computed中返回的都是跟class相关的值，应用样式的，就不说了。</p>
<h2 id="created-amp-mounted"><a href="#created-amp-mounted" class="headerlink" title="created &amp; mounted"></a><span id="node.vue-created&mounted">created &amp; mounted</span></h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">created () &#123;</span><br><span class="line">    <span class="comment">// created node.vue first, mounted tree.vue second</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.data.checked) <span class="built_in">this</span>.$set(<span class="built_in">this</span>.data, <span class="string">&#x27;checked&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;,</span><br><span class="line">mounted () &#123;</span><br><span class="line">    <span class="built_in">this</span>.$on(<span class="string">&#x27;indeterminate&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.broadcast(<span class="string">&#x27;TreeNode&#x27;</span>, <span class="string">&#x27;indeterminate&#x27;</span>);</span><br><span class="line">        <span class="built_in">this</span>.setIndeterminate();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在created阶段定义了data props的checked属性<br><br>在mounted阶段监听了indeterminate事件，并广播该事件到所有的子节点中</p>
<h2 id="methods"><a href="#methods" class="headerlink" title="methods"></a><span id="node.vue-methods">methods</span></h2><p>methods中主要处理一些事件，在template中可以看到用<code>v-on</code>绑定了三个click事件</p>
<ul>
<li><code>handleExpand</code>： 处理树展开收起</li>
<li><code>handleCheck</code>：  处理checkbox勾选</li>
<li><code>handleSelect</code>： 处理选项选中/取消选中</li>
</ul>
<h3 id="handleExpand"><a href="#handleExpand" class="headerlink" title="handleExpand"></a>handleExpand</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">handleExpand () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.data.disabled) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">this</span>.$set(<span class="built_in">this</span>.data, <span class="string">&#x27;expand&#x27;</span>, !<span class="built_in">this</span>.data.expand);</span><br><span class="line">    <span class="built_in">this</span>.dispatch(<span class="string">&#x27;Tree&#x27;</span>, <span class="string">&#x27;toggle-expand&#x27;</span>, <span class="built_in">this</span>.data);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>处理展开收起只做了三个微小的工作：</p>
<ol>
<li>判断节点是否被禁用</li>
<li>设置<code>this.data.expand</code>值，取反</li>
<li>在父组件Tree上触发<code>toggle-expand</code>事件</li>
</ol>
<h3 id="handleCheck"><a href="#handleCheck" class="headerlink" title="handleCheck"></a>handleCheck</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">handleCheck () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.disabled) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">const</span> checked = !<span class="built_in">this</span>.data.checked;</span><br><span class="line">    <span class="keyword">if</span> (!checked || <span class="built_in">this</span>.indeterminate) &#123;</span><br><span class="line">        findComponentsDownward(<span class="built_in">this</span>, <span class="string">&#x27;TreeNode&#x27;</span>).forEach(<span class="function"><span class="params">node</span> =&gt;</span> node.data.checked = <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        findComponentsDownward(<span class="built_in">this</span>, <span class="string">&#x27;TreeNode&#x27;</span>).forEach(<span class="function"><span class="params">node</span> =&gt;</span> node.data.checked = <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.data.checked = checked;</span><br><span class="line">    <span class="built_in">this</span>.dispatch(<span class="string">&#x27;Tree&#x27;</span>, <span class="string">&#x27;checked&#x27;</span>);</span><br><span class="line">    <span class="built_in">this</span>.dispatch(<span class="string">&#x27;Tree&#x27;</span>, <span class="string">&#x27;on-checked&#x27;</span>);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>处理check事件：</p>
<ol>
<li>判断是否禁用（这边好像写错了？并没有找到this.disabled，怀疑是this.data.disabled</li>
<li><code>const checked</code>取点击后<code>this.data.checked</code>的值</li>
<li>如果<code>checked</code>为<code>false</code>，或者checkbox的状态是indeterminate，则将子节点全部取消勾选；否则将子节点全部勾选</li>
<li>修改<code>this.data.checked</code>为最新的值（因为在点击进入这个事件处理函数时，checkbox的状态还是未改变的状态，所以这边手动修改了<code>this.data.checked</code>的值）</li>
<li>在父组件Tree上触发<code>checked</code>和<code>on-checked</code>两个事件</li>
</ol>
<h3 id="handleSelect"><a href="#handleSelect" class="headerlink" title="handleSelect"></a><span id="node.vue-handleSelect">handleSelect</span></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">handleSelect () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.data.disabled) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.data.selected) &#123;</span><br><span class="line">        <span class="built_in">this</span>.data.selected = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.multiple) &#123;</span><br><span class="line">        <span class="built_in">this</span>.$set(<span class="built_in">this</span>.data, <span class="string">&#x27;selected&#x27;</span>, !<span class="built_in">this</span>.data.selected);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dispatch(<span class="string">&#x27;Tree&#x27;</span>, <span class="string">&#x27;selected&#x27;</span>, <span class="built_in">this</span>.data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.dispatch(<span class="string">&#x27;Tree&#x27;</span>, <span class="string">&#x27;on-selected&#x27;</span>);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>处理select事件：</p>
<ol>
<li>判断是否禁用</li>
<li>当节点是选中时，改为非选中；否则判断是否多选，如果是，则将节点自身改为选中；否则在父组件Tree上触发<code>selected</code>事件（父组件中会把所有节点的<code>selected</code>改为<code>false</code>，并把当前节点的<code>selected</code>改为<code>true</code>）</li>
<li>最后在父组件Tree上触发<code>on-selected</code>事件</li>
</ol>
<p><strong>node.vue相关的废话就说到这边</strong></p>
<hr>
<p>强势的分割线</p>
<hr>
<h1 id="tree-vue"><a href="#tree-vue" class="headerlink" title="tree.vue"></a>tree.vue</h1><p>Tree组件主要的作用是给Node组件加个外壳，不想写太多废话了，主要讲讲mounted跟watch吧。</p>
<h2 id="template-1"><a href="#template-1" class="headerlink" title="template"></a>template</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div :class&#x3D;&quot;prefixCls&quot;&gt;</span><br><span class="line">        &lt;Tree-node</span><br><span class="line">            v-for&#x3D;&quot;item in data&quot;</span><br><span class="line">            :key&#x3D;&quot;item.nodeKey&quot;</span><br><span class="line">            :data&#x3D;&quot;item&quot;</span><br><span class="line">            visible</span><br><span class="line">            :multiple&#x3D;&quot;multiple&quot;</span><br><span class="line">            :show-checkbox&#x3D;&quot;showCheckbox&quot;&gt;</span><br><span class="line">        &lt;&#x2F;Tree-node&gt;</span><br><span class="line">        &lt;div :class&#x3D;&quot;[prefixCls + &#39;-empty&#39;]&quot; v-if&#x3D;&quot;!data.length&quot;&gt;&#123;&#123; localeEmptyText &#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<p>tree.vue的结构比较简单，主要的工作就是把树的最外层渲染出来，然后每个<code>Tree-node</code>组件内会递归渲染各自的子节点</p>
<h2 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mounted () &#123;</span><br><span class="line">    <span class="built_in">this</span>.updateData();</span><br><span class="line">    <span class="built_in">this</span>.$on(<span class="string">&#x27;selected&#x27;</span>, <span class="function"><span class="params">ori</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> nodes = findComponentsDownward(<span class="built_in">this</span>, <span class="string">&#x27;TreeNode&#x27;</span>);</span><br><span class="line">        nodes.forEach(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.$set(node.data, <span class="string">&#x27;selected&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">this</span>.$set(ori, <span class="string">&#x27;selected&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">this</span>.$on(<span class="string">&#x27;on-selected&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.$emit(<span class="string">&#x27;on-select-change&#x27;</span>, <span class="built_in">this</span>.getSelectedNodes());</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">this</span>.$on(<span class="string">&#x27;checked&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.updateData(<span class="literal">false</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">this</span>.$on(<span class="string">&#x27;on-checked&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.$emit(<span class="string">&#x27;on-check-change&#x27;</span>, <span class="built_in">this</span>.getCheckedNodes());</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">this</span>.$on(<span class="string">&#x27;toggle-expand&#x27;</span>, <span class="function">(<span class="params">payload</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.$emit(<span class="string">&#x27;on-toggle-expand&#x27;</span>, payload);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>mounted中主要是监听Node组件中在Tree触发的各种事件（参见<a href="#node.vue-methods">node.vue methods</a>）</p>
<p>那些往外部触发事件的就不说了，来看看<code>selected</code>事件的处理函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$on(<span class="string">&#x27;selected&#x27;</span>, <span class="function"><span class="params">ori</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> nodes = findComponentsDownward(<span class="built_in">this</span>, <span class="string">&#x27;TreeNode&#x27;</span>);</span><br><span class="line">    nodes.forEach(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.$set(node.data, <span class="string">&#x27;selected&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">this</span>.$set(ori, <span class="string">&#x27;selected&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ol>
<li>首先找到所有的TreeNode子组件（包括子组件的子组件，也就是无论是迭代几层都包括在里面）</li>
<li>遍历子组件，将子组件的<code>data.selected</code>都改为<code>false</code></li>
<li>将触发事件的组件的<code>data.selected</code>改为<code>true</code></li>
</ol>
<p>结合node.vue中的<a href="#node.vue-handleSelect">handleSelect</a>，就不难理解select功能的工作原理了。</p>
<h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">        <span class="built_in">this</span>.$nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.updateData();</span><br><span class="line">            <span class="built_in">this</span>.broadcast(<span class="string">&#x27;TreeNode&#x27;</span>, <span class="string">&#x27;indeterminate&#x27;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>watch中监听了data的变化。当data变化时，在DOM更新完成后，执行<code>updateData</code>方法更新数据，并broadcast一个<code>indeterminate</code>事件。<br>结合<a href="#node.vue-created&mounted">node.vue mounted</a>，在监听到<code>indeterminate</code>事件后，也向下broadcast了该事件，保证所有子节点都能接收到该事件的触发，并执行相应方法。</p>
<p><strong>tree.vue就讲到这里吧。</strong></p>
<h1 id="用到的utils-amp-mixins"><a href="#用到的utils-amp-mixins" class="headerlink" title="用到的utils &amp; mixins"></a>用到的utils &amp; mixins</h1><p>先留个坑，会解释dispatch和broadcast，还有 findComponentsDownward 是怎么回事。</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>iview</tag>
      </tags>
  </entry>
  <entry>
    <title>iview clickoutside指令</title>
    <url>/2017/09/18/iview-clickoutside-directive/</url>
    <content><![CDATA[<h1 id="clickoutside指令介绍"><a href="#clickoutside指令介绍" class="headerlink" title="clickoutside指令介绍"></a>clickoutside指令介绍</h1><p>iview里面有个clickoutside指令，用来处理点击元素外面的事件。</p>
<p>比如在cascader组件里的最外层div就用到了该指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div :class&#x3D;&quot;classes&quot; v-clickoutside&#x3D;&quot;handleClose&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>当用户点击了这个元素的外面，就会执行传到指令中的<code>handleClose</code>函数。</p>
<h1 id="clickoutside指令原理"><a href="#clickoutside指令原理" class="headerlink" title="clickoutside指令原理"></a>clickoutside指令原理</h1><p>首先来看一下该指令的源码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    bind (el, binding, vnode) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">documentHandler</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (el.contains(e.target)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binding.expression) &#123;</span><br><span class="line">                binding.value(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        el.__vueClickOutside__ = documentHandler;</span><br><span class="line">        <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;click&#x27;</span>, documentHandler);</span><br><span class="line">    &#125;,</span><br><span class="line">    update () &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    unbind (el, binding) &#123;</span><br><span class="line">        <span class="built_in">document</span>.removeEventListener(<span class="string">&#x27;click&#x27;</span>, el.__vueClickOutside__);</span><br><span class="line">        <span class="keyword">delete</span> el.__vueClickOutside__;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>定义了bind和unbind两个钩子函数。</p>
<p>有关Vue自定义指令钩子函数的知识参照<a href="https://cn.vuejs.org/v2/guide/custom-directive.html">官方文档</a></p>
<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p>在bind函数中，给使用了该指令的元素添加了一个<code>__vueClickOutside__</code>属性。</p>
<p>然后在document上绑定了一个click事件，<code>documentHandler</code>。</p>
<p>该handler做了两件事：</p>
<ol>
<li>判断使用指令的元素中是否包含当前被点击的元素，如果是，说明用户点击的是元素里面，则return false停止事件冒泡</li>
<li>判断使用指令的元素是否有绑定值，若有，则调用绑定的函数。</li>
</ol>
<p>需要注意的是，绑定的值必须是一个函数，例如，上述cascader组件中的<code>handleClose</code>就必须是一个函数</p>
<p>因为<code>binding.value(e)</code>在此例中就相当于<code>handleClose(e)</code>（<code>binding.value</code>为指令的绑定值，在这里绑定了handleClose这个值）</p>
<h2 id="unbind"><a href="#unbind" class="headerlink" title="unbind"></a>unbind</h2><p>解绑，两个操作</p>
<ol>
<li>移除监听器，在bind中定义的<code>el.__vueClickOutside__</code>在这里作为removeEventListener的listener参数</li>
<li>删除元素上的<code>__vueClickOutside__</code>属性</li>
</ol>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>iview</tag>
      </tags>
  </entry>
  <entry>
    <title>iview级联选择组件源码阅读笔记</title>
    <url>/2017/09/18/iview%E7%BA%A7%E8%81%94%E9%80%89%E6%8B%A9%E7%BB%84%E4%BB%B6%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="组件划分"><a href="#组件划分" class="headerlink" title="组件划分"></a>组件划分</h1><p>cascader组件共划分成了三个组件：</p>
<ul>
<li>cascader.vue</li>
<li>caspanel.vue</li>
<li>casitem.vue</li>
</ul>
<p>其中，cascader是最外层的组件，包括一个slot和caspanel。slot内部默认是一个input框。</p>
<p>caspanel则是弹出的面板，里面包括若干个casitem选项，和一个子caspanel面板（如果有）。</p>
<p>casitem则是简单的选项组件，存放选项。</p>
<h1 id="DOM结构"><a href="#DOM结构" class="headerlink" title="DOM结构"></a>DOM结构</h1><p>大致的DOM结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Cascader&gt;</span><br><span class="line">  &lt;Input&gt;</span><br><span class="line">  &lt;Caspanel&gt;</span><br><span class="line">    &lt;Caspanel&gt;</span><br><span class="line">    &lt;Casitem&gt;</span><br></pre></td></tr></table></figure>
<h1 id="逻辑思路"><a href="#逻辑思路" class="headerlink" title="逻辑思路"></a>逻辑思路</h1><p>在页面渲染时，通过computed中的<code>querySelections</code>方法对data进行遍历修改，添加<code>__label</code> <code>__value</code>属性</p>
<p>在点击slot中的内容时，调用<code>toggleOpen</code>方法，修改<code>visible</code>属性控制<code>Caspanel</code>的显隐：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下三个函数用于控制this.visible，由此控制panel的显隐</span></span><br><span class="line">handleClose () &#123;</span><br><span class="line">    <span class="built_in">this</span>.visible = <span class="literal">false</span>;</span><br><span class="line">&#125;,</span><br><span class="line">toggleOpen () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.disabled) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.visible) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.filterable) <span class="built_in">this</span>.handleClose();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.onFocus();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">onFocus () &#123;</span><br><span class="line">    <span class="built_in">this</span>.visible = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.currentValue.length) &#123;</span><br><span class="line">        <span class="built_in">this</span>.broadcast(<span class="string">&#x27;Caspanel&#x27;</span>, <span class="string">&#x27;on-clear&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>然后在watch中监听<code>visible</code>属性的变化，当input中有值时，更新面板的内容，使面板展示选中的项：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">visible (val) &#123;</span><br><span class="line">    <span class="keyword">if</span> (val) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.currentValue.length) &#123;</span><br><span class="line">            <span class="built_in">this</span>.updateSelected();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.transfer) &#123;</span><br><span class="line">            <span class="built_in">this</span>.$refs.drop.update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.filterable) &#123;</span><br><span class="line">            <span class="built_in">this</span>.query = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            <span class="built_in">this</span>.$refs.input.currentValue = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.transfer) &#123;</span><br><span class="line">            <span class="built_in">this</span>.$refs.drop.destroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.$emit(<span class="string">&#x27;on-visible-change&#x27;</span>, val);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">updateSelected (init = <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.changeOnSelect || init) &#123;</span><br><span class="line">        <span class="built_in">this</span>.broadcast(<span class="string">&#x27;Caspanel&#x27;</span>, <span class="string">&#x27;on-find-selected&#x27;</span>, &#123;</span><br><span class="line">            value: <span class="built_in">this</span>.currentValue</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>在<code>updateSelected</code>中，会广播<code>on-find-selected</code>事件，在处理该事件的函数中，还会触发<code>on-clear</code>事件，将<code>Caspanel</code>的子面板都清空，然后再渲染新的子面板（展示选中的项），并设置选中的value。</p>
<p>当用户点击最后要选择的选项时，<code>Caspanel</code>组件会调用一个方法先改变父组件<code>Cascader</code>的<code>this.tmpSelected</code>，然后触发<code>on-result-change</code>事件，驱使父组件更新<code>this.selected</code>和<code>this.currentValue</code>，从而更新DOM。</p>
<p><strong>疑惑：</strong></p>
<p>在<code>Caspanel</code>组件中，使用了<code>this.$parent</code>来调用父组件<code>Cascader</code>的方法，甚至用到了<code>this.$parent.$parent</code>，在其他组件中有看到直接通过<code>this.$parent</code>修改父组件中的属性值，不知这种方式与通过事件来通知父组件从而改变父组件中的属性，哪种更合适一些。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">emitUpdate (result) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.$parent.$options.name === <span class="string">&#x27;Caspanel&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.$parent.updateResult(result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.$parent.$parent.updateResult(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>iview</tag>
      </tags>
  </entry>
  <entry>
    <title>在浏览器中模拟WebSocket行为</title>
    <url>/2018/05/18/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E6%A8%A1%E6%8B%9FWebSocket%E8%A1%8C%E4%B8%BA/</url>
    <content><![CDATA[<p>先挂上项目链接：<a href="https://github.com/ChuChencheng/wsmock-js">wsmock-js</a></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在一个前端项目开发过程中若用到了 ajax ，可以使用 <a href="https://github.com/jakerella/jquery-mockjax">jquery-mockjax</a> 、<a href="https://github.com/angrytoro/mockajax">mockajax</a> 等库来拦截 ajax 请求，并模拟服务器返回一份自定义的模拟数据给浏览器。这个过程没有发起网络请求，却模拟了 ajax 过程的行为，定义好模拟数据后，只要照常使用 ajax 即可，基本覆盖了日常使用 ajax 的需要。</p>
<p>那么，同样的思路，在开发过程中如果用到了 WebSocket ，也可以设法拦截 WebSocket 请求，并返回事先定义好的模拟数据，从而不用等待后端开发完成再来进行调试。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>要拦截 WebSocket 请求，我首先得到的思路有</p>
<ol>
<li>通过浏览器插件拦截网络请求，并返回对应模拟数据 （未探索）</li>
<li>重写进行 WebSocket 连接与数据交换的方法 （阅读上述两个 mock ajax 库源码了解的思路）</li>
</ol>
<p>退一步说，还可以搭设一个本地服务器，在开发时将请求 URL 都指向本地，进行真实的 WebSocket 流程，不过这样不太符合上述背景中 “照常使用” 的要求， URL 需要在本地跟实际 URL 中切换。</p>
<p>另外能想到的是在系统层面做手脚，这个没考虑得这么多。</p>
<p>本文按照上述第 2 点思路进行开发。</p>
<h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>重写一个方法，也就是说将原来的方法进行了覆盖，这样，用户后面调用的都将是重写后的方法而不是原来的方法。</p>
<p>这么做的优点有：</p>
<ol>
<li>可定制。可以对原来的方法进行改造，比如加个钩子啥的，例如 Vue 对 Array 方法的重写 （但这里并没有真的覆盖原生方法，具体看 Vue 源码）</li>
<li>可扩展。跟第一点有点类似，可以对重写的方法加入新的方法、功能等。</li>
</ol>
<p>但是重写方法也是有挺明显的缺点的：</p>
<ol>
<li>需要实现原来的功能。重写的方法应该要在不影响本来的方法正常使用的情况下进行，让用户感受不到这个方法被重写过了 （这边也不一定就是了，看你要实现什么样的功能） ，这要求对原方法的实现有一定的了解，如果能直接继承或调用原方法是最好的。</li>
<li>对原方法的后续跟踪。基于第 1 点的考虑，原来的方法若后续进行了功能上的扩展或变更，重写的方法应该进行跟进。</li>
</ol>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>本项目的实现参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket">WebSocket MDN 文档</a> ，把里面的方法跟属性等基本重写了一遍。</p>
<h2 id="WebSocket-构造函数"><a href="#WebSocket-构造函数" class="headerlink" title="WebSocket 构造函数"></a>WebSocket 构造函数</h2><p><code>WebSocket</code> 构造函数接受两个参数，一个 <code>url</code> ，一个可选的 <code>protocols</code></p>
<p>由于一执行 <code>new WebSocket()</code> 就会进行 <code>url</code> 的检查并建立连接，而继承 <code>WebSocket</code> 必须执行 <code>super()</code> 方法，为了不发起连接，只能对整个 <code>WebSocket</code> 进行重写。</p>
<p>重写构造函数的大致流程是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存原生 WebSocket</span></span><br><span class="line"><span class="keyword">const</span> _WebSocket = <span class="built_in">window</span>.WebSocket</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写 WebSocket</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebSocket</span> <span class="keyword">extends</span> <span class="title">EventTarget</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">url, protocols</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (url <span class="keyword">in</span> mockSettingUrls) &#123; <span class="comment">// 如果定义了对于此 url 的模拟设置</span></span><br><span class="line">    <span class="comment">// 进入模拟 WebSocket 的流程</span></span><br><span class="line">    <span class="comment">// Mock code here...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 如果未对 url 定义模拟设置，则返回原生调用</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`No mock settings for &#x27;<span class="subst">$&#123;url&#125;</span>&#x27;, invoke native.`</span>)</span><br><span class="line">      <span class="keyword">return</span> _WebSocket(url, protocols)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：由于 <code>onopen</code>、<code>onmessage</code> 等事件的特殊性（重新定义后触发事件执行顺序不变）， <code>EventTarget</code> 需要一些自定义实现，此处参照 <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget#Example">MDN EventTarget 的简单实现</a> 进行了小的改造</p>
<h2 id="属性与常量"><a href="#属性与常量" class="headerlink" title="属性与常量"></a>属性与常量</h2><p>常量不用说，既然重写了整个 <code>WebSocket</code> ，直接把该定义的四个 <code>ReadyState</code> 常量再定义一遍就行。</p>
<p>至于属性，根据文档定义好默认值，在适当的时机进行变更。如果考虑到只读等这些特性，可以配合 <code>Object.defineProperty</code> 与 <code>descriptor</code> 使用实现。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><code>WebSocket</code> 浏览器端只有两个方法：</p>
<ul>
<li><code>send</code></li>
<li><code>close</code></li>
</ul>
<p>当然，在模拟的 <code>WebSocket</code> 中的 <code>send</code> 不会发出请求，而是执行在模拟数据设置中自定义的函数来模拟服务器接收到浏览器发出的信息后执行的函数。</p>
<h2 id="事件系统"><a href="#事件系统" class="headerlink" title="事件系统"></a>事件系统</h2><p>根据 MDN 文档中的描述， <code>WebSocket</code> 是继承于 <code>EventTarget</code> 的，因此可以使用事件系统中的 <code>addEventListener</code>, <code>removeEventListener</code>, <code>dispatchEvent </code> 这些方法。</p>
<p>而定义 <code>onopen</code>, <code>onmessage</code>, <code>onclose</code>, <code>onerror</code> 这些属性本质上是执行了 <code>addEventListener</code> 。但是重新赋值这些属性时，事件的执行顺序并不会改变，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">&#x27;wss://xxx.xxx.xxx&#x27;</span>)</span><br><span class="line">ws.onopen = <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>) &#125;</span><br><span class="line">ws.addEventListener(<span class="string">&#x27;open&#x27;</span>, <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>) &#125;)</span><br><span class="line">ws.onopen = <span class="function">() =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>就是说，onxxx 这些属性，在事件 handler 的哪个顺序定义，再次更改该属性时，它们还在那个位置，顺序不会变更。</p>
<p>因此这边实现了一个简易 <code>EventTarget</code> ，并添加了一些方法去实现上述特性。</p>
<h2 id="模拟设置的定义"><a href="#模拟设置的定义" class="headerlink" title="模拟设置的定义"></a>模拟设置的定义</h2><p>重写了 <code>WebSocket</code> ，接下来该考虑怎么实现模拟设置了，其本质上是在模拟服务器的行为，包括接收数据、返回数据或主动推送数据。</p>
<p>因此有三个主要因素：</p>
<ul>
<li>接收数据的 handler</li>
<li>发送数据的方法</li>
<li>发送数据的时机</li>
</ul>
<p>我们可以把设置定义为一个对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  url,</span><br><span class="line">  receiver,</span><br><span class="line">  sender,</span><br><span class="line">  sendInterval,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，根据 <code>url</code> 跟内部生成的 <code>id</code> 来标识唯一（ <code>url</code> 支持正则的话，一个模拟设置可以匹配到多个 <code>WebSocket</code> 连接；或者多次定义具有相同 <code>url</code> 的模拟设置。因此还需要 <code>id</code> 来区分）</p>
<p><code>receiver</code> 表示服务器接收数据的 handler ，模拟 <code>WebSocket</code> 每次执行 <code>send</code> 方法时，实际上还执行了这个方法，表示服务器接收到了浏览器的数据。</p>
<p><code>sender</code> 是从服务器发送数据到浏览器的方法，其在适当的时机执行，通过预先定义的 <code>eventBus</code> 触发一个内部事件，通知浏览器端的 <code>WebSocket</code> 接收到数据了，使其触发 <code>message</code> 事件。</p>
<p><code>sendInterval</code> 则定义了服务器发送数据的时机，根据使用 WebSocket 的场景来看，基本上有这些情况：</p>
<ul>
<li>服务器收到数据后马上发送数据</li>
<li>服务器隔一定时间发送数据</li>
</ul>
<p>因此这个字段可以是数字类型，或者一个特殊的字符串用来标识服务器收到数据后应马上发送数据。</p>
<p>其他发送时机差不多都是这两种情况的变种，可以在 <code>sender</code> 跟 <code>receiver</code> 中进行操控。</p>
<h2 id="其他细节"><a href="#其他细节" class="headerlink" title="其他细节"></a>其他细节</h2><ul>
<li>数据、参数的校验，例如 <code>url</code>, <code>send</code> 数据的格式校验等</li>
<li><code>bufferedAmount</code> 属性的计算</li>
<li>异常、错误的抛出（这里我参考 Chrome 的错误提示信息跟错误类型）</li>
</ul>
<h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p>最后的效果就是这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> wsm <span class="keyword">from</span> <span class="string">&#x27;wsmock-js&#x27;</span></span><br><span class="line"> </span><br><span class="line">wsm.mock(&#123;</span><br><span class="line">  url: <span class="string">&#x27;ws://echo.websocket.org&#x27;</span>,</span><br><span class="line">  sendInterval: <span class="string">&#x27;onreceive&#x27;</span>,</span><br><span class="line">  receiver (data) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">  &#125;,</span><br><span class="line">  sender () &#123;</span><br><span class="line">    <span class="built_in">this</span>.response = <span class="string">&#x27;This is a message sent by server.&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">&#x27;ws://echo.websocket.org&#x27;</span>)</span><br><span class="line">ws.onmessage = <span class="function">(<span class="params">evt</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(evt.data) &#125;</span><br><span class="line">ws.send(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// console output</span></span><br><span class="line"><span class="comment">// &quot;This is a message sent by server.&quot;</span></span><br></pre></td></tr></table></figure>
<p>你也可以通过 <code>npm</code> 或 <code>yarn</code> 安装 <code>wsmock-js</code> 后，运行 <code>npm start</code> ，打开网页控制台查看效果，可以看到通过 <code>webpack-dev-server</code> 建立的连接因为没有模拟设置，因此不会被拦截模拟。</p>
<p><strong>注意：这个项目只应在开发阶段使用，在线上请移除该项目模块</strong></p>
<h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>后续想着支持一下常用的 WebSocket 库，比如 <a href="https://socket.io/">socket.io</a> ，但是其方法 API 比较多，还没仔细研究怎么实现，而且它并不是 WebSocket 的一个实现，与原生 WebSocket 不能互通。</p>
<blockquote>
<p>Note: Socket.IO is not a WebSocket implementation. Although Socket.IO indeed uses WebSocket as a transport when possible, it adds some metadata to each packet: the packet type, the namespace and the ack id when a message acknowledgement is needed. That is why a WebSocket client will not be able to successfully connect to a Socket.IO server, and a Socket.IO client will not be able to connect to a WebSocket server (like ws://echo.websocket.org) either. Please see the protocol specification <a href="https://github.com/socketio/socket.io-protocol">here</a>.</p>
</blockquote>
<p>或许应该尝试其他思路来实现了。</p>
<br/>

<p>最后再放一下项目地址 <a href="https://github.com/ChuChencheng/wsmock-js">wsmock-js</a> ，欢迎各位大佬们提出意见或建议。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket">WebSocket MDN 文档</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget#Example">MDN EventTarget 的简单实现</a></li>
<li><a href="https://github.com/jakerella/jquery-mockjax">jquery-mockjax</a></li>
<li><a href="https://github.com/angrytoro/mockajax">mockajax</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建Electron+Vue项目</title>
    <url>/2018/07/02/%E6%90%AD%E5%BB%BAElectron+Vue%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>本文记录了从一个 <code>package.json</code> 开始搭建一个 Electron + Vue 项目的过程。</p>
<p>如果不想这么麻烦，可以直接使用 <a href="https://github.com/SimulatedGREG/electron-vue">Electron-vue</a> 项目生成脚手架，里面包含了各种开发工具，包括 Vue.js devtools, 热重载 等。</p>
<p><a href="https://electronjs.org/docs">Electron 文档</a></p>
<h1 id="init-项目"><a href="#init-项目" class="headerlink" title="init 项目"></a>init 项目</h1><p>首先在根目录 <code>npm init</code> 一下，创建 <code>package.json</code> 文件</p>
<p>然后安装 <code>Electron</code>：</p>
<p><code>npm i electron --save-dev</code></p>
<p>或者</p>
<p><code>yarn add electron --dev</code></p>
<p>安装过程由于不可抗力因素可能较慢或者下载失败，可以尝试<a href="https://electronjs.org/docs/tutorial/installation">其他安装方式</a></p>
<h1 id="Electron-应用结构"><a href="#Electron-应用结构" class="headerlink" title="Electron 应用结构"></a>Electron 应用结构</h1><p>简单来说，Electron 应用有两种进程类型：<strong>主进程</strong>和<strong>渲染进程</strong></p>
<p>主进程就是从 <code>package.json</code> 中 <code>main</code> 入口执行的进程。</p>
<p>渲染进程则是负责 web 页面的运行的。</p>
<p>简单了解这两个概念后，我们围绕这两个进程来组织目录结构，在根目录的 <code>src</code> 目录下创建 <code>main</code> 和 <code>renderer</code> 两个文件夹，分别对应主进程和渲染进程。</p>
<h1 id="创建主进程入口"><a href="#创建主进程入口" class="headerlink" title="创建主进程入口"></a>创建主进程入口</h1><p>在 <code>src/main</code> 文件夹下创建 <code>index.js</code> 作为主进程入口，同时在 <code>package.json</code> 中将 <code>main</code> 字段对应修改为 <code>src/main/index.js</code> 。</p>
<p>然后在 <code>src/renderer</code> 文件夹下创建 <code>index.html</code> 作为窗口界面的入口。</p>
<p>接下来可以按照 <a href="https://electronjs.org/docs/tutorial/first-app">Electron 教程</a> 中写的内容来编写 <code>src/main/index.js</code> 跟 <code>src/renderer/index.html</code> 然后试着运行一下。</p>
<p>记得<br><code>win.loadFile(&#39;index.html&#39;)</code> 这句路径需要修改为 <code>src/renderer/index.html</code> ，然后 <code>package.json</code> <code>scripts</code> 中加上 <code>&quot;start&quot;: &quot;electron .&quot;</code></p>
<h1 id="在项目中使用-Vue"><a href="#在项目中使用-Vue" class="headerlink" title="在项目中使用 Vue"></a>在项目中使用 Vue</h1><p>接下来的步骤，基本上可以忘记主进程，先专注于渲染进程的东西了。</p>
<p>Electron 的渲染进程运行的就是一个 web ，也就是说我们只是在 Electron 项目中套用了一套 Vue 项目，你可以把 <code>renderer</code> 文件夹当做一个 Vue 项目的 <code>src</code> 文件夹。</p>
<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>首先安装各种依赖，根据需要装上 Vue 全家桶或者部分。</p>
<p><img src="!--swig%EF%BF%BC2--" alt="依赖"></p>
<h2 id="配置-webpack"><a href="#配置-webpack" class="headerlink" title="配置 webpack"></a>配置 webpack</h2><p>webpack 配置跟平时 Vue 项目的配置类似，这边是我项目开发环境的配置（配置文件位置在根目录）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; VueLoaderPlugin &#125; = <span class="built_in">require</span>(<span class="string">&#x27;vue-loader&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">  devtool: <span class="string">&#x27;#cheap-module-eval-source-map&#x27;</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    port: <span class="number">8086</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: [<span class="string">&#x27;./src/renderer/index.js&#x27;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    filename: <span class="string">&#x27;[name].bundle.js&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  node: <span class="literal">false</span>,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">&#x27;vue$&#x27;</span>: <span class="string">&#x27;vue/dist/vue.esm.js&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;@&#x27;</span>: path.join(__dirname, <span class="string">&#x27;src/renderer&#x27;</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    extensions: [<span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.vue&#x27;</span>, <span class="string">&#x27;.json&#x27;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">        loader: <span class="string">&#x27;vue-loader&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">&#x27;vue-style-loader&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">&#x27;vue-style-loader&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;less-loader&#x27;</span>,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpe?g|gif|svg)(\?.*)?$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/</span>,</span><br><span class="line">        loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(woff2?|eot|ttf|otf)(\?.*)?$/</span>,</span><br><span class="line">        loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> VueLoaderPlugin(),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123; <span class="attr">template</span>: <span class="string">&#x27;src/renderer/index.html&#x27;</span> &#125;),</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(),</span><br><span class="line">  ],</span><br><span class="line">  target: <span class="string">&#x27;electron-renderer&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li><p> <code>entry</code> 的路径跟 <code>plugins</code> 中的路径，即有涉及路径的地方都要相应修改为 <code>renderer</code> 目录下。</p>
</li>
<li><p> <code>target</code> 设置成 <code>electron-renderer</code>。有关 <code>target</code> 可以参照 <a href="https://webpack.docschina.org/configuration/target">webpack target</a></p>
</li>
<li><p>如果你需要访问当前 Electron 运行的进程变量 <code>process</code>，而不是 <code>webpack</code> 提供的变量（例如需要获取当前 Electron 应用使用的 node、 Chrome 与 Electron 版本，需要访问 <code>process.versions</code>），需要将 <code>node</code> 设置为 <code>false</code> 。参照 <a href="https://webpack.docschina.org/configuration/node/">webpack node</a></p>
</li>
</ul>
<p>你也可以使用 webpack 来构建主进程，在此就不多说了。</p>
<h2 id="使用-Vue-编写界面"><a href="#使用-Vue-编写界面" class="headerlink" title="使用 Vue 编写界面"></a>使用 Vue 编写界面</h2><p>这一步就是熟悉的一步了，从上面的 webpack 配置可以看到，<code>entry</code> 为 <code>src/renderer/index.js</code>，这就是 Vue 项目的入口文件。</p>
<p>还记得 <code>src/renderer/index.html</code> 吗，在 webpack 配置中，我们把它作为 <code>HtmlWebpackPlugin</code> 的模板，最后生成为 <code>dist/index.html</code>，因此我们可以把里面 <code>body</code> 的内容简单替换为：</p>
<p><code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code></p>
<p>就像平时写 Vue 项目那样。</p>
<h2 id="修改主进程中-loadFile-路径"><a href="#修改主进程中-loadFile-路径" class="headerlink" title="修改主进程中 loadFile 路径"></a>修改主进程中 loadFile 路径</h2><p>在 <code>src/main/index.js</code> 中，也就是主进程的入口文件，将 <code>win.loadFile</code> 的路径修改为 webpack 编译后的路径，也就是 <code>dist/index.html</code> </p>
<h1 id="运行应用"><a href="#运行应用" class="headerlink" title="运行应用"></a>运行应用</h1><p>做了这么多，终于可以完整运行了。</p>
<p>在 <code>package.json</code> 中的 <code>scripts</code> 中加入 <code>build</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;build&quot;</span>: <span class="string">&quot;webpack --config webpack.config.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;start&quot;</span>: <span class="string">&quot;electron .&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在命令行中按顺序执行这两个脚本即可启动应用</p>
<p><code>npm run build &amp;&amp; npm start</code></p>
<h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p>本文的任务完成了，调试篇参照 <a href="!--swig%EF%BF%BC3--">调试Electron+Vue项目</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Electron</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>调试Electron+Vue项目</title>
    <url>/2018/07/02/%E8%B0%83%E8%AF%95Electron+Vue%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>传送门：<a href="!--swig%EF%BF%BC17--">搭建Electron+Vue项目</a></p>
<p><strong>如果使用了 electron-vue 搭建的项目，基本可以忽略本篇文章，推荐只看后面两个大标题</strong></p>
<p><strong>本文的 dev-server 参考了 electron-vue 中服务器的搭建方式</strong></p>
<p>通过上一篇文章，我们搭建了一个 Electron + Vue 项目，但是每次项目启动都要执行两条命令， <code>npm run build &amp;&amp; npm start</code> 。或许你会说，这就是一条命令，是的没错，<code>webpack &amp;&amp; electron .</code> 的确可以在一条命令中完成。但开发过程中，一个本地 server 是必不可少的（对这类项目来说），而带上一个 server 就不能通过 <code>xxx &amp;&amp; xxx</code> 这样的形式实现了，因为 server 启动的时候会进行监听，导致下一条命令无法执行。</p>
<p>本篇文章主要致力于实现一条命令实现启动 server + electron 并实现调试（<a href="https://github.com/kimmobrunfeldt/concurrently">concurrently</a> 同学请你先坐下）。</p>
<h1 id="搭建-Webpack-dev-server-实现热重载"><a href="#搭建-Webpack-dev-server-实现热重载" class="headerlink" title="搭建 Webpack-dev-server 实现热重载"></a>搭建 Webpack-dev-server 实现热重载</h1><p>平时我们调试 Vue 项目，启动一个 webpack-dev-server 就可以打开浏览器调试了，但是在 Electron 项目中，除了渲染进程，我们还需要启动主进程， dev-server 在项目中用来提供渲染进程的页面。</p>
<h2 id="简单但麻烦的方法"><a href="#简单但麻烦的方法" class="headerlink" title="简单但麻烦的方法"></a>简单但麻烦的方法</h2><p>webpack-dev-server 可以通过命令行启动，而主进程也是通过命令行启动，那么只要在两个不同的命令行窗口分别执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack-dev-server --inline --hot --config webpack.config.dev.js</span><br><span class="line"></span><br><span class="line">electron .</span><br></pre></td></tr></table></figure>
<p>就可以了。</p>
<p>但是本文的目的是…</p>
<h2 id="稍微复杂但便捷的方法"><a href="#稍微复杂但便捷的方法" class="headerlink" title="稍微复杂但便捷的方法"></a>稍微复杂但便捷的方法</h2><p>我们已经知道， server + electron 不能用 <code>xxx &amp;&amp; xxx</code> 启动的原因是：</p>
<ol>
<li>server 启动后会监听文件，从而阻塞了后面那条命令的执行</li>
<li>两条命令有一定的顺序要求，需要启动 server 后再启动 electron</li>
</ol>
<p>（注：顺序不一定有要求，你也可以先启动 electron ，但会看到空白的页面，等 server 启动后再在窗口中刷新即可正常显示）</p>
<p>因此我们需要实现以下几点：</p>
<ol>
<li>启动 server</li>
<li>server 启动后的某个时机启动 electron</li>
<li>最好能将 electron 在控制台中打印的日志与 server 在同一个命令窗口中显示</li>
<li>使用一条命令即可启动</li>
</ol>
<p>我们可以通过一个 Node 脚本来实现。</p>
<h3 id="通过-Node-API-启动-server"><a href="#通过-Node-API-启动-server" class="headerlink" title="通过 Node API 启动 server"></a>通过 Node API 启动 server</h3><p>webpack-dev-server 既可以通过命令行启动，也能通过 Node API 启动。</p>
<p>个人认为 webpack-dev-server Node API 文档不是特别详尽，可以参照其 <a href="https://github.com/webpack/docs/wiki/webpack-dev-server">wiki</a> 跟阅读源码获得一些帮助。</p>
<p>以下是启动 server 部分的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> webpackDevServer = <span class="built_in">require</span>(<span class="string">&#x27;webpack-dev-server&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> devConfig = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.config.dev&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> startServer = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    devConfig.entry.app.unshift(<span class="string">&quot;webpack-dev-server/client?http://localhost:8086/&quot;</span>, <span class="string">&quot;webpack/hot/dev-server&quot;</span>)</span><br><span class="line">    <span class="keyword">const</span> compiler = webpack(devConfig)</span><br><span class="line">    <span class="keyword">const</span> server = <span class="keyword">new</span> webpackDevServer(compiler, &#123;</span><br><span class="line">      hot: <span class="literal">true</span>,</span><br><span class="line">      before (app, ctx) &#123;</span><br><span class="line">        ctx.middleware.waitUntilValid(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          resolve()</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    server.listen(<span class="number">8086</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="启动-electron"><a href="#启动-electron" class="headerlink" title="启动 electron"></a>启动 electron</h3><p>我们需要在与 server 同一个进程中启动 electron ，可以利用 Node 的 <code>child_process</code> 模块来执行。</p>
<p><a href="https://nodejs.org/dist/latest-v8.x/docs/api/child_process.html">child_process 文档</a></p>
<p>我们使用 <code>spawn</code> 方法创建一个子进程启动 electron ，并在子进程关闭的时候结束当前进程，也就是 server 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> electron = <span class="built_in">require</span>(<span class="string">&#x27;electron&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> startElectron = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> electronProcess = spawn(electron, [<span class="string">&#x27;--inspect=5858&#x27;</span>, <span class="string">&#x27;.&#x27;</span>])</span><br><span class="line">  electronProcess.on(<span class="string">&#x27;close&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    process.exit()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="限制执行顺序"><a href="#限制执行顺序" class="headerlink" title="限制执行顺序"></a>限制执行顺序</h3><p>在 <code>startServer</code> 函数中，我们返回了一个 <code>Promise</code> ，在 <code>ctx.middleware.waitUntilValid</code> 中 resolve 了这个 Promise 。通过源码得知这边的 middleware 是一个 <code>webpack-dev-middleware</code> ，直到它可用了，即可启动 electron 子进程。</p>
<p>因此可以这样启动这两个命令：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">startServer().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  startElectron()</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="将-electron-日志输出到-server-命令窗口"><a href="#将-electron-日志输出到-server-命令窗口" class="headerlink" title="将 electron 日志输出到 server 命令窗口"></a>将 electron 日志输出到 server 命令窗口</h3><p>通过上面代码可以得知，当前命令窗口只会打印当前进程的日志信息，即基本上是 server 的日志信息。</p>
<p>查询 <a href="https://nodejs.org/dist/latest-v8.x/docs/api/child_process.html">child_process 文档</a> 可以得知 child_process 有 <code>stdout</code> 和 <code>stderr</code> 两个属性，并且可以监听其输出的内容（一般情况只需要关注这两个）。因此我们可以稍微改造一下 <code>startElectron</code> ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> startElectron = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> electronProcess = spawn(electron, [<span class="string">&#x27;--inspect=5858&#x27;</span>, <span class="string">&#x27;.&#x27;</span>])</span><br><span class="line">  electronProcess.stdout.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Electron stdout: <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  electronProcess.stderr.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Electron stderr: <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  electronProcess.on(<span class="string">&#x27;close&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    process.exit()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，这个脚本就完成了，下面放出完整的脚本代码，基本上是参考了 <code>electron-vue</code> 的脚本代码，但没用 webpack-hot-middleware：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * webpack-dev-server 实现热重载，服务器启动后启动 electron</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> electron = <span class="built_in">require</span>(<span class="string">&#x27;electron&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; spawn &#125; = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">&#x27;chalk&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> webpackDevServer = <span class="built_in">require</span>(<span class="string">&#x27;webpack-dev-server&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> devConfig = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.config.dev&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> electronProcess = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> startServer = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    devConfig.entry.app.unshift(<span class="string">&quot;webpack-dev-server/client?http://localhost:8086/&quot;</span>, <span class="string">&quot;webpack/hot/dev-server&quot;</span>)</span><br><span class="line">    <span class="keyword">const</span> compiler = webpack(devConfig)</span><br><span class="line">    <span class="keyword">const</span> server = <span class="keyword">new</span> webpackDevServer(compiler, &#123;</span><br><span class="line">      hot: <span class="literal">true</span>,</span><br><span class="line">      before (app, ctx) &#123;</span><br><span class="line">        ctx.middleware.waitUntilValid(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          resolve()</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    server.listen(<span class="number">8086</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> startElectron = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  electronProcess = spawn(electron, [<span class="string">&#x27;--inspect=5858&#x27;</span>, <span class="string">&#x27;.&#x27;</span>])</span><br><span class="line">  electronProcess.stdout.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(chalk.blue(<span class="string">&#x27;------ Electron info start ------&#x27;</span>))</span><br><span class="line">    <span class="built_in">console</span>.log(chalk.blue(data))</span><br><span class="line">    <span class="built_in">console</span>.log(chalk.blue(<span class="string">&#x27;------ Electron info end ------&#x27;</span>))</span><br><span class="line">  &#125;)</span><br><span class="line">  electronProcess.stderr.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(chalk.red(<span class="string">&#x27;------ Electron error start ------&#x27;</span>))</span><br><span class="line">    <span class="built_in">console</span>.log(chalk.red(data))</span><br><span class="line">    <span class="built_in">console</span>.log(chalk.red(<span class="string">&#x27;------ Electron error end ------&#x27;</span>))</span><br><span class="line">  &#125;)</span><br><span class="line">  electronProcess.on(<span class="string">&#x27;close&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    process.exit()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">startServer().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  startElectron()</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>将这段代码保存为 <code>dev.js</code> 放在项目根目录，在 <code>package.json</code> 中添加脚本 <code>&quot;dev&quot;: &quot;node ./dev.js&quot;</code> ，后续即可通过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure>
<p>来启动调试服务</p>
<h1 id="使用-Chrome-开发者工具调试渲染进程"><a href="#使用-Chrome-开发者工具调试渲染进程" class="headerlink" title="使用 Chrome 开发者工具调试渲染进程"></a>使用 Chrome 开发者工具调试渲染进程</h1><p>Chrome 开发者工具是通过主进程中 <code>BrowserWindow</code> 实例的 <code>webContents.openDevTools</code> 方法打开的，从头开始是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> win = <span class="keyword">new</span> BrowserWindow(&#123;<span class="attr">width</span>: <span class="number">800</span>, <span class="attr">height</span>: <span class="number">600</span>&#125;)</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 然后加载应用的 index.html。</span></span><br><span class="line">win.loadFile(<span class="string">&#x27;index.html&#x27;</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 打开开发者工具</span></span><br><span class="line">win.webContents.openDevTools()</span><br></pre></td></tr></table></figure>
<p>启动后就可以看见熟悉的 Chrome 神器了，配合 webpack 配置中的 <code>devtool</code> source map ，就可以在 vue 文件中各种打断点了。</p>
<h1 id="加载-Vue-js-devtools"><a href="#加载-Vue-js-devtools" class="headerlink" title="加载 Vue.js devtools"></a>加载 Vue.js devtools</h1><p><a href="https://electronjs.org/docs/tutorial/devtools-extension">Electron 文档 – 开发工具扩展程序</a></p>
<p>这里面写得够清楚了，不再多说。</p>
<p>如果 <code>%LOCALAPPDATA%</code> 没法读取，就使用系统的绝对路径吧。</p>
<p><a href="https://github.com/MarshallOfSound/electron-devtools-installer">electron-devtools-installer</a> 也是个不错的选择。</p>
<p>需要注意的是，两种方式都是需要从 Chrome 商店下载扩展的，需要科学上网。</p>
<h1 id="electron-–inspect-调试主进程"><a href="#electron-–inspect-调试主进程" class="headerlink" title="electron . –inspect 调试主进程"></a>electron . –inspect 调试主进程</h1><p>根据 <a href="https://electronjs.org/docs/tutorial/debugging-main-process">Electron 文档 – 调试主进程</a> 的说法，我们可以用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">electron . --inspect&#x3D;5858</span><br></pre></td></tr></table></figure>
<p>来调试主进程。</p>
<p>除了上述命令之外，我们还需要一个 <code>支持 V8 调试协议的调试器</code> 。</p>
<p>这个调试器，方便一点的，我们可以用 Chrome 浏览器直接来调试。</p>
<h2 id="使用-Chrome-调试主进程"><a href="#使用-Chrome-调试主进程" class="headerlink" title="使用 Chrome 调试主进程"></a>使用 Chrome 调试主进程</h2><p>首先，打开 Chrome ，在地址栏里输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chrome:&#x2F;&#x2F;inspect</span><br></pre></td></tr></table></figure>
<p>看到如下界面，点击 <code>Configure</code></p>
<p><img src="!--swig%EF%BF%BC13--" alt="Chrome inspect"></p>
<p>紧接着，新增一条</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">localhost:5858</span><br></pre></td></tr></table></figure>
<p>这边的 <code>5858</code> 就是上面命令行执行的端口。</p>
<p><img src="!--swig%EF%BF%BC14--" alt="Chrome inspect settings"></p>
<p>接下来启动上面的命令， <code>electron . --inspect=5858</code> ，即可在 Chrome 中看到 Remote Target 中多了个东西，点击 <code>inspect</code> 即可打开开发者工具，主进程的代码都在里面，可以进行调试，设置断点之类的。</p>
<p><img src="!--swig%EF%BF%BC15--" alt="Chrome inspect settings"></p>
<h2 id="使用-VSCode-附加在主进程上"><a href="#使用-VSCode-附加在主进程上" class="headerlink" title="使用 VSCode 附加在主进程上"></a>使用 VSCode 附加在主进程上</h2><p>在 VSCode 中，可以把调试器附加在 Electron 主进程中。</p>
<p><img src="!--swig%EF%BF%BC16--" alt="VSCode attach"></p>
<p>进入 Debug 面板，添加配置，VSCode 会在根目录生成一个 <code>.vscode</code> 文件夹，并包含一个 <code>launch.json</code> 文件，这就是 VSCode debug 时的配置文件。</p>
<p>打开 <code>launch.json</code> ，在 <code>configurations</code> 中填入： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;node&quot;</span>,</span><br><span class="line">  <span class="string">&quot;request&quot;</span>: <span class="string">&quot;attach&quot;</span>,</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Inspect Electron&quot;</span>,</span><br><span class="line">  <span class="string">&quot;port&quot;</span>: <span class="number">5858</span>,</span><br><span class="line">  <span class="string">&quot;sourceMaps&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;localRoot&quot;</span>: <span class="string">&quot;$&#123;workspaceRoot&#125;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;remoteRoot&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">&quot;address&quot;</span>: <span class="string">&quot;localhost&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后保存。</p>
<p>现在，你可以在 VSCode 中按 <code>F5</code> 键启动调试器，并在 VSCode 中对主进程的代码打断点进行调试了。当然，这是在启动了 Electron 的前提下进行的调试，你还是需要先手动执行 <code>electron . --inspect=5858</code> 。</p>
<h1 id="使用-VSCode-调试主进程"><a href="#使用-VSCode-调试主进程" class="headerlink" title="使用 VSCode 调试主进程"></a>使用 VSCode 调试主进程</h1><p>开头我们已经写好了一个启动 dev-server 后再启动 Electron 的脚本，在 VSCode 中，我们可以利用其调试器来启动这个脚本，并且直接在 VSCode 中调试主进程。</p>
<p>与上面使用附加的方式不同，这次我们使用 launch 。</p>
<p><code>launch.json</code> <code>configurations</code> ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;node&quot;</span>,</span><br><span class="line">  <span class="string">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;启动程序&quot;</span>,</span><br><span class="line">  <span class="string">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;workspaceRoot&#125;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;program&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;/dev.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;autoAttachChildProcesses&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意最后一行 <code>&quot;autoAttachChildProcesses&quot;: true</code> ，由于我们的脚本是通过子进程启动的 Electron ，这一行配置告诉 VSCode 自动附加到子进程上，也就是脚本启动的 Electron 进程，这相当于 “启动 dev.js + 附加到 Electron 进程” ，因此我们可以直接在 VSCode 中调试主进程。</p>
<p>有关 <code>launch.json</code> 配置见 <a href="https://code.visualstudio.com/docs/editor/debugging#_launch-configurations">VSCode 文档</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Electron</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>将 Electron 应用打包为 Windows exe 文件</title>
    <url>/2018/07/14/%E5%B0%86Electron%E5%BA%94%E7%94%A8%E6%89%93%E5%8C%85%E4%B8%BAWindows-exe%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>假设你已经写好了一个 Electron 应用，想要打包为安装包分发给用户。</p>
<h1 id="安装-electron-builder"><a href="#安装-electron-builder" class="headerlink" title="安装 electron-builder"></a>安装 electron-builder</h1><p>这里使用 <code>electron-builder</code> 来完成这项光荣的任务，首先安装 <code>electron-builder</code> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add electron-builder --dev</span><br></pre></td></tr></table></figure>
<h1 id="配置-package-json"><a href="#配置-package-json" class="headerlink" title="配置 package.json"></a>配置 package.json</h1><p>如果你看过他们的<a href="https://www.electron.build/">官方文档</a>就知道，下一步该配置 <code>package.json</code></p>
<p>添加一个 <code>build</code> 字段</p>
<p>下面直接放出示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;build&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;appId&quot;</span>: <span class="string">&quot;Your.App.Id&quot;</span>,</span><br><span class="line">  <span class="string">&quot;productName&quot;</span>: <span class="string">&quot;Your product name&quot;</span>,</span><br><span class="line">  <span class="string">&quot;directories&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">// 输出 exe 的文件夹，默认是 dist </span></span><br><span class="line">    <span class="comment">// 如果使用 webpack 配置了输出文件夹是 dist ，这边可以选择换一个输出文件夹</span></span><br><span class="line">    <span class="string">&quot;output&quot;</span>: <span class="string">&quot;output&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;win&quot;</span>: &#123;  <span class="comment">// Windows</span></span><br><span class="line">    <span class="string">&quot;target&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;target&quot;</span>: <span class="string">&quot;nsis&quot;</span>, <span class="comment">// target 默认是 nsis</span></span><br><span class="line">        <span class="string">&quot;arch&quot;</span>: [</span><br><span class="line">          <span class="string">&quot;x64&quot;</span> <span class="comment">// 如果需要打包 32 位，数组里加上 &#x27;ia32&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;build/icon.ico&quot;</span>, <span class="comment">// icon 地址</span></span><br><span class="line">    <span class="string">&quot;publish&quot;</span>: &#123;  <span class="comment">// 发布配置，如果使用 Auto Update 应该需要配置</span></span><br><span class="line">      <span class="string">&quot;provider&quot;</span>: <span class="string">&quot;generic&quot;</span>,</span><br><span class="line">      <span class="string">&quot;url&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;nsis&quot;</span>: &#123; <span class="comment">// nsis 配置</span></span><br><span class="line">    <span class="comment">// 是否非一键安装</span></span><br><span class="line">    <span class="string">&quot;oneClick&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 是否可以选择安装位置</span></span><br><span class="line">    <span class="string">&quot;allowToChangeInstallationDirectory&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;files&quot;</span>: [  <span class="comment">// 需要打包进 exe 的文件，具体书写规则参照文档</span></span><br><span class="line">    <span class="string">&quot;dist/*&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build/icon.ico&quot;</span>,</span><br><span class="line">    <span class="string">&quot;!node_modules&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.electron.build/file-patterns/">files 字段书写规则</a></p>
<p>或许还需要配置一个 <code>scripts</code> :</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;dist&quot;</span>: <span class="string">&quot;electron-builder&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h1><p>执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn dist</span><br></pre></td></tr></table></figure>
<p>等待打包即可。</p>
<p>Note: 在打包过程中，有些必要的包可能会下载失败，请自行查看控制台输出，下载失败的文件到对应的位置，重新执行打包。</p>
<p>最后，根据上面的配置，会在 <code>output</code> 文件夹下看到 <code>unpacked</code> 文件夹跟 <code>.exe</code> 文件。如果配置了 <code>publish</code> (如上配置)，还会有个 <code>latest.yml</code> 文件，这个文件在使用 <code>electron-builder</code> 的<a href="https://www.electron.build/auto-update">自动更新</a>功能时会用到。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Electron</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 源码浏览笔记</title>
    <url>/2019/01/10/Vue%E6%BA%90%E7%A0%81%E6%B5%8F%E8%A7%88%E7%AC%94%E8%AE%B0-0/</url>
    <content><![CDATA[<h1 id="废话在前"><a href="#废话在前" class="headerlink" title="废话在前"></a>废话在前</h1><p>原本为了了解一下 slot 是怎么处理的，于是看了源码，最后虽然还没看到那边，但是大概了解了 <code>new Vue()</code> 的过程，记录一下。</p>
<h1 id="下载仓库并安装依赖"><a href="#下载仓库并安装依赖" class="headerlink" title="下载仓库并安装依赖"></a>下载仓库并安装依赖</h1><p>略</p>
<h1 id="运行、在源码中打断点"><a href="#运行、在源码中打断点" class="headerlink" title="运行、在源码中打断点"></a>运行、在源码中打断点</h1><p>vue 使用的是 rollup 打包。</p>
<p>在 <code>scripts/config.js</code> 中的 <code>genConfig</code> 方法中的 <code>config</code> 对象中加上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sourcemap: true</span><br></pre></td></tr></table></figure>
<p>然后 <code>npm run dev</code></p>
<p>会打包 <code>vue.js</code> 到 <code>dist</code></p>
<p>接下来随便开一个 example ，引入刚刚打包的 <code>dist/vue.js</code> ，浏览器直接打开 html ，因为开了 sourcemap ，可以直接在谷歌开发者工具中对源码进行断点</p>
<p>开篇就这样吧</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue树组件性能优化</title>
    <url>/2019/05/08/Vue%E6%A0%91%E7%BB%84%E4%BB%B6%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="写树组件的思路"><a href="#写树组件的思路" class="headerlink" title="写树组件的思路"></a>写树组件的思路</h1><p>一听说要写树组件，像我这样的菜鸡肯定都是想到，就按照树形的结构，递归来组织组件。</p>
<p>这个思路本身是没问题的，我之前就按照这个思路写了一版，结局嘛…如果是 happy ending 的话就不会有这篇文了。</p>
<h1 id="递归组件的缺陷"><a href="#递归组件的缺陷" class="headerlink" title="递归组件的缺陷"></a>递归组件的缺陷</h1><p>先说说递归写法的优点：</p>
<ol>
<li>结构直白，数据什么样，组件就什么样，傻瓜式组织。</li>
<li>父子节点相关样式控制方便，展开折叠什么的，一个 v-show 就能搞定。</li>
</ol>
<p>然后是缺陷：</p>
<ol>
<li>结构太直白，导致 DOM 层级深，数据层级有多深， DOM 就有多深。</li>
<li>父子组件通信不便，需要用 event bus , vuex 或 provide 之类的方式进行深层的通信。</li>
<li>数据遍历困难，如果没有预先处理，需要经常一层层往下处理数据，导致代码跟💩一样。</li>
<li>最重要的就是性能问题，这种类似列表的数据，量一多，渲染方面肯定先撑不住， DOM 数量多、层级深，会导致浏览器卡顿，递归遍历数据也可能导致 UI 阻塞（虽然实际上并不会， V8 很强的。</li>
</ol>
<h1 id="需要优化的点"><a href="#需要优化的点" class="headerlink" title="需要优化的点"></a>需要优化的点</h1><p>根据列出的缺陷，可以简单得出一些优化关键点：</p>
<ol>
<li>优化深层级 DOM 结构</li>
<li>优化子组件结构，方便父子通信</li>
<li>优化数据结构，方便数据遍历与节点获取</li>
</ol>
<h1 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h1><p>让我们一点一点来看。</p>
<ol>
<li>首先是 DOM 结构。 DOM 是由 Vue 组件挂载出来的，因此考虑优化 Vue 组件。</li>
<li>子组件由于是递归组件，才生成了深层级的 DOM 结构，而 Vue 组件是根据数据来渲染的，因此我们要在根源，也就是数据上做手脚。</li>
<li>树数据，一般就是树形的一个结构，既然树形结构会导致一个递归的渲染，那我们可以把这个结构扁平化，这样，子组件就组成了一个普通的列表。</li>
</ol>
<p>把子组件变成列表，还有一个问题，就是 DOM 数量多的问题。平时我们写列表，如果是表格，一般都有分页，如果是选择下拉之类的列表，一般数量不多，几十个列表项，甚至几百个，我们可能都不会主动去优化，对扁平化后的树来说也是一样的。</p>
<p>不过既然已经优化了，那就优化得彻底一点，毕竟内存占用也是一个重要的优化点，优化过后可以轻松应对几百上千条、甚至上万条数据，岂不美哉？</p>
<h1 id="优化步骤"><a href="#优化步骤" class="headerlink" title="优化步骤"></a>优化步骤</h1><h2 id="数据扁平化"><a href="#数据扁平化" class="headerlink" title="数据扁平化"></a>数据扁平化</h2><p>组件使用者传进来的数据一般是一个树形结构：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> treeData = [</span><br><span class="line">  &#123;</span><br><span class="line">    title: <span class="string">&#x27;parent-1&#x27;</span>,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        title: <span class="string">&#x27;children-1&#x27;</span>,</span><br><span class="line">        children: [</span><br><span class="line">          &#123;</span><br><span class="line">            title: <span class="string">&#x27;grandchildren-1&#x27;</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>为了达到渲染一个列表的效果，需要把子节点提出来，与父节点同级，也就是把 <code>children</code> 字段往外提：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> flattenedData = [</span><br><span class="line">  &#123;</span><br><span class="line">    title: <span class="string">&#x27;parent-1&#x27;</span>,</span><br><span class="line">    children: [ <span class="comment">/* ... */</span> ],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    title: <span class="string">&#x27;children-1&#x27;</span>,</span><br><span class="line">    children: [ <span class="comment">/* ... */</span> ],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    title: <span class="string">&#x27;grandchildren-1&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>为了保留住节点之间的层级关系，可以在拍平过程中给每个节点额外加一个 <code>level</code> 字段，比如根节点的 level 为 0 ，往深层依次递增。</p>
<h2 id="递归组件转换为列表结构"><a href="#递归组件转换为列表结构" class="headerlink" title="递归组件转换为列表结构"></a>递归组件转换为列表结构</h2><p>使用递归组件一般会用 <code>ul</code> 标签或者对子节点整体设置一个缩进来表示节点之间的层级关系，在数据扁平化后，我们可以根据上面设置的 <code>level</code> 字段，去控制每个节点的缩进。</p>
<p>原来的递归组件结构：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Tree.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    &lt;TreeNode</span><br><span class="line">      v-for=&quot;node in treeData&quot;</span><br><span class="line">      :key=&quot;node.key&quot;</span><br><span class="line">    /&gt;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- TreeNode.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    &lt;div</span><br><span class="line">      v-if=&quot;children&quot;</span><br><span class="line">      style=&quot;margin-left: 20px;&quot;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;TreeNode</span><br><span class="line">        v-for=&quot;node in children&quot;</span><br><span class="line">        :key=&quot;node.key&quot;</span><br><span class="line">      /&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>改为普通的列表：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Tree.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    &lt;TreeNode</span><br><span class="line">      v-for=&quot;node in treeData&quot;</span><br><span class="line">      :key=&quot;node.key&quot;</span><br><span class="line">      :style=&quot;&#123;</span><br><span class="line">        marginLeft: `$&#123;node.level * 20&#125;px`</span><br><span class="line">      &#125;&quot;</span><br><span class="line">    /&gt;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- TreeNode.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="子节点显隐"><a href="#子节点显隐" class="headerlink" title="子节点显隐"></a>子节点显隐</h2><p>组件改为列表结构后，新的问题出现了，怎么控制子节点的显隐。</p>
<p>在递归结构中，只要在 <code>TreeNode</code> 组件中控制子组件的容器 div 显隐即可。</p>
<p>在列表中，每个节点都是同级的，处理起来会稍微麻烦一些。</p>
<p>我们可以在每个节点上添加一个 <code>visible</code> 属性，在执行展开折叠操作时，只要控制父节点下的所有子节点，以及子节点的子节点他们的 <code>visible</code> ，即可实现显隐控制。</p>
<h3 id="思路1-递归"><a href="#思路1-递归" class="headerlink" title="思路1 递归"></a>思路1 递归</h3><p>还记得扁平化数据时把子节点提出来的操作吗，那一步提出来的数据实际是一个引用，每个节点本身是不变的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> flattenedData = [</span><br><span class="line">  &#123;</span><br><span class="line">    title: <span class="string">&#x27;parent-1&#x27;</span>,</span><br><span class="line">    children: [</span><br><span class="line">      &#123; <span class="comment">// 这个节点跟外层提出去的节点实际上是同一个对象</span></span><br><span class="line">        title: <span class="string">&#x27;children-1&#x27;</span>,</span><br><span class="line">        children: [ <span class="comment">/* ... */</span> ],</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    title: <span class="string">&#x27;children-1&#x27;</span>,</span><br><span class="line">    children: [ <span class="comment">/* ... */</span> ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>也就是说，我们只要访问 <code>parentNode.children</code> ，还是能得到这个父节点下的所有子节点。那么，需要控制显隐时，递归遍历父节点以下的所有子节点以及子节点的子节点，分别设置他们的 <code>visible</code> 属性即可。</p>
<h3 id="思路2-对扁平化后的数据做手脚"><a href="#思路2-对扁平化后的数据做手脚" class="headerlink" title="思路2 对扁平化后的数据做手脚"></a>思路2 对扁平化后的数据做手脚</h3><p>扁平化后的数据是有个 <code>level</code> 字段去表示他们的层级关系的，那么根据这个字段，我们不需要递归其实也可以获取到某个节点的所有子节点，包括子节点的子节点。</p>
<p>扁平化后的数据：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> flattenedData = [</span><br><span class="line">  &#123;</span><br><span class="line">    title: <span class="string">&#x27;parent-1&#x27;</span>,</span><br><span class="line">    level: <span class="number">0</span>,</span><br><span class="line">    children: [ <span class="comment">/* ... */</span> ],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    title: <span class="string">&#x27;children-1&#x27;</span>,</span><br><span class="line">    level: <span class="number">1</span>,</span><br><span class="line">    children: [ <span class="comment">/* ... */</span> ],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    title: <span class="string">&#x27;grandchildren-1&#x27;</span>,</span><br><span class="line">    level: <span class="number">2</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    title: <span class="string">&#x27;parent-2&#x27;</span>,</span><br><span class="line">    level: <span class="number">0</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>假设我们需要获取 <code>parent-1</code> 节点的所有子孙节点， 那么，只要从这个节点开始，在 <code>flattenedData</code> 中往下遍历，直到 <code>level</code> 大于等于 <code>parent-1</code> ，或者到了数组末尾这段数据，均为其子孙节点。</p>
<p>但是这个方法需要先获取节点在 <code>flattenedData</code> 中的位置。</p>
<p>在性能影响不大的前提下，我还是偏向递归的（真香</p>
<h2 id="控制-DOM-数量"><a href="#控制-DOM-数量" class="headerlink" title="控制 DOM 数量"></a>控制 DOM 数量</h2><p>之前有跟做 Android 的小伙伴讨论过，手机上的长列表也是需要优化的。在这点上，优化的思路是一致的，都是只渲染视野内可见的几条列表项，然后在滚动的时候不断回收、创建视野以外的列表项，达成优化的效果。</p>
<p>不过与浏览器不同的是， Android 应用在渲染之前，系统就会计算出每个列表项的高度，而浏览器是在渲染完成之后，才有办法去获取一个元素的实际高度，这导致在浏览器上优化列表会稍微麻烦一些。</p>
<h3 id="简单思路"><a href="#简单思路" class="headerlink" title="简单思路"></a>简单思路</h3><p>这里采用最简单的思路来优化：</p>
<ol>
<li>我们假设每个节点高度都是相同的</li>
<li>节点容器的高度就是 <code>(节点高度 * 节点总个数)</code></li>
<li>确定可见 div 的高度，监听其 <code>scroll</code> 事件，根据 <code>scrollTop</code> 计算当前可见区域对应 <code>flattenedData</code> 哪一部分。</li>
</ol>
<p>思路相对简单，但是缺点其实也比较明显，就是对于节点高度的限制是比较死的，如果节点高度都不相等，或者与传入的节点高度 Prop 相差过大，就可能出现滚动条拉不下去，最后几条数据无法渲染，或者末尾出现空白的情况，因为节点容器的高度：<code>(节点高度 * 节点总个数)</code> 是限死的。</p>
<h3 id="其他办法"><a href="#其他办法" class="headerlink" title="其他办法"></a>其他办法</h3><p>其他思路总是有的，比如 <a href="https://github.com/Akryum">Akryum</a> 大佬的 <a href="https://github.com/Akryum/vue-virtual-scroller">vue-virtual-scroller</a> ，利用 <code>translate</code> 与创建视图组件池(?creates pools of views)的方式，即能不限制节点的高度，又可以不用重复销毁、创建 Vue 组件。</p>
<h2 id="其他优化点"><a href="#其他优化点" class="headerlink" title="其他优化点"></a>其他优化点</h2><p>还有一个要提到的地方是， Vue 会把需要监听的数据都遍历一遍，然后加上 <code>getter</code> 跟 <code>setter</code> ，这样在数据量大的情况下，会导致开销变大。</p>
<p>为了避免 Vue 去监听大量的数据，我们可以提供一个方法 <code>setData</code> ，而不是 Prop ，来接收树数据，在方法里去初始化树数据。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>new Vue() 的时候发生了什么</title>
    <url>/2019/01/10/Vue%E6%BA%90%E7%A0%81%E6%B5%8F%E8%A7%88%E7%AC%94%E8%AE%B0-1/</url>
    <content><![CDATA[<h1 id="寻找-Vue-函数"><a href="#寻找-Vue-函数" class="headerlink" title="寻找 Vue 函数"></a>寻找 Vue 函数</h1><p>要知道 new Vue() 的时候发生了什么，首先要知道 Vue 定义在哪里。</p>
<p>我们从 <code>package.json</code> 开始寻找 Vue 在哪里</p>
<ol>
<li>在 <code>scripts</code> 中，可以看到在 build 时执行了 <code>scripts/build.js</code></li>
<li>找到 <code>scripts/build.js</code> ，发现在构建时读取了同目录下的 <code>config.js</code></li>
<li>找到 <code>scripts/config.js</code> ，根据 <code>package.json</code> 中的 <code>main</code> 字段可以知道最终入口是 <code>dist/vue.runtime.common.js</code> ，于是我们找 dest 为 <code>dist/vue.runtime.common.js</code> 对应的 entry ，发现是 <code>web/entry-runtime.js</code></li>
<li>找到 <code>entry-runtime.js</code> （别名在 <code>scripts/alias.js</code> 中），顺着 <code>import Vue</code> 一直找下去</li>
<li>最后发现，在 <code>src/core/instance/index.js</code> 中定义了 <code>function Vue</code></li>
</ol>
<h1 id="import-Vue-时发生了什么"><a href="#import-Vue-时发生了什么" class="headerlink" title="import Vue 时发生了什么"></a>import Vue 时发生了什么</h1><p>平时在写 Vue 项目时，一般都是先导入 Vue ，然后再执行 new Vue()</p>
<p>那么，在我们 <code>import Vue from &#39;vue&#39;</code> 的时候都发生了什么呢，或者说，new Vue() 之前框架都做了哪些准备工作</p>
<p>我们从 rollup 打包的入口，也就是上一步中的 <code>web/entry-runtime.js</code> 开始看（单页应用的话引入的可能是 <code>vue.esm.js</code> ，对应入口是 <code>web/entry-runtime-with-compiler.js</code> ，与运行时版本相比，其 <code>$mount</code> 是带了编译模板功能的，这个暂时不看），会发现在 <code>web/runtime/index.js</code> 中，主要是在 <code>Vue.prototype</code> 上挂了一个 <code>$mount</code> 方法，这个方法，就是我们执行 <code>(new Vue()).$mount()</code> 时调用的方法</p>
<p>从当前文件接着寻找 <code>import Vue</code> ，可以找到 <code>core/index.js</code> ，在这个文件中，主要是挂载 ssr 相关的属性， <code>$isServer</code>, <code>$ssrContext</code> 等</p>
<p>接着找 <code>import Vue</code> ，就找到了定义 Vue 的地方， <code>core/instance/index.js</code> 。在 <code>function Vue</code> 底下对 Vue 函数执行了一些混入操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">initMixin(Vue)</span><br><span class="line">stateMixin(Vue)</span><br><span class="line">eventsMixin(Vue)</span><br><span class="line">lifecycleMixin(Vue)</span><br><span class="line">renderMixin(Vue)</span><br></pre></td></tr></table></figure>
<p>这一堆 mixin 方法都是从同目录下的文件中导入的，我们一个个来看</p>
<h2 id="initMixin"><a href="#initMixin" class="headerlink" title="initMixin"></a>initMixin</h2><p>文件： <code>src\core\instance\init.js</code></p>
<p>主要内容： 挂载 <code>_init</code> 方法到 <code>Vue.prototype</code> 中， <code>_init</code> 是 <code>new Vue()</code> 时首先调用的方法。</p>
<h2 id="stateMixin"><a href="#stateMixin" class="headerlink" title="stateMixin"></a>stateMixin</h2><p>文件： <code>src\core\instance\state.js</code></p>
<p>主要内容： 挂载 <code>$data</code>, <code>$props</code> 属性与 <code>$set</code>, <code>$delete</code>, <code>$watch</code> 方法到 <code>Vue.prototype</code> 中</p>
<h2 id="eventsMixin"><a href="#eventsMixin" class="headerlink" title="eventsMixin"></a>eventsMixin</h2><p>文件： <code>src\core\instance\events.js</code></p>
<p>主要内容： 挂载 <code>$on</code>, <code>$once</code>, <code>$off</code>, <code>$emit</code> 方法到 <code>Vue.prototype</code> 中</p>
<h2 id="lifecycleMixin"><a href="#lifecycleMixin" class="headerlink" title="lifecycleMixin"></a>lifecycleMixin</h2><p>文件： <code>src\core\instance\lifecycle.js</code></p>
<p>主要内容： 挂载 <code>_update</code>, <code>$forceUpdate</code>, <code>$destroy</code> 方法到 <code>Vue.prototype</code> 中</p>
<h2 id="renderMixin"><a href="#renderMixin" class="headerlink" title="renderMixin"></a>renderMixin</h2><p>文件： <code>src\core\instance\render.js</code></p>
<p>主要内容： 挂载 <code>$nextTick</code>, <code>_render</code> 方法到 <code>Vue.prototype</code> 中</p>
<p>到这里，准备工作就基本完成了，总结起来就是往 <code>Vue.prototype</code> 中挂载了一堆属性与方法</p>
<h1 id="new-Vue-时发生了什么"><a href="#new-Vue-时发生了什么" class="headerlink" title="new Vue() 时发生了什么"></a>new Vue() 时发生了什么</h1><p>准备工作完成后，接下来就是等待用户执行 <code>new Vue()</code> 了。</p>
<p>我们从定义 Vue 的地方，就是 <code>src\core\instance\index.js</code> 开始看起。</p>
<p><code>function Vue</code> 中除了提示我们 Vue 是一个需要用 new 的构造函数外，只调用了一个方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>._init(options)</span><br></pre></td></tr></table></figure>
<p>这个即是刚才 <code>initMixin</code> 中挂载到 <code>Vue.prototype</code> 上的 <code>_init</code> 方法。</p>
<p><code>_init</code> 中主要做了这些事：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 省略部分代码</span></span><br><span class="line"><span class="keyword">const</span> vm: Component = <span class="built_in">this</span></span><br><span class="line">initLifecycle(vm)</span><br><span class="line">initEvents(vm)</span><br><span class="line">initRender(vm)</span><br><span class="line">callHook(vm, <span class="string">&#x27;beforeCreate&#x27;</span>)</span><br><span class="line">initInjections(vm) <span class="comment">// resolve injections before data/props</span></span><br><span class="line">initState(vm)</span><br><span class="line">initProvide(vm) <span class="comment">// resolve provide after data/props</span></span><br><span class="line">callHook(vm, <span class="string">&#x27;created&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">  vm.$mount(vm.$options.el)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在生命周期 <code>beforeCreate</code> 之前，完成了 <code>initLifecycle</code>, <code>initEvents</code> 和 <code>initRender</code>。前两个不说，在 <code>initRender</code> 中，挂载了 <code>$slots</code>, <code>$scopedSlots</code>, <code>$attrs</code>, <code>$listeners</code> 属性和 <code>$createElement</code> 方法。</p>
<p>而在 <code>created</code> 之前，完成了 <code>initInjections</code>, <code>initState</code> 和 <code>initProvide</code> 。这边我们主要看一下 <code>initState</code> ，因为这跟我们平时所写的 Vue 组件的属性关系比较大。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initState</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  vm._watchers = []</span><br><span class="line">  <span class="keyword">const</span> opts = vm.$options</span><br><span class="line">  <span class="keyword">if</span> (opts.props) initProps(vm, opts.props)</span><br><span class="line">  <span class="keyword">if</span> (opts.methods) initMethods(vm, opts.methods)</span><br><span class="line">  <span class="keyword">if</span> (opts.data) &#123;</span><br><span class="line">    initData(vm)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    observe(vm._data = &#123;&#125;, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (opts.computed) initComputed(vm, opts.computed)</span><br><span class="line">  <span class="keyword">if</span> (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</span><br><span class="line">    initWatch(vm, opts.watch)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，我们可以看到每个属性初始化的顺序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">props -&gt; methods -&gt; data -&gt; computed -&gt; watch</span><br></pre></td></tr></table></figure>
<p>根据这个顺序就可以明白，为什么在 props 里面没法访问 methods 或 data ，在 data 里面能访问 methods 却无法访问 computed</p>
<p>而 props 的 validator ，因为是直接调用执行的，因此内部无法访问 Vue 实例；而且 props 是最先被初始化的，在这个步骤对于实例内的属性几乎没有什么可访问的，个人感觉即使绑定了 this 意义也不大。</p>
<p>接下来就是判断是否提供了 <code>el</code> 属性，如果有，则执行 <code>$mount</code> 方法挂载组件，这个过程中，会调用 <code>src\core\instance\lifecycle.js</code> 中的 <code>mountComponent</code> 。由于在这个方法中也存在生命周期钩子函数的调用，下面大概来看一下 <code>mountComponent</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除了非 production 时的代码</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vm: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  el: ?Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  vm.$el = el</span><br><span class="line">  <span class="keyword">if</span> (!vm.$options.render) &#123;</span><br><span class="line">    vm.$options.render = createEmptyVNode</span><br><span class="line">  &#125;</span><br><span class="line">  callHook(vm, <span class="string">&#x27;beforeMount&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> updateComponent</span><br><span class="line">  updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    vm._update(vm._render(), hydrating)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we set this to vm._watcher inside the watcher&#x27;s constructor</span></span><br><span class="line">  <span class="comment">// since the watcher&#x27;s initial patch may call $forceUpdate (e.g. inside child</span></span><br><span class="line">  <span class="comment">// component&#x27;s mounted hook), which relies on vm._watcher being already defined</span></span><br><span class="line">  <span class="keyword">new</span> Watcher(vm, updateComponent, noop, &#123;</span><br><span class="line">    before () &#123;</span><br><span class="line">      <span class="keyword">if</span> (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123;</span><br><span class="line">        callHook(vm, <span class="string">&#x27;beforeUpdate&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</span><br><span class="line">  hydrating = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// manually mounted instance, call mounted on self</span></span><br><span class="line">  <span class="comment">// mounted is called for render-created child components in its inserted hook</span></span><br><span class="line">  <span class="keyword">if</span> (vm.$vnode == <span class="literal">null</span>) &#123;</span><br><span class="line">    vm._isMounted = <span class="literal">true</span></span><br><span class="line">    callHook(vm, <span class="string">&#x27;mounted&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看到， <code>beforeMount</code> 之前会先判断是否有 <code>render</code> 属性，如果没有则赋值一个空的 VNode 节点。这里的 <code>render</code> 其实是一定会有的：</p>
<ol>
<li>如果你写的是单文件组件，那 <code>&lt;template&gt;&lt;/template&gt;</code> 会被 <code>vue-loader</code> 编译为 <code>render</code> 函数</li>
<li>如果你提供的是 <code>template</code> 选项，并使用带 compiler 版本的 Vue ，则在 $mount 方法中会进行编译成 <code>render</code> 函数</li>
<li>如果直接写的 <code>render</code> 函数，有 jsx 则会编译成 JavaScript ，这在 Vue 官方文档中是有说明的</li>
</ol>
<p>然后是 <code>new</code> 了一个 <code>Watcher</code> 。这里目前不需要知道里面具体干了什么，只要知道 <code>updateComponent</code> 会马上被调用一次就行了。而 <code>updateComponent</code> 中调用了 <code>_render</code> 跟 <code>_update</code> 方法，之前已经看过，这两个方法分别在 <code>render.js</code> 跟 <code>lifecycle.js</code> 中挂载到 Vue 的原型上了。简单来说，这一步创建了当前实例的 VNode 。</p>
<p>至此， <code>new Vue()</code> 表面可见的工作大致就到这边，剩下的 watch 相关、 vdom 以及其他内容后续再看。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue JSX中组件名大小写的问题</title>
    <url>/2019/05/16/Vue-JSX%E4%B8%AD%E7%BB%84%E4%BB%B6%E5%90%8D%E5%A4%A7%E5%B0%8F%E5%86%99%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="Vue-官方风格指南"><a href="#Vue-官方风格指南" class="headerlink" title="Vue 官方风格指南"></a>Vue 官方风格指南</h1><p>在 Vue 官方的风格指南中，强烈推荐在 JS/JSX 中组件名应该是 PascalCase 的。</p>
<blockquote>
<p>JS/JSX 中的组件名应该始终是 PascalCase 的，尽管在较为简单的应用中只使用 Vue.component 进行全局组件注册时，可以使用 kebab-case 字符串。</p>
</blockquote>
<p>我原以为在 JSX 中组件名都写成 PascalCase 就好了，然而在使用一些 UI 组件库时，在 render 函数中常常会报某个组件未注册的问题。</p>
<p>例如 iView ，在其官方文档的 <a href="https://www.iviewui.com/docs/guide/start">快速上手</a> 章节底下，有个 组件使用规范 ，是这样写的：</p>
<blockquote>
<p>在非 template/render 模式下（例如使用 CDN 引用时），组件名要分隔，例如 DatePicker 必须要写成 date-picker。</p>
</blockquote>
<p>看到这个，我以为这只是这个组件库的规范，于是在报错的时候直接把报错的组件名改成 kebab-case 就好了，也就没再深究。</p>
<p>然而一知半解的下场就是，下次遇到同样的问题，还是会一脸懵逼。</p>
<h1 id="官方示例代码大小写使用情况"><a href="#官方示例代码大小写使用情况" class="headerlink" title="官方示例代码大小写使用情况"></a>官方示例代码大小写使用情况</h1><p>我们看到 Vue 官网解释 <a href="https://cn.vuejs.org/v2/guide/render-function.html#JSX">JSX</a> 的部分有这样一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> AnchoredHeading <span class="keyword">from</span> <span class="string">&#x27;./AnchoredHeading.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#demo&#x27;</span>,</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params">h</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;AnchoredHeading level=&#123;<span class="number">1</span>&#125;&gt;</span><br><span class="line">        &lt;span&gt;Hello&lt;/span&gt; world!</span><br><span class="line">      &lt;/AnchoredHeading&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>其中 JSX 部分就是 PascalCase 。那为什么在 JSX 中使用 iView 组件时却要 kebab-case ？</p>
<p>而且在 iView 的 table 组件示例中，可以看到这样的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">render: <span class="function">(<span class="params">h, params</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, [</span><br><span class="line">        h(<span class="string">&#x27;Button&#x27;</span>, &#123;</span><br><span class="line">            props: &#123;</span><br><span class="line">                type: <span class="string">&#x27;primary&#x27;</span>,</span><br><span class="line">                size: <span class="string">&#x27;small&#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            style: &#123;</span><br><span class="line">                marginRight: <span class="string">&#x27;5px&#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            on: &#123;</span><br><span class="line">                click: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.show(params.index)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&#x27;View&#x27;</span>),</span><br><span class="line">        h(<span class="string">&#x27;Button&#x27;</span>, &#123;</span><br><span class="line">            props: &#123;</span><br><span class="line">                type: <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">                size: <span class="string">&#x27;small&#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            on: &#123;</span><br><span class="line">                click: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.remove(params.index)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&#x27;Delete&#x27;</span>)</span><br><span class="line">    ]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道， JSX 最后也会被解析成 h 函数，那么，其中组件名的大小写一定跟 JSX 的解析有关。</p>
<p>所以，我们来看看 Vue 的 JSX 插件 <a href="https://github.com/vuejs/babel-plugin-transform-vue-jsx">babel-plugin-transform-vue-jsx</a> 怎么说。</p>
<h1 id="来自官方的解释"><a href="#来自官方的解释" class="headerlink" title="来自官方的解释"></a>来自官方的解释</h1><p>在 babel-plugin-transform-vue-jsx 的 github README 中，有一段 Component Tip ：</p>
<blockquote>
<p>If a custom element starts with lowercase, it will be treated as a string id and used to lookup a registered component. If it starts with uppercase, it will be treated as an identifier, which allows you to do:</p>
</blockquote>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Todo <span class="keyword">from</span> <span class="string">&#x27;./Todo.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  render (h) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Todo</span>/&gt;</span></span> <span class="comment">// no need to register Todo via components option</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>意思就是如果自定义元素是小写开头，就会被当做字符串 id ，会从注册的组件中去查找；如果是大写开头，会被当成一个标识符。</p>
<p>什么意思呢？其实说得不是特别直观，我们直接去看看 PascalCase 跟 kebab-case 分别会被转换成什么样就会明白那段解释了。</p>
<h1 id="Babel-Try-it-out"><a href="#Babel-Try-it-out" class="headerlink" title="Babel Try it out"></a>Babel Try it out</h1><p>让我们打开 Babel 官网，点击顶部的 <code>Try it out</code> 。在左侧底部 <code>Add Plugin</code> 把 <code>babel-plugin-transform-vue-jsx</code> 添加进去。</p>
<p>然后输入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="xml"><span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> b = <span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span>&gt;</span><span class="tag">&lt;/<span class="name">MyComponent</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>马上，我们可以在右侧结果中看到：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = h(<span class="string">&quot;my-component&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> b = h(MyComponent);</span><br></pre></td></tr></table></figure>
<p>这下清楚了：</p>
<ol>
<li>kebab-case 组件名解析成 h 函数时会解析成字符串，自然会去看当前组件有没有注册相应的组件，或者去搜索有没有全局注册的组件。</li>
<li>PascalCase 组件名解析成 h 函数时会解析成一个标识符，也就是变量，需要你在当前上下文中就定义或者引入这个变量。</li>
</ol>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>那么，在 Vue JSX 里，组件名什么时候用 PascalCase ，什么时候用 kebab-case ，就很明确了：</p>
<ul>
<li>当组件只在全局注册时，一般是使用了组件库，在入口用了 <code>Vue.use</code> 这类，或者自己用了 <code>Vue.component</code> 注册的组件，这时候没在当前组件引入时，需要用 kebab-case</li>
</ul>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> iView <span class="keyword">from</span> <span class="string">&#x27;iview&#x27;</span></span><br><span class="line"><span class="keyword">import</span> CustomComponent <span class="keyword">from</span> <span class="string">&#x27;./some-local-path&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(iView)</span><br><span class="line">Vue.component(<span class="string">&#x27;CustomComponent&#x27;</span>, CustomComponent)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// MyComponent.vue</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  render (h) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;i-button&gt;&lt;/i-button&gt;</span><br><span class="line">        &lt;tooltip&gt;&lt;/tooltip&gt;</span><br><span class="line">        &lt;custom-component&gt;&lt;/custom-component&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>当组件在当前组件有引入过时，或者在当前组件定义了的组件，可以直接用 PascalCase ，因为这是直接使用的变量。</li>
</ul>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyComponent.vue</span></span><br><span class="line"><span class="keyword">import</span> &#123; Tooltip &#125; <span class="keyword">from</span> <span class="string">&#x27;iview&#x27;</span></span><br><span class="line"><span class="keyword">import</span> CustomComponent <span class="keyword">from</span> <span class="string">&#x27;./some-local-path&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  render (h) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Tooltip&gt;&lt;/Tooltip&gt;</span><br><span class="line">        &lt;CustomComponent&gt;&lt;/CustomComponent&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>jsx</tag>
      </tags>
  </entry>
  <entry>
    <title>回忆杀：JavaScript的继承</title>
    <url>/2019/05/27/%E5%9B%9E%E5%BF%86%E6%9D%80%EF%BC%9AJavaScript%E7%9A%84%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<p>ES6 中的 class 容易让人遗忘 JavaScript 在没有 class 的时候，是用什么骚操作去实现类似其他语言的继承的，因此再梳理一遍。</p>
<h1 id="三年前"><a href="#三年前" class="headerlink" title="三年前"></a>三年前</h1><p>从前从前，老夫写代码还是一把梭，jQuery ，function ，$(document).ready 就是干。</p>
<p>到后来出社会，发现前端的需求一个比一个骚，不能再 $(document).ready 就直接开干了。</p>
<p>由于 JavaScript 这东西是基于原型的，必须通过一些骚操作才能实现一个类似 class 的东西，并且能够继承复用。</p>
<p>那时候对原型和继承的知识的掌握是必不可少的，一入职就要求要学习并输出一篇笔记，本菜鸡之前只是稍微知道有 prototype 这东西，还不明白有这么些操作，赶紧打开 《JavaScript高级程序设计》 （没错，就是这本，虽然很菜但书还是要看高级的）翻到继承那章，稀里糊涂的就记上了一篇笔记，当时应该是似懂非懂，大概懂了的感觉（然而现在已经忘得差不多了）。</p>
<h1 id="原型、构造函数与实例"><a href="#原型、构造函数与实例" class="headerlink" title="原型、构造函数与实例"></a>原型、构造函数与实例</h1><p>由于 JavaScript 是基于原型的，因此我们需要先搞清楚原型是个什么玩意儿。</p>
<p>说起原型，就会想到 prototype ，经常看浏览器控制台的话，还会看到一个 <code>__proto__</code> 。那么这些东西，哪些是原型，其他属性又跟原型有什么关系呢？</p>
<p>首先，原型，就打个不恰当的比方吧，好比一个叫 Fn 的需求过来时给了你一个原型界面，诶，就把这个当成原型。</p>
<p>然后开发仔把这个原型界面用代码实现了一遍，诶，这个实现了的代码，就是构造函数。</p>
<p>代码上线，用户访问这个界面，相当于 new 了一下构造函数，最后每个用户屏幕上的界面，都是一个实例。</p>
<p>好了，脑袋中有这样一个场景，就可以把 JavaScript 原型相关的东西对应上：</p>
<ol>
<li>这个原型界面，就是 <code>Fn.prototype</code></li>
<li>开发仔把这个原型界面实现了，就有了构造函数 <code>Fn</code></li>
<li>用户访问界面，相当于 <code>var f = new Fn()</code> ，这个 <code>f</code> 就是实例</li>
</ol>
<p>现在，需求方听说上线了，打开浏览器访问了这个界面，new 了一个实例出来，发现，哇，跟我给的原型一模一样，这时候，需求方脑袋中的这个印象，就是 <code>__proto__</code> ，从浏览器的界面联系到了原型界面。也就是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">f.__proto__ === Fn.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>这时候，还有一个问题，就是需求方给的原型界面是怎么来的…天知道是怎么来的啊？！嗯？天知道？没错，就是一个叫 Object 的天，这个天，给了需求方一个灵感，作为 Fn 这个需求的原型，这个灵感就是 <code>Object.prototype</code> 。</p>
<p>上天看到了 <code>Fn.prototype</code> ，心想，可以啊，跟我给的灵感一模一样，于是，<code>Fn.prototype</code> 就跟 <code>Object.prototype</code> 联系上了，也就是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Fn.prototype.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>这时候有人就要杠了，那 <code>Object.prototype</code> 又是怎么来的啊？</p>
<p>我们知道，许多神话传说创造世界都是从一片虚空开始的，盘古开天辟地，上帝创世等。诶，懂了没，这个 <code>Object.prototype</code> ，就是从虚空（ <code>null</code> ）来的，它跟虚空之间的联系就是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>扯了这么多，大概只搞懂了原型、构造函数跟实例之间的关系吧：</p>
<ol>
<li>构造函数有个原型对象，就是 <code>Fn.prototype</code> 。</li>
<li>每个实例对象会有个 <code>__proto__</code> 属性指向这个实例的构造函数的原型对象。</li>
</ol>
<h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><p>上面看下来，你会发现 <code>__proto__</code> 这家伙不简单，把原型之间都串起来了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">f.__proto__ === Fn.prototype</span><br><span class="line">Fn.prototype.__proto__ === <span class="built_in">Object</span>.prototype</span><br><span class="line"><span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>这一串，就是原型链。</p>
<p>大概是下面这张图的关系：</p>
<p><img src="/images/posts/prototype.jpg" alt="prototype"></p>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>正片开始。</p>
<p>我们假设有这样两个构造函数：</p>
<p>父亲：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dad</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.kind = <span class="string">&#x27;human&#x27;</span></span><br><span class="line">  <span class="built_in">this</span>.gender = <span class="string">&#x27;male&#x27;</span></span><br><span class="line">  <span class="built_in">this</span>.hobbies = [</span><br><span class="line">    <span class="string">&#x27;coffee&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;tea&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;wife&#x27;</span>,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dad.prototype.breakLeg = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;打断她的腿&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>女儿（别问为什么是女儿）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Daughter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.gender = <span class="string">&#x27;female&#x27;</span></span><br><span class="line">  <span class="built_in">this</span>.boyfriend = <span class="string">&#x27;tan90&#x27;</span></span><br><span class="line">  <span class="built_in">this</span>.hobbies = [</span><br><span class="line">    <span class="string">&#x27;piano&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;chess&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;writing&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;painting&#x27;</span>,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后要实现女儿继承父亲。</p>
<p>对了，为什么要把方法挂在原型对象上呢？这要从 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new">new</a> 这个关键字说起，一个构造函数 Fn 被 new 了，会创建一个继承自 <code>Fn.prototype</code> 的实例对象，因此，每个实例都可以从原型链中找到 <code>Fn.prototype</code> 上的方法，也就是这些方法是实例中共享的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">dad_one.breakLeg === dad_two.breakLeg <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">dad_one.__proto__.breakLeg === dad_two.__proto__.breakLeg <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>而没有挂在原型对象上的则是每个实例独立的属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">dad_one.hobbies === dad_two.hobbies <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>因此我们把实例间需要共享的，一般是方法，挂在构造函数的原型对象上，而其他属性挂在 this 上。</p>
<h2 id="原型链继承法"><a href="#原型链继承法" class="headerlink" title="原型链继承法"></a>原型链继承法</h2><p>所谓原型链继承，就是很粗暴的，直接修改女儿的原型对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Daughter.prototype = <span class="keyword">new</span> Dad()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> daughter = <span class="keyword">new</span> Daughter()</span><br></pre></td></tr></table></figure>
<p>这样继承十分简单，把 Dad 的构造函数内的属性与原型对象上的方法全部挂在 Daughter 的原型对象上。</p>
<p>原型链就变成了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">daughter.__proto__ === Daughter.prototype <span class="comment">// true</span></span><br><span class="line">Daughter.prototype.__proto__ === Dad.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>在使用时，看起来是挺正常的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">daughter <span class="keyword">instanceof</span> Daughter <span class="comment">// true</span></span><br><span class="line">daughter <span class="keyword">instanceof</span> Dad <span class="comment">// true</span></span><br><span class="line">daughter.kind <span class="comment">// &#x27;human&#x27;</span></span><br><span class="line">daughter.gender <span class="comment">// &#x27;female&#x27;</span></span><br><span class="line">daughter.boyfriend <span class="comment">// &#x27;tan90&#x27;</span></span><br></pre></td></tr></table></figure>
<p>但是有个问题，上面得出结论 <code>__proto__</code> 会把实例跟构造函数原型对象联系起来：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">daughter.__proto__.hobbies <span class="comment">// [&quot;coffee&quot;, &quot;tea&quot;, &quot;wife&quot;]</span></span><br></pre></td></tr></table></figure>
<p>这样一来，老爸有什么兴趣就全被女儿知道了，而且是所有子女之间共享的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> daughter_two = <span class="keyword">new</span> Daughter()</span><br><span class="line"></span><br><span class="line">daughter_two.__proto__.hobbies === daughter.__proto__.hobbies <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>这下老爸就慌了，每个人都有各自的兴趣，继承的时候覆盖掉就好了，没必要知根知底了，再说这样多费女儿脑容量（内存），是不？</p>
<h2 id="借用构造函数法"><a href="#借用构造函数法" class="headerlink" title="借用构造函数法"></a>借用构造函数法</h2><p>这个方法需要在构造函数主体内容前面调用父类的构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Daughter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 调用父亲的构造函数</span></span><br><span class="line">  Dad.call(<span class="built_in">this</span>)</span><br><span class="line">  <span class="built_in">this</span>.gender = <span class="string">&#x27;female&#x27;</span></span><br><span class="line">  <span class="built_in">this</span>.boyfriend = <span class="string">&#x27;tan90&#x27;</span></span><br><span class="line">  <span class="built_in">this</span>.hobbies = [</span><br><span class="line">    <span class="string">&#x27;piano&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;chess&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;writing&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;painting&#x27;</span>,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是有点像 <code>super()</code> ？</p>
<p>这跟原型链法是两个极端，原型链继承法把父亲的所有属性都挂在女儿的原型对象上，而借用构造函数则是把父亲所有的属性都挂在构造函数里。</p>
<p>这样的话，女儿就没法继承父亲原型对象上的独门绝技 -&gt; 打断腿 <code>breakLeg</code> 方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> daughter = <span class="keyword">new</span> Daughter()</span><br><span class="line"></span><br><span class="line">daughter.breakLeg <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>那怎么办呢？我们可以把这个独门绝技放到父亲的构造函数中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dad</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.kind = <span class="string">&#x27;human&#x27;</span></span><br><span class="line">  <span class="built_in">this</span>.gender = <span class="string">&#x27;male&#x27;</span></span><br><span class="line">  <span class="built_in">this</span>.hobbies = [</span><br><span class="line">    <span class="string">&#x27;coffee&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;tea&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;wife&#x27;</span>,</span><br><span class="line">  ]</span><br><span class="line">  <span class="built_in">this</span>.breakLeg = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;打断她的腿&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，女儿就可以成功传承独门绝技了。</p>
<p>不过这样做是有个问题的，相信你也看出来了，我们必须把方法都挂到构造函数的 <code>this</code> 上，而且你会发现，女儿学到的打断腿技能，跟父亲的不一样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dad = <span class="keyword">new</span> Dad()</span><br><span class="line"><span class="keyword">const</span> daughter = <span class="keyword">new</span> Daughter()</span><br><span class="line"></span><br><span class="line">dad.breakLeg === daughter.breakLeg <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>那怎么行呢，这继承得不正宗，而且有多少个子女继承父亲，就有多少种打断腿方法，而方法内容都是一样的，我们只需要一个就好，否则十分占用空间，上天看了都头大。</p>
<h2 id="组合继承法"><a href="#组合继承法" class="headerlink" title="组合继承法"></a>组合继承法</h2><p>既然上面两种继承方法走的是两个极端，那我们就不能像小孩子一样做选择了，我全都要！</p>
<p>组合继承法，就是把上面两种方法都组合起来，同时父类的方法还是挂在父亲的原型对象上：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dad</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.kind = <span class="string">&#x27;human&#x27;</span></span><br><span class="line">  <span class="built_in">this</span>.gender = <span class="string">&#x27;male&#x27;</span></span><br><span class="line">  <span class="built_in">this</span>.hobbies = [</span><br><span class="line">    <span class="string">&#x27;coffee&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;tea&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;wife&#x27;</span>,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dad.prototype.breakLeg = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;打断她的腿&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Daughter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 调用父亲的构造函数</span></span><br><span class="line">  Dad.call(<span class="built_in">this</span>)</span><br><span class="line">  <span class="built_in">this</span>.gender = <span class="string">&#x27;female&#x27;</span></span><br><span class="line">  <span class="built_in">this</span>.boyfriend = <span class="string">&#x27;tan90&#x27;</span></span><br><span class="line">  <span class="built_in">this</span>.hobbies = [</span><br><span class="line">    <span class="string">&#x27;piano&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;chess&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;writing&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;painting&#x27;</span>,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承父亲的打断腿技能</span></span><br><span class="line">Daughter.prototype = <span class="keyword">new</span> Dad()</span><br></pre></td></tr></table></figure>
<p>诶，完美结合了原型链继承法与借用构造函数法的优点！</p>
<p>但是！这也完美结合了两者的缺点。</p>
<p>不知你是否发现，<code>Dad</code> 构造函数，总共被调用了两次，而且，跟原型链法的缺点一样，父亲的所有属性、方法，都被挂在了女儿的原型对象上，父亲的那点小爱好，又被女儿知道了。</p>
<h2 id="原型式继承法与寄生式继承法"><a href="#原型式继承法与寄生式继承法" class="headerlink" title="原型式继承法与寄生式继承法"></a>原型式继承法与寄生式继承法</h2><p>这俩的缺点跟原型链继承法与借用构造函数法的缺点类似，在这边就不啰嗦了。</p>
<h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><p>在组合继承中，你可能发现了，我们只要防止父亲构造函数中的内容，被挂在女儿原型对象上，这整个继承的实现就基本上是我们想要的了。</p>
<p>那么，要怎么做呢？看好，骚操作来了。</p>
<p>首先，我们引入一位父亲的分身。这个分身不知道父亲的爱好，但是他清楚父亲所有的技能，在这里就是那个打断腿的技能：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Temp</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Temp.prototype = Dad.prototype</span><br><span class="line"><span class="keyword">const</span> temp = <span class="keyword">new</span> Temp()</span><br></pre></td></tr></table></figure>
<p>现在，这个分身实例 <code>temp</code> 没有属性，只有一个打断腿技能。然后我们只需要让女儿用组合继承法，但是在继承方法时，改为继承这个分身，即可达到我们的目标。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Daughter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 调用父亲的构造函数</span></span><br><span class="line">  Dad.call(<span class="built_in">this</span>)</span><br><span class="line">  <span class="built_in">this</span>.gender = <span class="string">&#x27;female&#x27;</span></span><br><span class="line">  <span class="built_in">this</span>.boyfriend = <span class="string">&#x27;tan90&#x27;</span></span><br><span class="line">  <span class="built_in">this</span>.hobbies = [</span><br><span class="line">    <span class="string">&#x27;piano&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;chess&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;writing&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;painting&#x27;</span>,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承父亲（分身）的打断腿技能</span></span><br><span class="line">temp.constructor = Daughter</span><br><span class="line">Daughter.prototype = temp</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承完成后可以在女儿原型对象上加新的技能</span></span><br><span class="line">Daughter.prototype.sing = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;I can sing.&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> daughter = <span class="keyword">new</span> Daughter()</span><br></pre></td></tr></table></figure>
<p>此时的原型链是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">daughter.__proto__ === Daughter.prototype <span class="comment">// true</span></span><br><span class="line">daughter.__proto__ === temp <span class="comment">// true</span></span><br><span class="line">temp.__proto__ === Temp.prototype <span class="comment">// true</span></span><br><span class="line">temp.__proto__ === Dad.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>temp</code> 的内容（也就是 <code>Daughter.prototype</code> 的内容）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">temp: &#123;</span><br><span class="line">  <span class="title">constructor</span>: <span class="title">Daughter</span>,</span><br><span class="line">  <span class="title">__proto__</span>: &#123;</span><br><span class="line">    <span class="title">constructor</span>: <span class="title">Dad</span>,</span><br><span class="line">    <span class="title">breakLeg</span>: <span class="title">f</span> (<span class="params"></span>),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现我们执行的 <code>temp.constructor = Daughter</code> 给 <code>temp</code> 挂上了一个 constructor ，这样在查找构造函数时，会优先使用 <code>Daughter</code> ，而不是 <code>__proto__</code> 上挂的 <code>Dad</code> 。至于为什么要加上 constructor ，是为了不打破原型链，constructor 本是 prototype ，也就是原型对象上的一个属性。</p>
<p>实际上我们最终还是把方法都挂在了 <code>Daughter.prototype.__proto__</code> 上。</p>
<p>使用寄生组合式继承，我们还是调用了两次构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> temp = <span class="keyword">new</span> Temp()</span><br><span class="line">Dad.call(<span class="built_in">this</span>)</span><br></pre></td></tr></table></figure>
<p>但是分身 <code>temp</code> 的构造函数内容是空的，对整个继承过程没有影响，同时不会把父亲 <code>this</code> 上的爱好等属性挂在女儿原型对象上。</p>
<h3 id="继承方法抽离"><a href="#继承方法抽离" class="headerlink" title="继承方法抽离"></a>继承方法抽离</h3><p>看了一顿骚操作，有什么感受？是不是觉得好麻烦，每次继承都要搞一个 temp 出来。</p>
<p>没关系，我们可以稍微简化一下这个步骤，把创建 temp 的过程封装起来：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createTemp</span> (<span class="params">Dad</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Temp</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  Temp.prototype = Dad.prototype</span><br><span class="line">  <span class="keyword">const</span> temp = <span class="keyword">new</span> Temp()</span><br><span class="line">  <span class="keyword">return</span> temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 <code>createTemp</code> 方法，实际上就是刚刚没讲的原型式继承的方法。而 JavaScript 里，已经有个方法做了上述工作，就是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create">Object.create</a> 。</p>
<p>然后，为了防止我们忘记怎么继承打断腿技能，可以把继承的过程也封装起来，整个继承原型方法的过程就是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span> (<span class="params">Daughter, Dad</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建 temp</span></span><br><span class="line">  <span class="keyword">const</span> temp = createTemp(Dad)</span><br><span class="line">  temp.constructor = Daughter</span><br><span class="line">  Daughter.prototype = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把参数名替换一下，并用 <code>Object.create</code> 方法替换 <code>createTemp</code> 就是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span> (<span class="params">SubClass, SuperClass</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建 temp</span></span><br><span class="line">  <span class="keyword">const</span> temp = <span class="built_in">Object</span>.create(SuperClass.prototype) <span class="comment">// 2019.12.12 修正，Object.create 不会取 prototype ，具体见 MDN 文档 polyfill 部分</span></span><br><span class="line">  temp.constructor = SubClass</span><br><span class="line">  SubClass.prototype = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，JavaScript 继承的回忆就结束了，不知道你对这种基于原型的继承思路有没有稍微清楚一点了呢？</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>以前的文章</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">MDN 继承与原型链</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>记录：如何包裹一个现有的Vue组件</title>
    <url>/2019/06/04/%E8%AE%B0%E5%BD%95%EF%BC%9A%E5%A6%82%E4%BD%95%E5%8C%85%E8%A3%B9%E4%B8%80%E4%B8%AA%E7%8E%B0%E6%9C%89%E7%9A%84Vue%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>有点高阶组件的感觉，把一个组件功能增强或修改组件的一些默认配置，同时外界能像原有组件那样使用新的组件。不过高阶组件是一个函数，而我们是直接写一个新的 Vue 组件，相当于是直接写这个函数的返回值了。</p>
<p>假设有一个 Input 组件，可以使用 v-model ，可以传 Props ，可以触发事件，可以传 Slots （包括 scopedSlots）。<br>但是我们在使用过程中发现，它的配置太自由了，但默认值不是我们想用的，每次使用都要配置一次，而且我们希望旁边能有个按钮，加个搜索功能。</p>
<p>于是我们新建一个 Vue 组件 <code>SearchInput</code></p>
<h1 id="Template"><a href="#Template" class="headerlink" title="Template"></a>Template</h1><p>首先来实现新组件的 DOM 结构：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Input</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;handleSearch&quot;</span>&gt;</span>搜索<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h1><p>然后接收 Input 组件所有的 Props ，甚至你还想加几个 Props 上去：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    &lt;Input</span><br><span class="line">      v-bind=&quot;$attrs&quot;</span><br><span class="line">    /&gt;</span><br><span class="line">    &lt;button</span><br><span class="line">      v-if=&quot;canSearch&quot;</span><br><span class="line">      @click=&quot;handleSearch&quot;</span><br><span class="line">    &gt;搜索<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&#x27;SearchInput&#x27;</span>,</span></span><br><span class="line">  props: &#123;</span><br><span class="line">    canSearch: &#123;</span><br><span class="line"><span class="javascript">      type: <span class="built_in">Boolean</span>,</span></span><br><span class="line"><span class="javascript">      <span class="keyword">default</span>: <span class="literal">true</span>,</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="Events"><a href="#Events" class="headerlink" title="Events"></a>Events</h1><p>使用 $listeners 把监听器都挂 Input 上：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    &lt;Input</span><br><span class="line">      v-bind=&quot;$attrs&quot;</span><br><span class="line">      v-on=&quot;$listeners&quot;</span><br><span class="line">    /&gt;</span><br><span class="line">    &lt;button</span><br><span class="line">      v-if=&quot;canSearch&quot;</span><br><span class="line">      @click=&quot;handleSearch&quot;</span><br><span class="line">    &gt;搜索<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&#x27;SearchInput&#x27;</span>,</span></span><br><span class="line">  props: &#123;</span><br><span class="line">    canSearch: &#123;</span><br><span class="line"><span class="javascript">      type: <span class="built_in">Boolean</span>,</span></span><br><span class="line"><span class="javascript">      <span class="keyword">default</span>: <span class="literal">true</span>,</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleSearch () &#123;</span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$emit(<span class="string">&#x27;search&#x27;</span>)</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>也可以在 <code>v-on</code> 上绑定一个 computed ，对 <code>$listeners</code> 做手脚。</p>
<h1 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h1><p>Vue 版本 2.6.2 以后直接</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">v-bind=<span class="string">&quot;$attrs&quot;</span></span><br><span class="line">v-on=<span class="string">&quot;$listeners&quot;</span></span><br></pre></td></tr></table></figure>
<p>一般就可以实现 <code>v-model</code> 了，涉及原生的可能需要重写 input 事件监听器。</p>
<p>2.6.2 以前的版本有个 issue <a href="https://github.com/vuejs/vue/issues/8430">#8430</a> ，在外部使用 v-model 不会把 value prop 传入 $attrs 中，因此需要手动声明 value prop 兼容：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    &lt;Input</span><br><span class="line">      :value=&quot;value&quot;</span><br><span class="line">      v-bind=&quot;$attrs&quot;</span><br><span class="line">      v-on=&quot;$listeners&quot;</span><br><span class="line">    /&gt;</span><br><span class="line">    &lt;button</span><br><span class="line">      v-if=&quot;canSearch&quot;</span><br><span class="line">      @click=&quot;handleSearch&quot;</span><br><span class="line">    &gt;搜索<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&#x27;SearchInput&#x27;</span>,</span></span><br><span class="line">  props: &#123;</span><br><span class="line">    value: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">    canSearch: &#123;</span><br><span class="line"><span class="javascript">      type: <span class="built_in">Boolean</span>,</span></span><br><span class="line"><span class="javascript">      <span class="keyword">default</span>: <span class="literal">true</span>,</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleSearch () &#123;</span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$emit(<span class="string">&#x27;search&#x27;</span>)</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="Slots"><a href="#Slots" class="headerlink" title="Slots"></a>Slots</h1><p>在 Vue 2.6 以后推出了新语法 <code>v-slot</code> ，因此我们可以这样传入所有 slots ：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    &lt;Input</span><br><span class="line">      :value=&quot;value&quot;</span><br><span class="line">      v-bind=&quot;$attrs&quot;</span><br><span class="line">      v-on=&quot;$listeners&quot;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;template</span><br><span class="line">        v-for=&quot;(_, slotName) in $scopedSlots&quot;</span><br><span class="line">        v-slot:[slotName]=&quot;slotProps&quot;</span><br><span class="line">      &gt;</span><br><span class="line">        &lt;slot</span><br><span class="line">          :name=&quot;slotName&quot;</span><br><span class="line">          v-bind=&quot;slotProps&quot;</span><br><span class="line">        &gt;<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Input</span>&gt;</span></span><br><span class="line">    &lt;button</span><br><span class="line">      v-if=&quot;canSearch&quot;</span><br><span class="line">      @click=&quot;handleSearch&quot;</span><br><span class="line">    &gt;搜索<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&#x27;SearchInput&#x27;</span>,</span></span><br><span class="line">  props: &#123;</span><br><span class="line">    value: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">    canSearch: &#123;</span><br><span class="line"><span class="javascript">      type: <span class="built_in">Boolean</span>,</span></span><br><span class="line"><span class="javascript">      <span class="keyword">default</span>: <span class="literal">true</span>,</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleSearch () &#123;</span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$emit(<span class="string">&#x27;search&#x27;</span>)</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>（在此吐槽一句，新语法就意味着新坑）</p>
<p>2.6 以下的，老样子，把 $slots, $scopedSlots 分别传入：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    &lt;Input</span><br><span class="line">      :value=&quot;value&quot;</span><br><span class="line">      v-bind=&quot;$attrs&quot;</span><br><span class="line">      v-on=&quot;$listeners&quot;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;slot</span><br><span class="line">        v-for=&quot;(_, slotName) in $slots&quot;</span><br><span class="line">        :name=&quot;slotName&quot;</span><br><span class="line">        :slot=&quot;slotName&quot;</span><br><span class="line">      &gt;<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">      &lt;template</span><br><span class="line">        v-for=&quot;(_, slotName) in $scopedSlots&quot;</span><br><span class="line">        :slot=&quot;slotName&quot;</span><br><span class="line">        slot-scope=&quot;slotProps&quot;</span><br><span class="line">      &gt;</span><br><span class="line">        &lt;slot</span><br><span class="line">          :name=&quot;slotName&quot;</span><br><span class="line">          v-bind=&quot;slotProps&quot;</span><br><span class="line">        &gt;<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Input</span>&gt;</span></span><br><span class="line">    &lt;button</span><br><span class="line">      v-if=&quot;canSearch&quot;</span><br><span class="line">      @click=&quot;handleSearch&quot;</span><br><span class="line">    &gt;搜索<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&#x27;SearchInput&#x27;</span>,</span></span><br><span class="line">  props: &#123;</span><br><span class="line">    value: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">    canSearch: &#123;</span><br><span class="line"><span class="javascript">      type: <span class="built_in">Boolean</span>,</span></span><br><span class="line"><span class="javascript">      <span class="keyword">default</span>: <span class="literal">true</span>,</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleSearch () &#123;</span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$emit(<span class="string">&#x27;search&#x27;</span>)</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>至此就完成了包裹。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue响应式之data</title>
    <url>/2019/06/05/Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E4%B9%8Bdata/</url>
    <content><![CDATA[<h1 id="data-初始化时都做了什么"><a href="#data-初始化时都做了什么" class="headerlink" title="data 初始化时都做了什么"></a>data 初始化时都做了什么</h1><p>假设我们有这么一个 Vue 组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; foo &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&#x27;App&#x27;</span>,</span></span><br><span class="line">  data () &#123;</span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      foo: <span class="string">&#x27;bar&#x27;</span>,</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>那么这个 <code>foo</code> 是怎么被 Vue 监听的呢？</p>
<p>我们定位一下 <code>src/core/instance/state.js</code> 文件，找到 <code>initData</code> 方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initData</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = vm.$options.data</span><br><span class="line">  <span class="comment">// ...省略部分代码</span></span><br><span class="line">  <span class="comment">// observe data</span></span><br><span class="line">  observe(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在方法末尾，可以看到 <code>observe</code> 方法，跳转到这个方法 <code>src/core/observer/index.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observe</span> (<span class="params">value: any, asRootData: ?boolean</span>): <span class="title">Observer</span> | <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(value) || value <span class="keyword">instanceof</span> VNode) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> ob: Observer | <span class="keyword">void</span></span><br><span class="line">  <span class="keyword">if</span> (hasOwn(value, <span class="string">&#x27;__ob__&#x27;</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer) &#123;</span><br><span class="line">    ob = value.__ob__</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    shouldObserve &amp;&amp;</span><br><span class="line">    !isServerRendering() &amp;&amp;</span><br><span class="line">    (<span class="built_in">Array</span>.isArray(value) || isPlainObject(value)) &amp;&amp;</span><br><span class="line">    <span class="built_in">Object</span>.isExtensible(value) &amp;&amp;</span><br><span class="line">    !value._isVue</span><br><span class="line">  ) &#123;</span><br><span class="line">    ob = <span class="keyword">new</span> Observer(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (asRootData &amp;&amp; ob) &#123;</span><br><span class="line">    ob.vmCount++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ob</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这步重点是 <code>new Observer</code> ，最终会返回一个 <code>Observer</code> 的实例。</p>
<p>跳转到同一个文件的 <code>Observer</code> 类：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  value: any;</span><br><span class="line">  dep: Dep;</span><br><span class="line">  vmCount: number; <span class="comment">// number of vms that have this object as root $data</span></span><br><span class="line"></span><br><span class="line">  <span class="title">constructor</span> (<span class="params">value: any</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line">    <span class="built_in">this</span>.dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="built_in">this</span>.vmCount = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 在对象上定义一个 `__ob__` 属性</span></span><br><span class="line">    def(value, <span class="string">&#x27;__ob__&#x27;</span>, <span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasProto) &#123;</span><br><span class="line">        protoAugment(value, arrayMethods)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        copyAugment(value, arrayMethods, arrayKeys)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.observeArray(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 对 data 上的每一个属性都执行 `defineReactive`</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  walk (obj: <span class="built_in">Object</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">      defineReactive(obj, keys[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Observe a list of Array items.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  observeArray (items: <span class="built_in">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">      observe(items[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着，我们来看还是同一个文件下的 <code>defineReactive</code> ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  obj: <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  val: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  customSetter?: ?<span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  shallow?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用了 Object.freeze 就无法响应的原因</span></span><br><span class="line">  <span class="keyword">const</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key)</span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// cater for pre-defined getter/setters</span></span><br><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.get</span><br><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.set</span><br><span class="line">  <span class="keyword">if</span> ((!getter || setter) &amp;&amp; <span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span><br><span class="line">    val = obj[key]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val)</span><br><span class="line">  <span class="comment">// 定义 getter 跟 setter</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 尝试调用自身 getter ，如果没有直接返回 value</span></span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dep.depend()</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          childOb.dep.depend()</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">            dependArray(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="comment">/* eslint-disable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* eslint-enable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">        customSetter()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// #7981: for accessor properties without setter</span></span><br><span class="line">      <span class="keyword">if</span> (getter &amp;&amp; !setter) <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看看这方法的名字，defineReactive ，肯定就是定义数据响应的地方了。</p>
<p>首先，我们看到：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这么一个判断，所以，这也是你用了 <code>Object.freeze</code> 后就能防止数据被监听的原因。</p>
<p>接下来我们可以看到里面来了一手 <code>Object.defineProperty</code> ，这里面给每个属性都定义了 <code>getter/setter</code> ，这也就是你在 console 打印 data 时会有很多 get set 的原因：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$vm0.$data</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  foo: &#x27;bar&#x27;</span></span><br><span class="line"><span class="comment">  __ob__: &#123;...&#125;</span></span><br><span class="line"><span class="comment">  get foo: ƒ reactiveGetter()</span></span><br><span class="line"><span class="comment">  set foo: ƒ reactiveSetter(newVal)</span></span><br><span class="line"><span class="comment">  __proto__</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>我们发现，在 getter 中，除了调用自身 getter 之外，主要还执行了 <code>dep.depend()</code> ，这时候就要看看这个 <code>Dep</code> 类是何方神圣了。</p>
<p>在 <code>src/core/observer/dep</code> 中找到 <code>Dep</code> 类：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A dep is an observable that can have multiple</span></span><br><span class="line"><span class="comment"> * directives subscribing to it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> target: ?Watcher;</span><br><span class="line">  id: number;</span><br><span class="line">  subs: <span class="built_in">Array</span>&lt;Watcher&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.id = uid++</span><br><span class="line">    <span class="built_in">this</span>.subs = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addSub (sub: Watcher) &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  removeSub (sub: Watcher) &#123;</span><br><span class="line">    remove(<span class="built_in">this</span>.subs, sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  depend () &#123;</span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">      Dep.target.addDep(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="comment">// stabilize the subscriber list first</span></span><br><span class="line">    <span class="keyword">const</span> subs = <span class="built_in">this</span>.subs.slice()</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !config.async) &#123;</span><br><span class="line">      <span class="comment">// subs aren&#x27;t sorted in scheduler if not running async</span></span><br><span class="line">      <span class="comment">// we need to sort them now to make sure they fire in correct</span></span><br><span class="line">      <span class="comment">// order</span></span><br><span class="line">      subs.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.id - b.id)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个类中，需要特别注意两个地方：</p>
<ol>
<li><code>Dep.target</code> 是一个 <code>Watcher</code> 实例</li>
<li><code>subs</code> 是 <code>Watcher</code> 实例的数组，而在 <code>notify</code> 方法中，调用了每个实例的 <code>update</code> 方法</li>
</ol>
<p>看到这里，你脑海里是不是有个名词一直在晃来晃去的？这…不是有点像那个发布订阅模式吗？诶，不过我不是很了解发布订阅模式，没关系，我们慢慢看下去。</p>
<p>这时候，我们应该已经有个场景了：</p>
<ol>
<li>数据变化会调用 <code>dep.notify</code></li>
<li><code>dep.notify</code> 会调用 <code>watcher.update</code></li>
</ol>
<p>那还有个问题，就是 watcher 是怎么进入 <code>dep.subs</code> 列表的？也就是 watcher 是怎么订阅的。</p>
<p>由于我有稍微搜了一下代码，在这里我们就先不看 Watcher 类，而是先转到 <code>$mount</code> 方法：</p>
<p>我们可以找到 <code>mountComponent</code> 方法，在里面，有一段实例化 Watcher 的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Watcher(vm, updateComponent, noop, &#123;</span><br><span class="line">  before () &#123;</span><br><span class="line">    <span class="keyword">if</span> (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123;</span><br><span class="line">      callHook(vm, <span class="string">&#x27;beforeUpdate&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</span><br></pre></td></tr></table></figure>
<p>了解到这个，我们再去看 Watcher ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...省略部分代码</span></span><br><span class="line">    <span class="comment">// parse expression for getter</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.getter = expOrFn</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.getter = parsePath(expOrFn)</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.getter) &#123;</span><br><span class="line">        <span class="built_in">this</span>.getter = noop</span><br><span class="line">        process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; warn(</span><br><span class="line">          <span class="string">`Failed watching path: &quot;<span class="subst">$&#123;expOrFn&#125;</span>&quot; `</span> +</span><br><span class="line">          <span class="string">&#x27;Watcher only accepts simple dot-delimited paths. &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;For full control, use a function instead.&#x27;</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="built_in">this</span>.lazy</span><br><span class="line">      ? <span class="literal">undefined</span></span><br><span class="line">      : <span class="built_in">this</span>.get()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get () &#123;</span><br><span class="line">    pushTarget(<span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">let</span> value</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="built_in">this</span>.vm</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      value = <span class="built_in">this</span>.getter.call(vm, vm)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.user) &#123;</span><br><span class="line">        handleError(e, vm, <span class="string">`getter for watcher &quot;<span class="subst">$&#123;<span class="built_in">this</span>.expression&#125;</span>&quot;`</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> e</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// &quot;touch&quot; every property so they are all tracked as</span></span><br><span class="line">      <span class="comment">// dependencies for deep watching</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.deep) &#123;</span><br><span class="line">        traverse(value)</span><br><span class="line">      &#125;</span><br><span class="line">      popTarget()</span><br><span class="line">      <span class="built_in">this</span>.cleanupDeps()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  update () &#123;</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.lazy) &#123;</span><br><span class="line">      <span class="built_in">this</span>.dirty = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.sync) &#123;</span><br><span class="line">      <span class="built_in">this</span>.run()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      queueWatcher(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.active) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = <span class="built_in">this</span>.get()</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        value !== <span class="built_in">this</span>.value ||</span><br><span class="line">        <span class="comment">// Deep watchers and watchers on Object/Arrays should fire even</span></span><br><span class="line">        <span class="comment">// when the value is the same, because the value may</span></span><br><span class="line">        <span class="comment">// have mutated.</span></span><br><span class="line">        isObject(value) ||</span><br><span class="line">        <span class="built_in">this</span>.deep</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// set new value</span></span><br><span class="line">        <span class="keyword">const</span> oldValue = <span class="built_in">this</span>.value</span><br><span class="line">        <span class="built_in">this</span>.value = value</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.user) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.cb.call(<span class="built_in">this</span>.vm, value, oldValue)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            handleError(e, <span class="built_in">this</span>.vm, <span class="string">`callback for watcher &quot;<span class="subst">$&#123;<span class="built_in">this</span>.expression&#125;</span>&quot;`</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.cb.call(<span class="built_in">this</span>.vm, value, oldValue)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，实例化后马上执行了 <code>get</code> （不是 lazy 的时候），而在 get 中，执行了 <code>this.getter</code> ，这个则是 <code>mountComponent</code> 中定义的 <code>updateComponent</code> 方法，在这个方法中，执行了 <code>_render</code> ，那么，如果在模板中有用到 data 的话，则会去执行 <code>defineReactive</code> 中的 getter ，例如：</p>
<p>在最开始的例子中，我们的模板是这样的：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; foo &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里用到了 <code>foo</code> 。于是会执行 foo 上的 getter ，里面有个 <code>dep.depend()</code> 再加上 <code>watcher.get</code> 的时候执行了 <code>pushTarget(this)</code> ，因此此时 <code>Dep.target</code> 指向的就是 <code>mountComponent</code> 中的 <code>new Watcher</code> 。这一连串操作成功将这个 watcher 添加到 <code>dep.subs</code> 列表中，以后每次 <code>foo</code> 改变，都会调用 <code>dep.notify</code> 具体执行下去，就是每次都会调用 <code>updateComponent</code> ，从而达到更新 DOM 上 <code>foo</code> 的值的效果，也就是实现了一个响应式的过程。</p>
<h1 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h1><p><img src="/images/posts/vue-data-reactive.jpg" alt="process"></p>
<p>经历 ①②③ 步骤收集依赖到 watcher 后，每次 data 改变，都会执行 ④⑤⑥ 步骤，从而实现响应。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue响应式之computed</title>
    <url>/2019/06/10/Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E4%B9%8Bcomputed/</url>
    <content><![CDATA[<h1 id="关于-Props"><a href="#关于-Props" class="headerlink" title="关于 Props"></a>关于 Props</h1><p>props 的处理与 data 类似，因此不再单独水一篇。</p>
<h1 id="需要弄清的问题"><a href="#需要弄清的问题" class="headerlink" title="需要弄清的问题"></a>需要弄清的问题</h1><p>相信看过 Vue 文档的你，在看到计算属性那一章节时，一定会对一句话产生疑问：</p>
<blockquote>
<p>计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。</p>
</blockquote>
<p>为什么？怎么做到依赖改变时才重新求值的？</p>
<p>整理出来就是：</p>
<ol>
<li>computed 一般我们写成一个函数，为何可以像一个属性一样去使用它。</li>
<li>computed 是如何做到相关响应式依赖改变时才去重新计算求值的。</li>
</ol>
<p>我们还是先假设一个组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; foo &#125;&#125;</span><br><span class="line">    &#123;&#123; testComputed &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&#x27;App&#x27;</span>,</span></span><br><span class="line">  data () &#123;</span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      foo: <span class="string">&#x27;bar&#x27;</span>,</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    testComputed () &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="built_in">this</span>.foo</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="computed-初始化时都发生了什么"><a href="#computed-初始化时都发生了什么" class="headerlink" title="computed 初始化时都发生了什么"></a>computed 初始化时都发生了什么</h1><p>我们还是从 <code>initComputed</code> 开始看起：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> computedWatcherOptions = &#123; <span class="attr">lazy</span>: <span class="literal">true</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initComputed</span> (<span class="params">vm: Component, computed: <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...省略部分代码</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> computed) &#123;</span><br><span class="line">    <span class="keyword">const</span> userDef = computed[key]</span><br><span class="line">    <span class="keyword">const</span> getter = <span class="keyword">typeof</span> userDef === <span class="string">&#x27;function&#x27;</span> ? userDef : userDef.get</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; getter == <span class="literal">null</span>) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">`Getter is missing for computed property &quot;<span class="subst">$&#123;key&#125;</span>&quot;.`</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isSSR) &#123;</span><br><span class="line">      <span class="comment">// create internal watcher for the computed property.</span></span><br><span class="line">      watchers[key] = <span class="keyword">new</span> Watcher(</span><br><span class="line">        vm,</span><br><span class="line">        getter || noop,</span><br><span class="line">        noop,</span><br><span class="line">        computedWatcherOptions</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">      defineComputed(vm, key, userDef)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// ...省略部分代码</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>initComputed</code> 中主要是 new 了一个 Watcher ，然后执行了 <code>defineComputed</code> 。</p>
<p>在看这个 Watcher 之前，先注意一下这行代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getter = <span class="keyword">typeof</span> userDef === <span class="string">&#x27;function&#x27;</span> ? userDef : userDef.get</span><br></pre></td></tr></table></figure>
<p>除了定义一个 computed 为函数，我们也可以直接定义其 getter/setter ，也就是说，当我们定义为函数时，其实是定义了这个 computed 的 getter ，这也就解释了第一个疑问。</p>
<h2 id="new-Watcher"><a href="#new-Watcher" class="headerlink" title="new Watcher"></a>new Watcher</h2><p><code>initComputed</code> 实例化了一个 Watcher 对象，不过这个 Watcher 跟 <code>$mount</code> 时的 Watcher 有点不一样，computed 的 Watcher 传入了 <code>&#123; lazy: true &#125;</code> 选项，这就导致实例化后不会马上执行其 getter ，也就是依赖不会马上被这个 watcher 收集到，那么收集依赖的过程应该是下一步，<code>defineComputed</code> 中进行了。</p>
<h2 id="defineComputed"><a href="#defineComputed" class="headerlink" title="defineComputed"></a>defineComputed</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sharedPropertyDefinition = &#123;</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  get: noop,</span><br><span class="line">  set: noop</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineComputed</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  target: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  userDef: <span class="built_in">Object</span> | <span class="built_in">Function</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> shouldCache = !isServerRendering()</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> userDef === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    sharedPropertyDefinition.get = shouldCache</span><br><span class="line">      ? createComputedGetter(key)</span><br><span class="line">      : createGetterInvoker(userDef)</span><br><span class="line">    sharedPropertyDefinition.set = noop</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sharedPropertyDefinition.get = userDef.get</span><br><span class="line">      ? shouldCache &amp;&amp; userDef.cache !== <span class="literal">false</span></span><br><span class="line">        ? createComputedGetter(key)</span><br><span class="line">        : createGetterInvoker(userDef.get)</span><br><span class="line">      : noop</span><br><span class="line">    sharedPropertyDefinition.set = userDef.set || noop</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...省略部分代码</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, key, sharedPropertyDefinition)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个函数中，最后在 vm 上定义了对应 computed ，而 getter ，在不是 SSR 的情况下是用 <code>createComputedGetter(key)</code> 来代替。</p>
<p>我们来看看 <code>createComputedGetter</code> 函数做了什么：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComputedGetter</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">computedGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> watcher = <span class="built_in">this</span>._computedWatchers &amp;&amp; <span class="built_in">this</span>._computedWatchers[key]</span><br><span class="line">    <span class="keyword">if</span> (watcher) &#123;</span><br><span class="line">      <span class="keyword">if</span> (watcher.dirty) &#123;</span><br><span class="line">        watcher.evaluate()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        watcher.depend()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> watcher.value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看了这段好像看不出什么端倪，让我们从 <code>watcher.evaluate</code> 看起。</p>
<p>首先，watcher.dirty 是为 <code>true</code> 的，因为在 Watcher 中初始化时 watcher.dirty 是赋了 watcher.lazy 的值。</p>
<p>所以，如果有在模板中用到 computed ，则一开始就会进行一次 <code>evaluate</code> ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">evaluate () &#123;</span><br><span class="line">  <span class="built_in">this</span>.value = <span class="built_in">this</span>.get()</span><br><span class="line">  <span class="built_in">this</span>.dirty = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在重新评估 computed 值的过程中，会执行 <code>watcher.get</code> ，而在 get 函数中，会尝试去执行 getter ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  value = <span class="built_in">this</span>.getter.call(vm, vm)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是我们所定义的函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">testComputed () &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.foo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我们所定义的 getter 里，引用了 <code>this.foo</code> ，因此会去执行 <code>this.foo</code> 的 getter 。</p>
<p>在之前阅读 data 响应式时了解到，Vue 重写了 data 的 getter/setter ，其中，在 getter 中有这么一段：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">  dep.depend()</span><br><span class="line">  <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">    childOb.dep.depend()</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      dependArray(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>this.foo</code> 的 getter 中会执行 <code>dep.depend()</code> ，也就是会向 <code>this.testComputed</code> 的 watcher 中添加 <code>this.foo</code> 的 <code>dep</code> 依赖。</p>
<p>因此，在 <code>this.foo</code> 改变时，会调用 <code>this.testComputed</code> 的 watcher 的 <code>update</code> 方法，具体就是把 <code>dirty</code> 置为 <code>true</code> ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">update () &#123;</span><br><span class="line">  <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.lazy) &#123;</span><br><span class="line">    <span class="built_in">this</span>.dirty = <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.sync) &#123;</span><br><span class="line">    <span class="built_in">this</span>.run()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    queueWatcher(<span class="built_in">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，在 render 的过程中，执行 <code>this.testComputed</code> 的 getter ，也就是 <code>computedGetter</code> ，由于 <code>dirty === true</code> ，会重新执行一次 <code>evaluate</code> 。</p>
<p>如此，便达到了响应式依赖改变时才重新计算值，而不会重复计算的效果。</p>
<h1 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h1><p><img src="/images/posts/vue-computed-reactive.jpg" alt="process"></p>
<p>初始化时，按照 ①②③④ 步骤执行。<br>而当 foo 改变时，则会执行 <code>dep.notify</code> ：</p>
<ol>
<li>通知 computed Watcher 把 <code>dirty</code> 置为 <code>true</code></li>
<li>通知 <code>$mount</code> 时的 Watcher 执行 <code>updateComponent</code> 函数进行渲染，即执行 ③④ 步骤</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue响应式之watch</title>
    <url>/2019/06/11/Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E4%B9%8Bwatch/</url>
    <content><![CDATA[<h1 id="需要弄清的问题"><a href="#需要弄清的问题" class="headerlink" title="需要弄清的问题"></a>需要弄清的问题</h1><p>关于 watch ，一般有两个疑问：</p>
<ol>
<li>怎么做到监听的属性改变时调用 handler 的</li>
<li>deep 是怎么实现的</li>
</ol>
<p>假设有如下组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; foo &#125;&#125;</span><br><span class="line">    &#123;&#123; testComputed &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&#x27;App&#x27;</span>,</span></span><br><span class="line">  data () &#123;</span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      foo: <span class="string">&#x27;bar&#x27;</span>,</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    testComputed () &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="built_in">this</span>.foo</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    foo (newVal, oldVal) &#123;</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(newVal)</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(oldVal)</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="从-initWatch-看起"><a href="#从-initWatch-看起" class="headerlink" title="从 initWatch 看起"></a>从 initWatch 看起</h1><p>老样子，还是从 <code>initWatch</code> 看起：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initWatch</span> (<span class="params">vm: Component, watch: <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> watch) &#123;</span><br><span class="line">    <span class="keyword">const</span> handler = watch[key]</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(handler)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; handler.length; i++) &#123;</span><br><span class="line">        createWatcher(vm, key, handler[i])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      createWatcher(vm, key, handler)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跳转到 <code>createWatcher</code> ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWatcher</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vm: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  expOrFn: string | <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  handler: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  options?: <span class="built_in">Object</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isPlainObject(handler)) &#123;</span><br><span class="line">    options = handler</span><br><span class="line">    handler = handler.handler</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> handler === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    handler = vm[handler]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm.$watch(expOrFn, handler, options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到最后调用了 <code>$watch</code> 方法，这个方法在官网有介绍，在 <code>stateMixin</code> 阶段被添加到了 <code>Vue.prototype</code> 上。我们找到这个 <code>$watch</code> 方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.prototype.$watch = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    expOrFn: string | <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    cb: any,</span></span></span><br><span class="line"><span class="function"><span class="params">    options?: <span class="built_in">Object</span></span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">if</span> (isPlainObject(cb)) &#123;</span><br><span class="line">    <span class="keyword">return</span> createWatcher(vm, expOrFn, cb, options)</span><br><span class="line">  &#125;</span><br><span class="line">  options = options || &#123;&#125;</span><br><span class="line">  options.user = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">const</span> watcher = <span class="keyword">new</span> Watcher(vm, expOrFn, cb, options)</span><br><span class="line">  <span class="keyword">if</span> (options.immediate) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      cb.call(vm, watcher.value)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      handleError(error, vm, <span class="string">`callback for immediate watcher &quot;<span class="subst">$&#123;watcher.expression&#125;</span>&quot;`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unwatchFn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    watcher.teardown()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在 <code>$watch</code> 里，new 了一个 Watcher ，并返回了一个 <code>unwatchFn</code> ，用来取消订阅所有的依赖。</p>
<p>接下来我们再来看看 Watcher 的构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span></span><br><span class="line"><span class="params">    vm: Component,</span></span><br><span class="line"><span class="params">    expOrFn: string | <span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params">    cb: <span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params">    options?: ?<span class="built_in">Object</span>,</span></span><br><span class="line"><span class="params">    isRenderWatcher?: boolean</span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="comment">// ...省略部分代码</span></span><br><span class="line">    <span class="comment">// parse expression for getter</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.getter = expOrFn</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.getter = parsePath(expOrFn)</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.getter) &#123;</span><br><span class="line">        <span class="built_in">this</span>.getter = noop</span><br><span class="line">        process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; warn(</span><br><span class="line">          <span class="string">`Failed watching path: &quot;<span class="subst">$&#123;expOrFn&#125;</span>&quot; `</span> +</span><br><span class="line">          <span class="string">&#x27;Watcher only accepts simple dot-delimited paths. &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;For full control, use a function instead.&#x27;</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="built_in">this</span>.lazy</span><br><span class="line">      ? <span class="literal">undefined</span></span><br><span class="line">      : <span class="built_in">this</span>.get()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，如果 Watcher 监听的是一个表达式，则在构造函数内会赋值一个解析路径的函数作为 getter 。</p>
<p>然后调用了 <code>get</code> 方法。在 <code>get</code> 中，调用了 getter ，也就是在构造函数中赋值的 <code>parsePath(expOrFn)</code> ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bailRE = <span class="regexp">/[^\w.$]/</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">parsePath</span> (<span class="params">path: string</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (bailRE.test(path)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> segments = path.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; segments.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!obj) <span class="keyword">return</span></span><br><span class="line">      obj = obj[segments[i]]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而 <code>parsePath</code> 返回的函数，只是做了读取相应表达式属性的操作，按上述示例，也就是调用了 <code>foo</code> 的 getter 。</p>
<p>根据之前 <code>initData</code> 时执行的 <code>defineReactive</code> ，会将 <code>foo</code> 对应的 dep 依赖添加到当前的 watcher 中，这样，在 <code>foo</code> 改变时，就会调用 <code>dep.notify</code> ，既而调用当前 watcher 的 <code>watcher.update</code> 方法，而在 <code>update</code> 中，最终调用了 <code>run</code> ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Subscriber interface.</span></span><br><span class="line"><span class="comment">  * Will be called when a dependency changes.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">update () &#123;</span><br><span class="line">  <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.lazy) &#123;</span><br><span class="line">    <span class="built_in">this</span>.dirty = <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.sync) &#123;</span><br><span class="line">    <span class="built_in">this</span>.run()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    queueWatcher(<span class="built_in">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Scheduler job interface.</span></span><br><span class="line"><span class="comment">  * Will be called by the scheduler.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">run () &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.active) &#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="built_in">this</span>.get()</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      value !== <span class="built_in">this</span>.value ||</span><br><span class="line">      <span class="comment">// Deep watchers and watchers on Object/Arrays should fire even</span></span><br><span class="line">      <span class="comment">// when the value is the same, because the value may</span></span><br><span class="line">      <span class="comment">// have mutated.</span></span><br><span class="line">      isObject(value) ||</span><br><span class="line">      <span class="built_in">this</span>.deep</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// set new value</span></span><br><span class="line">      <span class="keyword">const</span> oldValue = <span class="built_in">this</span>.value</span><br><span class="line">      <span class="built_in">this</span>.value = value</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.user) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.cb.call(<span class="built_in">this</span>.vm, value, oldValue)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          handleError(e, <span class="built_in">this</span>.vm, <span class="string">`callback for watcher &quot;<span class="subst">$&#123;<span class="built_in">this</span>.expression&#125;</span>&quot;`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cb.call(<span class="built_in">this</span>.vm, value, oldValue)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在 <code>run</code> 方法中，调用了 <code>cb</code> ，也就是用户定义的 <code>handler</code> 。</p>
<p>至此，就解决了第一个疑问。</p>
<h1 id="deep-是如何实现的"><a href="#deep-是如何实现的" class="headerlink" title="deep 是如何实现的"></a>deep 是如何实现的</h1><p>有关于 deep 选项，我们在 Watcher 中搜索，可以在 <code>get</code> 方法中找到：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">get () &#123;</span><br><span class="line">  pushTarget(<span class="built_in">this</span>)</span><br><span class="line">  <span class="keyword">let</span> value</span><br><span class="line">  <span class="keyword">const</span> vm = <span class="built_in">this</span>.vm</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    value = <span class="built_in">this</span>.getter.call(vm, vm)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.user) &#123;</span><br><span class="line">      handleError(e, vm, <span class="string">`getter for watcher &quot;<span class="subst">$&#123;<span class="built_in">this</span>.expression&#125;</span>&quot;`</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> e</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// &quot;touch&quot; every property so they are all tracked as</span></span><br><span class="line">    <span class="comment">// dependencies for deep watching</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.deep) &#123;</span><br><span class="line">      traverse(value)</span><br><span class="line">    &#125;</span><br><span class="line">    popTarget()</span><br><span class="line">    <span class="built_in">this</span>.cleanupDeps()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.deep) &#123;</span><br><span class="line">  traverse(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于 <code>traverse</code> 就不具体去看了，大致就是把 <code>value</code> 都过一遍，把深层的 dep 都添加到当前 watcher 中去。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>记录：TypeScript模块作用域</title>
    <url>/2019/08/01/%E8%AE%B0%E5%BD%95%EF%BC%9ATypeScript%E6%A8%A1%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在使用 TypeScript 时，有些场景可能需要定义一些全局变量，或者是在 <code>window</code> 对象底下挂一些全局变量（这两种全局变量在 TypeScript 中略有不同），这时候我们可能会在项目 src 中自己手写一些 <code>.d.ts</code> 文件。</p>
<p>但是这个全局变量要怎么写？</p>
<p>TypeScript <a href="https://www.typescriptlang.org/docs/handbook/modules.html">官方文档</a> 里有这么一段话：</p>
<blockquote>
<p>In TypeScript, just as in ECMAScript 2015, any file containing a top-level import or export is considered a module. Conversely, a file without any top-level import or export declarations is treated as a script whose contents are available in the global scope (and therefore to modules as well).</p>
</blockquote>
<p>一个有着顶级 <code>import</code> 或 <code>export</code> 语句的文件被认为是一个<strong>模块</strong>，相反，则被当成一个全局作用域的脚本。</p>
<h1 id="全局作用域文件"><a href="#全局作用域文件" class="headerlink" title="全局作用域文件"></a>全局作用域文件</h1><p>有了这句话，就很清楚了，只要避免一个文件顶级有 <code>import</code> 或 <code>export</code> 语句，这个文件的作用域就是全局的，即无需引入就可以使用里面的类型。</p>
<p>例如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/global.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> add: <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span></span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"><span class="comment">// 无需引入，可直接调用 add</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>如果在顶级添加一个 <code>import</code> 或 <code>export</code> ：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/global.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> add: <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>则在 index.ts 中会提示 找不到名称“add”</p>
<p>这时候要用到里面的变量，只能把变量都 export 出来，然后在 index.ts 中引入：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/global.d.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">var</span> add: <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// src/index.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; add &#125; <span class="keyword">from</span> <span class="string">&#x27;./global&#x27;</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h1 id="带有-import-的全局作用域脚本"><a href="#带有-import-的全局作用域脚本" class="headerlink" title="带有 import 的全局作用域脚本"></a>带有 import 的全局作用域脚本</h1><p>那如果需要 <code>import</code> 怎么办？例如我们需要定义一个 axios 的实例，并把它定义为全局变量 <code>$http</code> 。</p>
<h2 id="不在顶级-import"><a href="#不在顶级-import" class="headerlink" title="不在顶级 import"></a>不在顶级 import</h2><p>文档里有说明</p>
<blockquote>
<p>top-level import or export</p>
</blockquote>
<p>那么只要避开 top-level 就行。通过定义一个 namespace ，可以把 <code>import </code> 跟 <code>export</code> 都放到里面：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/global.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> Glb &#123;</span><br><span class="line">  <span class="keyword">declare</span> <span class="keyword">var</span> $http: <span class="keyword">import</span>(<span class="string">&#x27;axios&#x27;</span>).AxiosInstance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，可以直接用 <code>Glb.$http(&#123;&#125;)</code> 来调用。</p>
<h2 id="使用-declare-global"><a href="#使用-declare-global" class="headerlink" title="使用 declare global"></a>使用 declare global</h2><p>如果非要直接 <code>$http(&#123;&#125;)</code> 调用，还可以这么写：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; AxiosInstance &#125; <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="built_in">global</span> &#123;</span><br><span class="line">  <span class="keyword">declare</span> <span class="keyword">var</span> $http: AxiosInstance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然在顶级有 <code>import</code> ，但直接在 global namespace 定义了 <code>$http</code></p>
<h1 id="拓展-window-对象"><a href="#拓展-window-对象" class="headerlink" title="拓展 window 对象"></a>拓展 window 对象</h1><h2 id="不带-import"><a href="#不带-import" class="headerlink" title="不带 import"></a>不带 import</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/global.d.ts</span></span><br><span class="line"><span class="keyword">interface</span> Window &#123;</span><br><span class="line">  add: <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="带-import"><a href="#带-import" class="headerlink" title="带 import"></a>带 import</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/global.d.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; AxiosInstance &#125; <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="built_in">global</span> &#123;</span><br><span class="line">  <span class="comment">// declare var $http: AxiosInstance</span></span><br><span class="line">  <span class="keyword">interface</span> Window &#123;</span><br><span class="line">    $http: AxiosInstance</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://stackoverflow.com/questions/39040108/import-class-in-definition-file-d-ts">Stack Overflow 采纳的回答</a></li>
<li><a href="https://www.typescriptlang.org/docs/handbook/modules.html">TypeScript Module</a></li>
<li><a href="https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-d-ts.html">TypeScript global.d.ts 文件模板</a></li>
<li><a href="https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-modifying-module-d-ts.html">TypeScript global-modifying-module.d.ts 文件模板</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>记录：Vue如何正确推导Props类型</title>
    <url>/2019/07/01/%E8%AE%B0%E5%BD%95%EF%BC%9AVue%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E6%8E%A8%E5%AF%BCProps%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>在使用 Vue + TypeScript 的时候，应该都会有个疑问，这些选项都是怎么推导出来的？特别是 <code>props</code> 这个选项，有着好几种形式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line">props: [<span class="string">&#x27;hello&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line">props: &#123;</span><br><span class="line">  hello: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象里面的 prop 是数组</span></span><br><span class="line">props: &#123;</span><br><span class="line">  hello: [<span class="built_in">String</span>, <span class="built_in">Boolean</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象里面的 prop 是对象</span></span><br><span class="line">props: &#123;</span><br><span class="line">  hello: &#123;</span><br><span class="line">    type: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有着这么多种形式，最后还能在其他地方推导出正确的类型</p>
<p><img src="/images/posts/20190701/vue-props-type.png" alt="props"></p>
<p>怎么做到的？</p>
<h1 id="查看源码"><a href="#查看源码" class="headerlink" title="查看源码"></a>查看源码</h1><p>我们从 <code>Vue.extend</code> 点进去，找到 <code>vue.d.ts</code> 中定义的 <code>extend</code> ：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> VueConstructor&lt;V <span class="keyword">extends</span> Vue = Vue&gt; &#123;</span><br><span class="line">  <span class="comment">// ...省略其他部分代码</span></span><br><span class="line">  extend&lt;Data, Methods, Computed, Props&gt;(options?: ThisTypedComponentOptionsWithRecordProps&lt;V, Data, Methods, Computed, Props&gt;): ExtendedVue&lt;V, Data, Methods, Computed, Props&gt;;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺着 Props 相关的类型，找到 vue 的 <code>options.d.ts</code> 文件中的 <code>ComponentOptions</code> 接口，这是我们使用 <code>Vue.extend</code> 时传入选项的接口。</p>
<p>可以看到 <code>props?: PropsDef;</code></p>
<p>我们顺着这个 <code>PropsDef</code> 把 Props 相关的定义都提取出来：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> Prop&lt;T&gt; = &#123; (): T &#125; | &#123; <span class="keyword">new</span>(...args: <span class="built_in">any</span>[]): T &amp; <span class="built_in">object</span> &#125; | &#123; <span class="keyword">new</span>(...args: <span class="built_in">string</span>[]): <span class="built_in">Function</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> PropType&lt;T&gt; = Prop&lt;T&gt; | Prop&lt;T&gt;[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> PropValidator&lt;T&gt; = PropOptions&lt;T&gt; | PropType&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> PropOptions&lt;T=any&gt; &#123;</span><br><span class="line">  <span class="keyword">type</span>?: PropType&lt;T&gt;;</span><br><span class="line">  required?: <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="keyword">default</span>?: T | <span class="literal">null</span> | <span class="literal">undefined</span> | (<span class="function">() =&gt;</span> T | <span class="literal">null</span> | <span class="literal">undefined</span>);</span><br><span class="line">  validator?(value: T): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> RecordPropsDefinition&lt;T&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T]: PropValidator&lt;T[K]&gt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> ArrayPropsDefinition&lt;T&gt; = (keyof T)[];</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> PropsDefinition&lt;T&gt; = ArrayPropsDefinition&lt;T&gt; | RecordPropsDefinition&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ComponentOptions&lt;</span><br><span class="line">  // ...</span><br><span class="line">  PropsDef=PropsDefinition&lt;DefaultProps&gt;,</span><br><span class="line">  Props=DefaultProps&gt; &#123;</span><br><span class="line">    props?: PropsDef;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h1 id="简化代码"><a href="#简化代码" class="headerlink" title="简化代码"></a>简化代码</h1><p>上边源码看起来还是有点多，我这边大概理解了推导过程，所以写一个简化版的便于理解，只考虑 props 为对象的情况：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.extend(&#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    test: <span class="built_in">String</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>简化的类型代码：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Prop&lt;T&gt; = <span class="function">() =&gt;</span> T</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PropDef&lt;T&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T]: Prop&lt;T[K]&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化版 VueConstructor ，只保留 extend</span></span><br><span class="line"><span class="keyword">interface</span> PropsConstructor &#123;</span><br><span class="line">  <span class="comment">// 从这里可以得到 PropDef&lt;Prop&gt; = &#123; test: String &#125; , 所以 Prop = &#123; test: string &#125;</span></span><br><span class="line">  extend&lt;Prop&gt;(options?: PropDef&lt;Prop&gt;): Prop</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> Props: PropsConstructor</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> props = Props.extend(&#123;</span><br><span class="line">  test: <span class="built_in">String</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>把上述简化的代码贴到 VSCode ，把鼠标移到 <code>const props</code> 上，可以发现正确推导出了 <code>&#123; test: string &#125;</code> 。</p>
<p>怎么做到的呢？这里我之前犯了个错误，把 <code>Prop</code> 这个类型当成是我们传进去的对象了，所以一直没法理解。</p>
<p>而实际上，<code>PropDef&lt;Prop&gt;</code> 才是我们传进去的类型，这边是 <strong>通过 <code>PropDef&lt;Prop&gt;</code> 推导出了 <code>Prop</code></strong></p>
<p>我们把 <code>&#123; test: string &#125;</code> 从上往下代入类型中，就是：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Prop&lt;<span class="built_in">string</span>&gt; = <span class="function">() =&gt;</span> <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PropDef&lt;&#123;</span><br><span class="line">  test: <span class="built_in">string</span>,</span><br><span class="line">&#125;&gt; = &#123;</span><br><span class="line">  <span class="comment">// 这里 Prop&lt;string&gt; 就是相当于 String 构造函数</span></span><br><span class="line">  test: Prop&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> PropsConstructor &#123;</span><br><span class="line">  <span class="comment">// 这边的 PropDef&lt;&#123; test: string &#125;&gt; 也就是 &#123; test: Prop&lt;string&gt; &#125;</span></span><br><span class="line">  extend&lt;&#123; <span class="attr">test</span>: <span class="built_in">string</span> &#125;&gt;(options?: PropDef&lt;&#123; <span class="attr">test</span>: <span class="built_in">string</span> &#125;&gt;): &#123; <span class="attr">test</span>: <span class="built_in">string</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代入后，不知各位会不会清楚一些。</p>
<p>这边的重点就是 <strong>通过 <code>PropDef&lt;Prop&gt;</code> 推导出了 <code>Prop</code></strong></p>
<p>我们写 <code>Vue.extend</code> 的时候定义的是 <code>PropDef&lt;Prop&gt;</code> ，而 <code>Prop</code> 则是通过 TypeScript 推导出来的，因此我们在其他地方才能获得正确的类型。</p>
<h1 id="其他情况"><a href="#其他情况" class="headerlink" title="其他情况"></a>其他情况</h1><p>如果理解了上面那种情况，那其他情况其实就比较好理解了。</p>
<p>我们看到 vue 里面有这样一条类型定义：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> PropsDefinition&lt;T&gt; = ArrayPropsDefinition&lt;T&gt; | RecordPropsDefinition&lt;T&gt;;</span><br></pre></td></tr></table></figure>
<p>显然，这是区分了 props 是数组跟对象的情况。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>首先看数组：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> ArrayPropsDefinition&lt;T&gt; = (keyof T)[];</span><br></pre></td></tr></table></figure>
<p>数组的情况比较简单，假设我们传入的是 <code>[&#39;test&#39;]</code> ，那么就直接对应了这个类型，在 <code>extend</code> 时会转为一个对象，类型都是 <code>any</code> ，即 <code>&#123; test: any &#125;</code>。</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>然后是对象：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> PropType&lt;T&gt; = Prop&lt;T&gt; | Prop&lt;T&gt;[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> PropValidator&lt;T&gt; = PropOptions&lt;T&gt; | PropType&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> RecordPropsDefinition&lt;T&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T]: PropValidator&lt;T[K]&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边的 <code>PropType&lt;T&gt;</code> 基本对应了刚刚简化版的情况，不过还加了一个数组的情况，就是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.extend(&#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    test: <span class="built_in">String</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Vue.extend(&#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    test: [<span class="built_in">String</span>, <span class="built_in">Boolean</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>对应这两种情况。</p>
<p>最后的 <code>PropOptions&lt;T&gt;</code> 就是对应最复杂的那种情况了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.extend(&#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    test: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这个结构对应 <code>PropOptions&lt;T&gt;</code> ：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> PropOptions&lt;T=any&gt; &#123;</span><br><span class="line">  <span class="keyword">type</span>?: PropType&lt;T&gt;;</span><br><span class="line">  required?: <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="keyword">default</span>?: T | <span class="literal">null</span> | <span class="literal">undefined</span> | (<span class="function">() =&gt;</span> T | <span class="literal">null</span> | <span class="literal">undefined</span>);</span><br><span class="line">  validator?(value: T): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>PropOptions</code> 的那个 <code>T</code> 就是我们最后推导拿到的类型，即 <code>&#123; test: string &#125;</code></p>
<h1 id="多个-extend-方法的重载"><a href="#多个-extend-方法的重载" class="headerlink" title="多个 extend 方法的重载"></a>多个 extend 方法的重载</h1><p>在 <code>vue.d.ts</code> 中，可以看到 <code>VueConstructor</code> 有很多 <code>extend</code> 方法的重载：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> VueConstructor&lt;V <span class="keyword">extends</span> Vue = Vue&gt; &#123;</span><br><span class="line">  <span class="comment">// ...省略部分代码</span></span><br><span class="line"></span><br><span class="line">  extend&lt;Data, Methods, Computed, PropNames <span class="keyword">extends</span> <span class="built_in">string</span> = <span class="built_in">never</span>&gt;(options?: ThisTypedComponentOptionsWithArrayProps&lt;V, Data, Methods, Computed, PropNames&gt;): ExtendedVue&lt;V, Data, Methods, Computed, Record&lt;PropNames, <span class="built_in">any</span>&gt;&gt;;</span><br><span class="line">  extend&lt;Data, Methods, Computed, Props&gt;(options?: ThisTypedComponentOptionsWithRecordProps&lt;V, Data, Methods, Computed, Props&gt;): ExtendedVue&lt;V, Data, Methods, Computed, Props&gt;;</span><br><span class="line">  extend&lt;PropNames <span class="keyword">extends</span> <span class="built_in">string</span> = <span class="built_in">never</span>&gt;(definition: FunctionalComponentOptions&lt;Record&lt;PropNames, <span class="built_in">any</span>&gt;, PropNames[]&gt;): ExtendedVue&lt;V, &#123;&#125;, &#123;&#125;, &#123;&#125;, Record&lt;PropNames, <span class="built_in">any</span>&gt;&gt;;</span><br><span class="line">  extend&lt;Props&gt;(definition: FunctionalComponentOptions&lt;Props, RecordPropsDefinition&lt;Props&gt;&gt;): ExtendedVue&lt;V, &#123;&#125;, &#123;&#125;, &#123;&#125;, Props&gt;;</span><br><span class="line">  extend(options?: ComponentOptions&lt;V&gt;): ExtendedVue&lt;V, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边通过 <code>options</code> 参数的类型，可以看出应对不同 <code>props</code> 形式而做的重载：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> VueConstructor&lt;V <span class="keyword">extends</span> Vue = Vue&gt; &#123;</span><br><span class="line">  <span class="comment">// ...省略部分代码</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// props: [&#x27;test&#x27;] 的情况</span></span><br><span class="line">  extend&lt;Data, Methods, Computed, PropNames <span class="keyword">extends</span> <span class="built_in">string</span> = <span class="built_in">never</span>&gt;(options?: ThisTypedComponentOptionsWithArrayProps&lt;V, Data, Methods, Computed, PropNames&gt;): ExtendedVue&lt;V, Data, Methods, Computed, Record&lt;PropNames, <span class="built_in">any</span>&gt;&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// props: &#123; test: String &#125; 或 props: &#123; test: [String, Boolean] &#125; 或 props: &#123; test: &#123; type: String &#125; &#125;</span></span><br><span class="line">  extend&lt;Data, Methods, Computed, Props&gt;(options?: ThisTypedComponentOptionsWithRecordProps&lt;V, Data, Methods, Computed, Props&gt;): ExtendedVue&lt;V, Data, Methods, Computed, Props&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// functional 组件中 props: [&#x27;test&#x27;] 的情况</span></span><br><span class="line">  extend&lt;PropNames <span class="keyword">extends</span> <span class="built_in">string</span> = <span class="built_in">never</span>&gt;(definition: FunctionalComponentOptions&lt;Record&lt;PropNames, <span class="built_in">any</span>&gt;, PropNames[]&gt;): ExtendedVue&lt;V, &#123;&#125;, &#123;&#125;, &#123;&#125;, Record&lt;PropNames, <span class="built_in">any</span>&gt;&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// functional 组件中 props 为对象的情况</span></span><br><span class="line">  extend&lt;Props&gt;(definition: FunctionalComponentOptions&lt;Props, RecordPropsDefinition&lt;Props&gt;&gt;): ExtendedVue&lt;V, &#123;&#125;, &#123;&#125;, &#123;&#125;, Props&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 其他情况</span></span><br><span class="line">  extend(options?: ComponentOptions&lt;V&gt;): ExtendedVue&lt;V, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p><strong>通过 <code>PropDef&lt;Prop&gt;</code> 推导出了 <code>Prop</code></strong></p>
<p>就是本次记录的结论，你在 <code>VueConstructor[&#39;extend&#39;]</code> 的多种重载中看到的 <code>Props</code> ，都是已经推导好的类型，而不是用户传进去的代码。</p>
<p>学过 TypeScript 的各位大佬们可能很快就理解了这种用法，我比较迟钝，记录一下hhh。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>记录：Vue computed实现deep监听踩坑</title>
    <url>/2019/12/12/%E8%AE%B0%E5%BD%95%EF%BC%9AVue-computed%E5%AE%9E%E7%8E%B0deep%E7%9B%91%E5%90%AC%E8%B8%A9%E5%9D%91/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在写 Vue 组件的时候，其中的 computed 里面依赖了一个对象，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">  	<span class="keyword">return</span> &#123;</span><br><span class="line">      date: &#123;</span><br><span class="line">      	start: <span class="literal">null</span>,</span><br><span class="line">        end: <span class="literal">null</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">  	dateRange () &#123;</span><br><span class="line">    	<span class="built_in">this</span>.count++</span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">this</span>.date</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>以上述代码为例， <code>dateRange</code> computed 属性依赖了 <code>date</code> 这个对象，理想情况下， <code>dateRange</code> 会随着 <code>date</code> 对象内容的改变而改变。</p>
<p>然而，当单独改变 <code>date.start</code> 或 <code>date.end</code> 时，<code>dateRange</code> 却没有做出响应，见下面的<a href="https://jsfiddle.net/azureternite/865uom91/13/">示例</a>：</p>
<script async src="//jsfiddle.net/azureternite/865uom91/13/embed/js,html,result/dark/"></script>

<h1 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h1><p>直接看 vue2 有关初始化 computed 部分的源码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> computedWatcherOptions = &#123; <span class="attr">lazy</span>: <span class="literal">true</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initComputed</span> (<span class="params">vm: Component, computed: <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="keyword">const</span> watchers = vm._computedWatchers = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  <span class="comment">// computed properties are just getters during SSR</span></span><br><span class="line">  <span class="keyword">const</span> isSSR = isServerRendering()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> computed) &#123;</span><br><span class="line">    <span class="keyword">const</span> userDef = computed[key]</span><br><span class="line">    <span class="keyword">const</span> getter = <span class="keyword">typeof</span> userDef === <span class="string">&#x27;function&#x27;</span> ? userDef : userDef.get</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; getter == <span class="literal">null</span>) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">`Getter is missing for computed property &quot;<span class="subst">$&#123;key&#125;</span>&quot;.`</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isSSR) &#123;</span><br><span class="line">      <span class="comment">// create internal watcher for the computed property.</span></span><br><span class="line">      watchers[key] = <span class="keyword">new</span> Watcher(</span><br><span class="line">        vm,</span><br><span class="line">        getter || noop,</span><br><span class="line">        noop,</span><br><span class="line">        computedWatcherOptions</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，初始化的 computed 实际上就是个不带 <code>deep</code> 的 <code>Watcher</code> ，所以在收集依赖的时候， <code>dateRange</code> 只收集到了 <code>date</code> ，而没有收集到 <code>date.start</code> 和 <code>date.end</code> ，因此也就不会对这两个属性的单独变化做出响应。</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>那要怎么在 computed 里实现类似 deep 的效果呢？实际上，使用 computed 的一般不会是什么特别复杂的属性，否则直接用 <code>watch</code> 就行了。</p>
<p>对于这类 computed ，有两种十分简单的方案：</p>
<ol>
<li>改变对象时将整个对象一起改变，例如 <code>this.date = &#123;&#125;</code> ，而不是 <code>this.date.start = xxx</code></li>
<li>在 computed 里将希望监听的属性都访问一遍，调用对象深层属性的 getter 。例如在上述示例中，在 <code>dateRange</code> 中访问一遍 <code>this.date.start</code> 跟 <code>this.date.end</code> 即可。</li>
</ol>
<p>可在<a href="https://jsfiddle.net/azureternite/865uom91/13/">示例</a>中将注释去掉查看 computed 触发更新效果。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>A*算法实现流程图折线的思路</title>
    <url>/2020/02/26/A-%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B%E5%9B%BE%E6%8A%98%E7%BA%BF%E7%9A%84%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在开发流程图时，节点之间的连线一般有三种类型：直线、曲线和折线</p>
<p>其中直线与曲线的实现比较简单，只要知道起点与终点就能计算出来，也不用考虑与流程图节点重叠的问题，直接穿过节点即可。</p>
<p><img src="/images/posts/20200226/flowchart-straight-link.png" alt="flowchart-straight-link"></p>
<p>但是折线就不一样了，需要考虑节点避让，在合适的地方“拐弯”</p>
<p><img src="/images/posts/20200226/flowchart-polyline-link.png" alt="flowchart-polyline-link"></p>
<p>那么，怎么确定这些拐点的位置？如何让折线避开节点，不与节点重叠？</p>
<h1 id="可行的方法"><a href="#可行的方法" class="headerlink" title="可行的方法"></a>可行的方法</h1><p>拐点的位置，肯定是与节点的位置有关，而且跟连线的起点、终点坐标有关。</p>
<h2 id="枚举法"><a href="#枚举法" class="headerlink" title="枚举法"></a>枚举法</h2><p>知道了节点的相对位置与起点终点的坐标，就可以枚举出拐点了。也就是用 If Else 堆叠出来的枚举法，把所有可能的相对位置与起点终点都枚举出来，再去判断拐点的位置。</p>
<p>关于枚举法，如果条件不多的话是最简单的，但是两个节点的相对位置，加上起点终点的位置，这两个条件组合起来，有几十种情况，要全部写出来也是一件比较头疼的事。</p>
<p>网上也有总结出规律的简化版：<a href="https://juejin.im/post/5b73829ee51d4566205fe7f0">流程图——正交连线的算法的一种简单实现</a></p>
<p>不过网上的枚举版本貌似都没有完全避开节点，还是会有重叠的情况。</p>
<h2 id="寻路算法"><a href="#寻路算法" class="headerlink" title="寻路算法"></a>寻路算法</h2><p>相比枚举，用寻路算法就不那么头疼，节点相对位置与起点终点坐标对代码逻辑的影响会小一些，而且能很好地满足节点避让的条件，但需要先确定哪些坐标是连线可以到达的。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>应该有更好的解决方案，欢迎提出一起研究。</p>
<h1 id="A-算法"><a href="#A-算法" class="headerlink" title="A* 算法"></a>A* 算法</h1><p>关于 A* 算法的解释，看这篇文章大概就能掌握： <a href="https://blog.csdn.net/hitwhylz/article/details/23089415">https://blog.csdn.net/hitwhylz/article/details/23089415</a></p>
<p>简单来说，目的就是找到从 A 点到 B 点的一条路径。</p>
<p>从 A 点出发，找出 A 点附近可到达的所有点，计算其 f 值，其中 f = g + h</p>
<p>g: 从起点到当前点的开销<br/><br>h: 从当前点到终点预估的开销</p>
<p>找出 f 最小的点作为下一个目的，重复上述步骤</p>
<p>直到找到 B 点，或者无法到达 B 点为止。</p>
<h1 id="地图构建"><a href="#地图构建" class="headerlink" title="地图构建"></a>地图构建</h1><p>要应用寻路算法，首先要把地图画出来，也就是确定地图上有哪些点。</p>
<h2 id="以像素作为路径点"><a href="#以像素作为路径点" class="headerlink" title="以像素作为路径点"></a>以像素作为路径点</h2><p>如果把每个像素作为路径点，通过这个像素是否在节点内部来判断这个坐标是否可以走，地图的构建似乎十分简单。</p>
<p>实际上，用这样细粒度的地图来画线不是不行，如果起点与终点的距离比较近，寻路后遍历到的点就几十个。</p>
<p>但是随着用户拖动节点，这样构建的地图缺陷就很明显了：</p>
<ol>
<li>节点每移动一次，路径都需要重新计算，一次几十个点看起来不是很多，但计算的频次变高之后，单位时间内需要遍历的点就越多</li>
<li>随着起点与终点距离的变化，需要遍历的点数量也不同，如果距离拉长，需要遍历的点数量就会暴增，达到几百个甚至几千个</li>
</ol>
<p>最终导致的结果就是，程序卡顿，甚至卡死</p>
<h2 id="尽量减少需要遍历的路径点"><a href="#尽量减少需要遍历的路径点" class="headerlink" title="尽量减少需要遍历的路径点"></a>尽量减少需要遍历的路径点</h2><p>那么，是不是寻路算法就不能用在这里了？答案当然是否定的，通过观察流程图折线可以知道，一般拐点的个数也就两三个，而通过像素构建的地图，虽然精度高，但最后画出来的折线，拐点也还是两三个，整条路径上大部分都是直线。所以，大多数点都是不需要去遍历的，是我们构建地图的方法有问题。</p>
<p>因此需要尽量简化地图，减少遍历点的个数。</p>
<p>我们以最简单的起点终点位置为例：</p>
<p><img src="/images/posts/20200226/flowchart-a-star-map-1.png" alt="flowchart-a-star-map-1"></p>
<p>这时的折线连线显然是这样的：</p>
<p><img src="/images/posts/20200226/flowchart-a-star-map-2.png" alt="flowchart-a-star-map-2"></p>
<p>实际上，操作过几个流程图的实现后，可以发现，折线的拐点，为了避让节点，走向总是会环绕着节点：</p>
<p><img src="/images/posts/20200226/flowchart-a-star-map-3.png" alt="flowchart-a-star-map-3"></p>
<p>经过观察可以知道，折线的拐点总是出现在固定的几个位置：</p>
<p><img src="/images/posts/20200226/flowchart-a-star-map-4.png" alt="flowchart-a-star-map-4"></p>
<ol>
<li>两个节点的四个边向外扩展一定边距组成的矩形的四个角（红色8个点）</li>
<li>起点与终点垂直于节点边做延长线，与扩展矩形的交点（蓝色4个点）</li>
<li>起点与终点分别做十字延长线组成一个矩形，矩形中垂直于节点边的两条边的中点（绿色2个点）</li>
</ol>
<p>这样，拐点可能出现的坐标，一共 14 个点，再加上起点与终点 2 个点，最终构成了一个 16 个点的简化地图</p>
<p>以上考虑的是一个典型的流程图情况，除此之外，还有一些情况：</p>
<ol>
<li>只有一个节点的情况</li>
<li>没有节点的情况</li>
<li>需要避让除了起点、终点所在节点之外的其他节点的情况（暂时不考虑）</li>
</ol>
<p>以上几种情况对应的地图坐标点的数量都不相同，前两种情况数量较为固定，公式：</p>
<p>16 - 没有节点的数量（1 或者 2） x (扩展矩形的 4 个点 + 延长线与扩展矩形的 2 个交点（蓝色）) + 没有节点的数量（1 或者 2） x (起点与终点十字延长线组成矩形的中点 1 个 + 起点与终点十字延长线组成矩形的 1 个角)</p>
<p>比如，连线只有一个节点时，地图点数 = 16 - 1 x (4 + 2) + 1 x (1 + 1) = 12</p>
<p>只有连线，没有节点时，地图点数 = 16 - 2 x (4 + 2) + 2 x (1 + 1) = 8</p>
<p>除了不考虑的第三种情况，其他情况地图上的点数量都不超过 16 ，即寻路时遍历的点数不会超过 16 ，相比像素作为地图路径点，极大减少了遍历的数量。</p>
<p>附：当两个节点重叠，导致在避让节点的条件下没有路径时，则忽略两个节点，不进行避让，即第二种情况。</p>
<h1 id="确定可到达的点"><a href="#确定可到达的点" class="headerlink" title="确定可到达的点"></a>确定可到达的点</h1><p>确定了地图上有哪些点后，接下来该找到一个办法，用来确定哪些坐标可以走，哪些坐标不能走。</p>
<p>与平常的 A* 不同的是，平时地图上的每个点已经确定是可走的或者是障碍物了，对于一个点 P 来说，无论算法遍历到哪个点，点 P 的属性都不会改变，是可走的，就一直是可走的，是障碍物就一直是障碍物。</p>
<p>而在流程图折线里，一个点是否可走，取决于当前遍历的点，点 P 有可能在遍历上一个点时是可走的，遍历下一个点时，又是不可走的。</p>
<p>假设现在用 A* 遍历到了下图蓝色的点：</p>
<p><img src="/images/posts/20200226/flowchart-a-star-map-5.png" alt="flowchart-a-star-map-5"></p>
<p>由于折线只有水平或者垂直两个方向的走向，下一个点只能在经过其十字延长线的点上去查找，在图上已标明共有 5 个点。</p>
<p>但是这 5 个点不能直接添加到 Open List 中，因为目前它们只是 “可能是可走的点” 。</p>
<p>如何确定是否真的可以走？只要把当前点，分别与 5 个点连起来，生成 5 条线，其中，线与节点重叠的点，即是不可走的点。</p>
<p>这个判断就是为了让折线能够避让节点。</p>
<h1 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h1><p>完成了地图构建与确定可到达点的方法后，剩下的就是按照 A* 算法的步骤去执行了。</p>
<p>不过执行后画出来的路径，虽然实现了弯折与节点避让，但有时候不是很美观，有时候路径不是我们想要的，比如：</p>
<ol>
<li>折线没有经过中点</li>
<li>折线拐点太多</li>
</ol>
<p>这时候就需要动到 A* 里面的核心公式了。</p>
<p>我们知道，决定下一个遍历的点时，是以 f = g + h 中 f 的大小决定的，即取 f 最小的点，那么，在 f 相同的情况下，取的点就不确定了，一般是取先进入 Open List 的点。</p>
<p>为此，对 f 相同的点，可以进行一些额外的判断：</p>
<ol>
<li>当 f 相同时，取 abs(g-h) 较小的点，以达到优先走中点的目的</li>
<li>当 f 与 abs(g-h) 都相同时，引入另外一个变量 t ，表示拐点的数量，取 t 较小的点</li>
</ol>
<p>经过优化，就大致可以达到我们想要的效果了。</p>
<h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><p><a href="https://github.com/wsfe/flowchart">@wsfe/flowchart</a></p>
<p>此流程图项目目前只能算个 Demo ，优化空间很大</p>
<p><a href="https://wsfe.github.io/flowchart/">在线试毒</a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://juejin.im/post/5b73829ee51d4566205fe7f0">流程图——正交连线的算法的一种简单实现</a></li>
<li><a href="https://blog.csdn.net/hitwhylz/article/details/23089415">A星算法详解</a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>A*</tag>
        <tag>流程图</tag>
      </tags>
  </entry>
  <entry>
    <title>对 React 一些零散的感受</title>
    <url>/2021/02/02/%E5%AF%B9-React-%E4%B8%80%E4%BA%9B%E9%9B%B6%E6%95%A3%E7%9A%84%E6%84%9F%E5%8F%97/</url>
    <content><![CDATA[<p>从 Vue 转到 React 快要一年了，虽然写页面用哪个不是搬砖？但实际经历过用两种框架搬砖，还是有所感触的。本文不是什么源码解析，也不是要分个高低，甚至会刻意避开一些技术上的细节，单纯谈谈我个人从 Vue 转 React 后的一些感受上的变化，更偏向感性的认知，并没有什么技术干货。</p>
<h1 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h1><p>“我写 Vue 的时候，从来都不会考虑这些。”</p>
<p>这是我刚接触一两个月时，最直接的感受。在写 Vue 代码时，不会去想这是什么副作用，有请求就调用方法，有渲染没生效就 nextTick ，也没有受控组件的概念， UI = f(State) 这个公式，仿佛离我很远。</p>
<p>关于受控这块，有经历过困惑的时候，也知道 Vue 内部对原生 input 标签做了处理，但还是没有写受控组件的意识。之前在写树组件时，用 <code>v-model</code> 去控制了 <code>selected</code> 属性跟 <code>checked</code> 属性，但是 <code>v-model</code> 只能控制一个属性的 <code>value</code> 跟 <code>onChange</code> ，多出来的属性，用 <code>v-sync</code> 总不是很舒服，而且当时本着需要传的 Props 能少就少的想法，提供了许多组件方法，让外部通过 <code>this.$refs.xxx()</code> 来控制子组件内部的状态。这个版本发布不久，我就后悔了，提供了这么多方法给外部来控制内部的状态，虽然当时也没有什么状态的概念，维护起来总有种莫名的难受，也可能是响应式带来的麻烦，我即想响应 <code>value</code> 属性，又想响应 <code>data</code> 属性，来决定选中的内容。</p>
<p>种种结合起来，虽然在 Vue 组件里最终都能解决，但总感觉不优雅，刚发布了 2.0 版本就想再重构，却无从下手。</p>
<p>Vue 对各种概念、场景都尽可能封装起来，帮你做了很多事情，所以你可以不用知道许多概念，就能直接上手。而且 Vue 的限制不多，以前开发表单这种有深层对象的东西，子组件直接修改传入的 Props 更是家常便饭，虽然我们都知道这是不好的。</p>
<p>或许是老外不用 996 ，又或许是自己真的菜， React 能有这么一套理念，这么多的概念可以推广。</p>
<p>刚上手 React 的那段时间，最经常遇到的疑惑就是：</p>
<ul>
<li>怎么又无限循环了？</li>
<li><code>style</code> 跟 <code>className</code> 为什么不能直接传进去？</li>
<li>re-render 了好多次耶，不过好像没啥影响，不管了吧？</li>
<li>状态提升太难受了吧，业务稍微变一下，内部的状态要提升到天上去了</li>
<li>每次 re-render 都创建了新的函数、新的对象，真的没事吗？</li>
<li>又要把状态提出来，父组件直接调用子组件的方法不香吗？</li>
<li>在请求返回后的 <code>then</code> 函数里调用两次 <code>setState</code> ， effect 执行了两次？</li>
</ul>
<p>这些问题一股脑地抛出来，对于刚从 Vue 保姆身边出来的人来说，什么 “我要好好学习它的思想” ，不存在的， “TMD 烦死了” 恐怕才是第一且真实的感受。</p>
<p>对于 “函数式编程” 这个概念，以前对它的印象就是：不是个坏东西；写工具来说挺重要的；但如果要我在业务里用，尤其是一连串函数 compose 起来，那让我死吧。</p>
<p>无知的时候总是会抗拒不了解的事务，不得不写 React ，倒逼了我去学习它的理念，也改善了我书写组件的方式。这个推动力， React 给了一部分，当然，身边的环境变化也给了一大部分。</p>
<p>现在写一个组件，不得不考虑的就是，状态，状态，还是状态，一个状态要放在哪里，谁可以动它。或许跟 Vue 里的 data 很像，但 React 函数式的思想使我不得不谨慎考虑，它没法让外部通过 <code>this.$refs.xxx()</code> 去干涉内部的状态，遇到业务变动就可能要提升一堆的状态，所以要考虑提升的成本（在 Vue 里，我可能就 <code>this.$refs</code> 了事），也开始考虑尽可能做成受控组件，同时尽量提供非受控用法，让外部使用起来更方便同时又灵活。</p>
<p>说了这么多，你们可能觉得我开始捧一踩一了，对着 React 一顿夸。其实我只是从我转变的角度去描述了这么一个变化，从另一个角度说， React 概念多、学习门槛比 Vue 高，不好上手这些网络上老生常谈的点，并不是不存在的。我依然存在抗拒 React 的想法，但相比刚上手时程度没这么严重，认识到自己的无知是很大的一个进步。</p>
<p>Angular：那我呢？</p>
<p>学习优秀框架的思想挺重要的，即使内心抗拒使用，抱着学习的心态，也一定会有收获的。在过去的近一年里，我也接触了身边的一些分享，或者跟 React 、Angular 这些框架有关，或者是一些通用的技术。老大不小的人了，希望从现在开始学习，永远不会太晚。</p>
<h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><p>在文档方面，两边都挺优秀的。</p>
<p>但在体验上，我在 Vue 文档更能快速找到想要的内容，或许是门槛低，没有那么多概念的解释，更像一本字典。</p>
<p>而看 React 文档，则要先理解一些概念，有种看国外产品翻译的文档特有的感觉，稍微有理解成本。</p>
<h1 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h1><p>实际上，两个框架都希望数据流是单向的，从父组件流向子组件，天经地义，可维护。</p>
<p>但两边都没有强行限制子组件修改 Props 嵌套对象的行为。</p>
<p>不过在 React 中，修改状态需要用 <code>setState</code> ，不会直接用赋值的方式，这使得正常书写组件时，如果不是刻意去赋值，是不会修改到 Props 的。</p>
<p>而在 Vue 中， Props 跟 data 都挂载在 <code>this</code> 上，要修改到 Props 是相对比较容易发生的。</p>
<h1 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h1><p>Hooks ，或者说带有状态的函数，通过控制反转的方式，保留住了状态。</p>
<p>Hooks 提高了功能的复用能力，使得整个 React 项目代码都由函数组成，不用 class ，没有 options ，整个代码看起来就都是函数，十分纯粹。</p>
<p>但是有个限制就是实现的 Hooks 都强依赖了 React ，只能在 React 生态里使用。这也能理解，想要实现不限框架的可复用的工具，没有状态的就是个普通函数，有状态的用 class 就好。</p>
<p>Vue 3 也是向着这个方向转变的，不知道在后端层面是不是个好的实践，至少现在看起来还行，解决了以前复用代码时 Props 来源不明确、命名冲突等问题。</p>
<p>自写 React 以来，对于引用类型更加敏感了，因为 dependencies 数组，有点观察者的感觉，而且在 <code>useEffect</code> 中，很容易造成无限循环，刚上手时磕磕绊绊地溯源，可以发现大体上存在这些问题：</p>
<ol>
<li>某个 dependency 没处理好，意外变化了，导致 <code>useEffect</code> 重新执行了</li>
<li>dependencies 数组内容特别多，难以定位是哪个依赖引起的</li>
</ol>
<p>所以随着代码量的增加，会更注意引用类型的变化、以及 dependencies 数组元素的个数，逐渐使代码优化到一个较好的、更可维护的状态。</p>
<p>虽然 Vue 就是基于观察者，但对于类似 <code>useEffect</code> 这类自动执行的函数，都是开发者通过 <code>watch</code> 配置的，整个 dependencies 都在掌控之中，因此不会特别在意其他每个引用类型变量的变化，只要管好 <code>watch</code> 的变量就好。而 React 推荐的 eslint 插件能自动补全 dependencies 数组，为了保持代码便于优化，一般都是让 dependencies 自动生成了，因此有时候对于不想 “监听” 的变量，需要有意识地使用 <code>useRef</code> 包裹起来。</p>
<h1 id="JSX-与模板语法"><a href="#JSX-与模板语法" class="headerlink" title="JSX 与模板语法"></a>JSX 与模板语法</h1><p>关于 JSX ，以前经常看到有争议，我个人是没什么感觉的，其优缺点应该是很明了的。</p>
<p>JSX 编译过来就是 js ，十分灵活，用 JSX 描述的界面，可以拆分一小块出来作为一个变量，到处复用。而使用模板的 Vue ，只能再套一层组件。</p>
<p>但模板语法的优势就在于它在编译成 js 代码的过程中，可以 “加点料” ，进行一些优化，比如新出的，静态模板的优化等，这些 Vue 保姆都帮你做好了。</p>
<p>两者没什么好争的， Vue 也不是不能写 JSX ，写 ejs, handlebars 等模板时，也没什么人吐槽它们的学习成本吧，更多的是喜好问题。</p>
<h1 id="“你看过源码吗？就知道bb”"><a href="#“你看过源码吗？就知道bb”" class="headerlink" title="“你看过源码吗？就知道bb”"></a>“你看过源码吗？就知道bb”</h1><p>这话不是其他人对我说的，而是这近一年来，对自己说的一句话。</p>
<p>去年 interview 之前的一段时间，有看了一部分 Vue 的源码，而在过去一年中，学习 React 源码的行动却一鸽再鸽，这不是什么好事。</p>
<p>不过有幸团队内部有分享过相关的内容，对 Fiber, React 如何利用 <code>requestIdleCallback</code> 和 Fiber 链表暂停渲染工作等也有了大致的一个印象。</p>
<p>后续还是希望能系统地去学习一下，看别人成套的文章，结合自己去看源码，以及 React 的新特性，了解在我们没有想象到的地方，它是如何抽象并解决现有的开发痛点的。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript 中如何实现依赖注入</title>
    <url>/2021/04/06/TypeScript-%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>如果有接触过 Angular 或者 Node 服务开发，应该会知道，代码里一般是充满了装饰器的，并且利用控制反转实现了依赖注入。</p>
<p>这本身没什么问题，开发者写的都是一个个的 <code>class</code> ，至于什么时候实例化，都是交给框架去做。</p>
<p>但是有关注入的方式，让我怎么也想不通：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> HttpService <span class="keyword">from</span> <span class="string">&#x27;nestjs&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XXXService</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> <span class="keyword">readonly</span> httpService: HttpService,</span></span><br><span class="line"><span class="params">  </span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是框架在实例化 service 的时候，如何知道要给 constructor 传入什么的</p>
<h1 id="试图分析"><a href="#试图分析" class="headerlink" title="试图分析"></a>试图分析</h1><h2 id="运行时固定传入参数？"><a href="#运行时固定传入参数？" class="headerlink" title="运行时固定传入参数？"></a>运行时固定传入参数？</h2><p>由于 <code>HttpService</code> 在 <code>constructor</code> 中是作为 ts 的类型使用的，因此在运行时 js 是不知道其类型的</p>
<p>这个逻辑至少是确定的（后面打脸</p>
<p>那么，在实例化 <code>XXXService</code> 的时候，固定会传入一个 <code>httpService</code> 实例？</p>
<p>随着文档阅读下去、慢慢开始自己写代码后，很容易发现这个推断是站不住脚的：</p>
<ol>
<li>首先，在 <code>constructor</code> 中，第一个参数也可以是其他的 Service</li>
<li>其次，使用依赖注入时，可以注入多个 Services ，跟 <code>constructor</code> 参数的顺序根本无关</li>
</ol>
<p>例如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XXXService</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> <span class="keyword">readonly</span> catsService: CatsService,</span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> <span class="keyword">readonly</span> dogsService: DogsService,</span></span><br><span class="line"><span class="params">  </span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Or</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XXXService</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> <span class="keyword">readonly</span> dogsService: DogsService,</span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> <span class="keyword">readonly</span> catsService: CatsService,</span></span><br><span class="line"><span class="params">  </span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上两种写法，效果是一样的，都会注入正确的 <code>catsService</code> 与 <code>dogsService</code> 实例。</p>
<p>所以，这个猜想是不成立的。</p>
<h2 id="编译时特殊处理？"><a href="#编译时特殊处理？" class="headerlink" title="编译时特殊处理？"></a>编译时特殊处理？</h2><p>既然无法纯靠运行时达到依赖注入的效果，那么就是在编译的时候进行了特殊的处理？</p>
<p>之前有稍微听说过，在 Angular 中，把原生的 <code>setTimeout</code> 啥的都重写了来实现更新检测相关的机制，那么这样一个风格的开源框架，自己在编译的时候加点料好像也不是什么稀奇的事情。</p>
<p>有可能是 tsc 的时候有些钩子让开发者加料？又或者是 Angular 团队自己写了个 ts 的 compiler ？</p>
<p>不管是哪种方式，实现起来都挺魔幻的，让人一时无法想明白，而且自己维护 compiler 的话，成本应该也不小的。</p>
<p>而 nestjs 文档中有说明，其依赖注入的设计是参考的 Angular ，这么一看，难道 nest 用的 compiler 跟 Angular 一样？还是 nest 团队也自己搞了一套？</p>
<p>在猜想越发离谱的情况下，还是老老实实去搜搜到底是怎么实现的吧。</p>
<h2 id="TypeScript-emitDecoratorMetadata-与-reflect-metadata"><a href="#TypeScript-emitDecoratorMetadata-与-reflect-metadata" class="headerlink" title="TypeScript emitDecoratorMetadata 与 reflect-metadata"></a>TypeScript emitDecoratorMetadata 与 reflect-metadata</h2><p>搜索资料的过程中，发现一个叫 <a href="https://github.com/rbuckton/reflect-metadata"><code>reflect-metadata</code></a> 的库，在 ts 的 <a href="https://www.typescriptlang.org/docs/handbook/decorators.html#metadata">handbook</a> 也有相关的介绍，之前基本没用到 decorators 所以没注意。</p>
<p>搜过 Angular 与 Nestjs 的源码后，可以确定它们的依赖注入系统就是利用了这个实验性的 API 。</p>
<h1 id="原理探索"><a href="#原理探索" class="headerlink" title="原理探索"></a>原理探索</h1><h2 id="reflect-metadata"><a href="#reflect-metadata" class="headerlink" title="reflect-metadata"></a>reflect-metadata</h2><p>从这个库的 <a href="https://github.com/rbuckton/reflect-metadata">Readme</a> 可以很清晰地看出它能做什么：</p>
<p>简单来说，它给开发者提供了一种能力，可以在定义一个 <code>class</code> 时通过 <code>Reflect.defineMetadata</code> 存储一些类型相关的数据，在实际调用的这个 <code>class</code> 的时候，通过 <code>Reflect.getMetadata</code> 获取之前定义的数据。要类比的话，有点像藏在 <code>class</code> 里的 <code>localStorage</code> 。</p>
<p>这里还涉及一个 <a href="https://en.wikipedia.org/wiki/Metaprogramming">元编程</a> 的概念，简单地说，就是平常写程序，是处理外部输入的数据，而元编程提供了将程序当做数据的能力，也就是处理程序的程序。在 JavaScript 中，也不是什么新鲜的特性了， ES6 提供的 <code>Proxy</code>, <code>Reflect</code> 甚至之前的 <code>defineProperty</code> 等，就给开发者提供了元编程的能力。详见 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Meta_programming">MDN</a></p>
<p>扯回正题，我们直接通过一个简单的例子看看 <code>reflect-metadata</code> 到底能做啥</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;reflect-metadata&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Injectable = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Reflect</span>.defineMetadata(<span class="string">&#x27;say&#x27;</span>, <span class="string">&#x27;meow&#x27;</span>, target)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instantiateCat = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> say = <span class="built_in">Reflect</span>.getMetadata(<span class="string">&#x27;say&#x27;</span>, Cat)</span><br><span class="line">  <span class="built_in">console</span>.log(say) <span class="comment">// meow</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">instantiateCat()</span><br></pre></td></tr></table></figure>
<p>通过以上这个例子可以看到， <code>Injectable</code> 通过 <code>Reflect.defineMetadata</code> 给 <code>Cat</code> 加了个 key 为 <code>say</code> 的 metadata</p>
<p>而在实例化的时候，通过 <code>Reflect.getMetadata</code> 就可以拿到定义的 metadata 了</p>
<p>那么，我们如果把 <code>constructor</code> 的参数定义为 metadata ，在实例化的时候也就知道要传入哪些参数了，就像下面的例子：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;reflect-metadata&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Injectable = <span class="function">(<span class="params">constructorArguments: <span class="built_in">any</span>[]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Reflect</span>.defineMetadata(<span class="string">&#x27;args&#x27;</span>, <span class="title">constructorArguments</span>, <span class="title">target</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title">class</span> <span class="title">Tail</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>([Tail])</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> <span class="keyword">readonly</span> tail: Tail,</span></span><br><span class="line"><span class="params">  </span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instantiateCat = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> args = <span class="built_in">Reflect</span>.getMetadata(<span class="string">&#x27;args&#x27;</span>, Cat)</span><br><span class="line">  <span class="built_in">console</span>.log(args) <span class="comment">// [Tail]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">instantiateCat()</span><br></pre></td></tr></table></figure>
<p>但很显然，我们实际在写 Angular 或者 nest 的时候，是不会给 <code>Injectable</code> 传入 <code>constructor</code> 的参数的，那框架是如何知道参数信息的？</p>
<p>以下就是黑魔法了</p>
<h2 id="emitDecoratorMetadata"><a href="#emitDecoratorMetadata" class="headerlink" title="emitDecoratorMetadata"></a>emitDecoratorMetadata</h2><p>tsconfig 里有这么一个配置 <a href="https://www.typescriptlang.org/tsconfig#emitDecoratorMetadata"><code>emitDecoratorMetadata</code></a> ，没有想了解依赖注入之前，完全没注意到这个是干啥的，加上官网文档中，其属于实验性的 API ，就更没想要了解了。</p>
<p>不过官网也指明了这个选项是跟 <code>reflect-metadata</code> 配合的，明显是我们要了解的、跟依赖注入有关的选项。</p>
<p>让我们接着以上的例子来说明，先把 <code>emitDecoratorMetadata</code> 在 <code>tsconfig.json</code> 中打开，然后运行以下示例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;reflect-metadata&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Injectable = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 移除 Reflect.defineMetadata</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tail</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除参数</span></span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> <span class="keyword">readonly</span> tail: Tail,</span></span><br><span class="line"><span class="params">  </span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instantiateCat = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// args 改为 design:paramtypes</span></span><br><span class="line">  <span class="keyword">const</span> args = <span class="built_in">Reflect</span>.getMetadata(<span class="string">&#x27;design:paramtypes&#x27;</span>, Cat)</span><br><span class="line">  <span class="built_in">console</span>.log(args) <span class="comment">// [Tail]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">instantiateCat()</span><br></pre></td></tr></table></figure>
<p>可以发现，我们把 <code>Injectable</code> 的参数去掉了，把 <code>Reflect.defineMetadata</code> 也移除了，效果还是一样，能读取到 <code>constructor</code> 的参数</p>
<p>ohhhhhhhhhhh</p>
<p>这时候可能会有个疑问， <code>Injectable</code> 啥也没做啊，能不能移除掉</p>
<p>答案当然是 不一定能</p>
<p>因为 <code>emitDecoratorMetadata</code> 选项是针对装饰器的，没有装饰器了，就没有作用了</p>
<p>当然，如果随便加一个其他乱七八糟的装饰器，那还是会起作用的</p>
<p>那么 <code>emitDecoratorMetadata</code> 这个黑魔法做了啥呢？我们在 TypeScript Playground 把代码贴上去看看会生成什么样的 JS 代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> __decorate = (<span class="built_in">this</span> &amp;&amp; <span class="built_in">this</span>.__decorate) || <span class="function"><span class="keyword">function</span> (<span class="params">decorators, target, key, desc</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="built_in">arguments</span>.length, r = c &lt; <span class="number">3</span> ? target : desc === <span class="literal">null</span> ? desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(target, key) : desc, d;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Reflect</span> === <span class="string">&quot;object&quot;</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Reflect</span>.decorate === <span class="string">&quot;function&quot;</span>) r = <span class="built_in">Reflect</span>.decorate(decorators, target, key, desc);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">for</span> (<span class="keyword">var</span> i = decorators.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) <span class="keyword">if</span> (d = decorators[i]) r = (c &lt; <span class="number">3</span> ? d(r) : c &gt; <span class="number">3</span> ? d(target, key, r) : d(target, key)) || r;</span><br><span class="line">    <span class="keyword">return</span> c &gt; <span class="number">3</span> &amp;&amp; r &amp;&amp; <span class="built_in">Object</span>.defineProperty(target, key, r), r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***** 重点1 ******</span></span><br><span class="line"><span class="keyword">var</span> __metadata = (<span class="built_in">this</span> &amp;&amp; <span class="built_in">this</span>.__metadata) || <span class="function"><span class="keyword">function</span> (<span class="params">k, v</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Reflect.metadata 是 Reflect.defineMetadata 的装饰器版本</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Reflect</span> === <span class="string">&quot;object&quot;</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Reflect</span>.metadata === <span class="string">&quot;function&quot;</span>) <span class="keyword">return</span> <span class="built_in">Reflect</span>.metadata(k, v);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;reflect-metadata&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> Injectable = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tail</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> Cat = <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">tail</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.tail = tail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Cat = __decorate([</span><br><span class="line">    Injectable(),</span><br><span class="line">    <span class="comment">// ****** 重点2 ******</span></span><br><span class="line">    __metadata(<span class="string">&quot;design:paramtypes&quot;</span>, [Tail])</span><br><span class="line">], Cat);</span><br><span class="line"><span class="keyword">const</span> instantiateCat = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> args = <span class="built_in">Reflect</span>.getMetadata(<span class="string">&#x27;design:paramtypes&#x27;</span>, Cat);</span><br><span class="line">    <span class="built_in">console</span>.log(args); <span class="comment">// [Tail]</span></span><br><span class="line">&#125;;</span><br><span class="line">instantiateCat();</span><br></pre></td></tr></table></figure>
<p>可以看到，生成的代码自动给我们加上了类似 <code>Reflect.defineMetadata(&#39;design:paramtypes&#39;, [Tail], Cat)</code> 的片段</p>
<p>所以后续实例化时，我们依然可以通过 <code>Reflect.getMetadata</code> 获取 <code>constructor</code> 参数</p>
<p><code>emitDecoratorMetadata</code> 会给 metadata 加上哪些 key ？</p>
<p>根据 TypeScript 官网文档：</p>
<blockquote>
<p>When enabled, as long as the reflect-metadata library has been imported, additional design-time type information will be exposed at runtime.</p>
</blockquote>
<p>一些设计时的类型(design-time type)会被暴露在运行时，从 <a href="https://www.typescriptlang.org/tsconfig#emitDecoratorMetadata">tsconfig 文档</a>中看，有这么几种：</p>
<ul>
<li>design:type</li>
<li>design:paramtypes</li>
<li>design:returntype</li>
</ul>
<p>本文用到的只有 <code>design:paramtypes</code> ，有关其他类型的 metadata ，请参阅 TypeScript 文档</p>
<p>至此，整个黑魔法就解释完了</p>
<h1 id="其他疑问"><a href="#其他疑问" class="headerlink" title="其他疑问"></a>其他疑问</h1><p>关于 TypeScript 依赖注入的黑魔法是清楚了，实际上，因为语言本身不支持，加上用得不多，所以第一次了解下来会感觉很魔幻，在其他语言中应该是很平常的做法。</p>
<p>还有一个跟依赖注入原理关系不大的问题：</p>
<p><code>Injectable</code> 就这么放空？</p>
<p>当然不是，根据本人的合理推断， <code>Injectable</code> 内部做的应该是把当前 class 注册到管理依赖注入的系统中，提供给其他 class 注入使用。</p>
<p>以下是对这个猜想不负责任的一个简单实现，不代表框架内部就是这样做的</p>
<iframe src="https://codesandbox.io/embed/modern-lake-3r7u9?expanddevtools=1&fontsize=14&hidenavigation=1&module=%2Fsrc%2Findex.ts&theme=dark"
     style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;"
     title="modern-lake-3r7u9"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
   ></iframe>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;reflect-metadata&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> providers: <span class="built_in">any</span>[] = []</span><br><span class="line"><span class="keyword">const</span> instanceMap = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Injectable = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!providers.includes(target)) &#123;</span><br><span class="line">      providers.push(target)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Yarn</span> </span>&#123;</span><br><span class="line">  roll () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;yarn roll!&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tail</span> </span>&#123;</span><br><span class="line">  wag () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;wag!&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> <span class="keyword">readonly</span> tail: Tail,</span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> <span class="keyword">readonly</span> yarn: Yarn,</span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    tail.wag()</span><br><span class="line">    yarn.roll()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instantiate = <span class="function">(<span class="params">target: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> args = <span class="built_in">Reflect</span>.getMetadata(<span class="string">&#x27;design:paramtypes&#x27;</span>, target)</span><br><span class="line">  <span class="keyword">const</span> ctorArgs = (args || []).map(<span class="function">(<span class="params">arg: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!providers.includes(arg)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`<span class="subst">$&#123;arg&#125;</span> not injectable`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> cache = instanceMap.get(arg)</span><br><span class="line">    <span class="keyword">if</span> (cache) <span class="keyword">return</span> cache</span><br><span class="line">    <span class="keyword">const</span> instance = instantiate(arg)</span><br><span class="line">    instanceMap.set(arg, instance)</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> target(...ctorArgs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instantiateCat = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> instantiate(Cat)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">instantiateCat()</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://github.com/rbuckton/reflect-metadata">reflect-metadata</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Meta_programming">Meta programming - JavaScript | MDN</a></li>
<li><a href="https://en.wikipedia.org/wiki/Metaprogramming">Metaprogramming - Wikipedia</a></li>
<li><a href="https://www.typescriptlang.org/docs/handbook/decorators.html#metadata">TypeScript: Documentation - Decorators</a></li>
<li><a href="https://www.typescriptlang.org/tsconfig#emitDecoratorMetadata">TypeScript: TSConfig Reference - Docs on every TSConfig option</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
</search>
